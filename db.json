{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/pander.jpg","path":"images/pander.jpg","modified":0,"renderable":0},{"_id":"source/images/title.ico","path":"images/title.ico","modified":0,"renderable":0},{"_id":"source/images/title.png","path":"images/title.png","modified":0,"renderable":0},{"_id":"source/images/vuex.jpg","path":"images/vuex.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/bg.jpg","path":"images/bg.jpg","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/bg.webp","path":"images/bg.webp","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/default-avatar.jpg","path":"images/default-avatar.jpg","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/default-avatar.webp","path":"images/default-avatar.webp","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/icons/css_cloud.png","path":"images/icons/css_cloud.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/icons/css_doorframe.png","path":"images/icons/css_doorframe.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/icons/css_pattern_bottom.png","path":"images/icons/css_pattern_bottom.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/icons/css_patterns.png","path":"images/icons/css_patterns.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/icons/css_tag.png","path":"images/icons/css_tag.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/icons/css_texture.png","path":"images/icons/css_texture.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/images/icons/css_window_frame.png","path":"images/icons/css_window_frame.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/images/title.ico","hash":"ce7e52d02e89940d8a03b0b987dde0728009dd5f","modified":1637902796759},{"_id":"source/images/title.png","hash":"a217992356d0c7c38ae7391b8276a31e25c15244","modified":1637902837054},{"_id":"source/images/vuex.jpg","hash":"178e2532d5b3f2498fd76a2b3df6ea8fb2de175f","modified":1637918554778},{"_id":"source/_posts/BFC.md","hash":"a3fdd7bf0671d34a5319a6810b23004b4a848c26","modified":1637908529949},{"_id":"source/_posts/ES6.md","hash":"1beeb487acd71b930f8534f2d272e0890a0f7303","modified":1637916254277},{"_id":"source/_posts/JS基本语法.md","hash":"3cdf7074be32c8503e82b4115e8d75b4e52d6303","modified":1637910761584},{"_id":"source/_posts/blog.md","hash":"cabfd41097dae368d3fd44995c5b76c4d608516f","modified":1637917352278},{"_id":"source/_posts/css3D转换和关键帧动画.md","hash":"7afea6191fc810c565bf1f8e429c067ca363f8a9","modified":1637907226616},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1637896300617},{"_id":"source/_posts/localStorage本地存储.md","hash":"66400464c00c0e138a6bc8dd5e45a460cfb66d8e","modified":1637917268995},{"_id":"source/_posts/vue随笔.md","hash":"5839f784d9e23d203b14981778930602b332dc92","modified":1638155375844},{"_id":"source/_posts/事件Event.md","hash":"edf27a71f5e23c57f798f4cb05495fc7b6057f98","modified":1637911046326},{"_id":"source/_posts/元素类型.md","hash":"536e69adf87961da0d382451af7d0a5e7fe0bbfe","modified":1637906546472},{"_id":"source/_posts/关于ES5和字符串string.md","hash":"82ad6b7fe2f286b8b8804147b99556359f6c902c","modified":1637909685540},{"_id":"source/_posts/关于vue.md","hash":"15d0bbb95592a241a34b668a5dfad1c04a025f76","modified":1637918130466},{"_id":"source/_posts/关于HTTP.md","hash":"269507847ff287c37afc505343d6a1b783066f34","modified":1637917393052},{"_id":"source/_posts/关于vuex.md","hash":"e5dec773f9d6c976708c01bbd5151fb2a248ad3e","modified":1637919006925},{"_id":"source/_posts/关于闭包.md","hash":"fc6ea1ec4f46461c6468e380348980c4687a7358","modified":1638157253479},{"_id":"source/_posts/函数.md","hash":"5bf7c9e6d2a4f65c2c23facf68949926c688eef4","modified":1637908050023},{"_id":"source/_posts/奶茶.md","hash":"72c19cc817a7a7b784fb48d79a13e4c8a49e78d5","modified":1638160977517},{"_id":"source/_posts/浏览器兼容和精灵图.md","hash":"66c7c96680760ce2c6c5da76e4a554ab714fd3bc","modified":1637916663660},{"_id":"source/_posts/数组.md","hash":"fc019461300ae4cfd5900a68fff3181c199241fb","modified":1637910494864},{"_id":"source/_posts/盒模型.md","hash":"35a139a2bb7a6c0423ad1ff98c9658ddb1172c8b","modified":1637908356271},{"_id":"source/_posts/移动端布局.md","hash":"dcdfeb393dd70c3fc0fc99b0f5a29bcccda6480e","modified":1637915104190},{"_id":"source/_posts/面向对象.md","hash":"c13e4f22b45f4db9fac2472129166967b3f59f39","modified":1637916874930},{"_id":"source/images/pander.jpg","hash":"255a66b7f07f2e773ee72412ff49b10914711834","modified":1637898755058},{"_id":"themes/yilia/.DS_Store","hash":"8c4701d8dd61c665de261240f293596bcc1dd337","modified":1637900623605},{"_id":"themes/yilia/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1637900623605},{"_id":"themes/yilia/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1637900623605},{"_id":"themes/yilia/README.md","hash":"3f9efabfa0c520f4c451f51449ba605ba301e6ff","modified":1637900623605},{"_id":"themes/yilia/_config.yml","hash":"8154cebb9145050eb6fa3e700da1b2f9be1a411f","modified":1637903114055},{"_id":"themes/yilia/package.json","hash":"63eabb0618958d990743a7dce359e8bdfacef302","modified":1637900623615},{"_id":"themes/yilia/layout/.DS_Store","hash":"6d0dff98dc62cd330641a53442988bc5a162ee95","modified":1637900623609},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1637900623614},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1637900623614},{"_id":"themes/yilia/layout/layout.ejs","hash":"750bdbbbfbda57f354cf9d1942f689fc318f7b85","modified":1637900623615},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1637900623615},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1637900623614},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1637900623615},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1637900623615},{"_id":"themes/yilia/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1637900623606},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1637900623606},{"_id":"themes/yilia/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1637900623606},{"_id":"themes/yilia/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1637900623607},{"_id":"themes/yilia/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1637900623606},{"_id":"themes/yilia/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1637900623607},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1637900623607},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1637900623607},{"_id":"themes/yilia/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1637900623607},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1637900623607},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"365e67a591419e5367b3ab438ae178daaece72d7","modified":1637900623608},{"_id":"themes/yilia/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1637900623609},{"_id":"themes/yilia/scripts/fancybox.js","hash":"629c3bbc17cc7fe4b8513f8dad6873c1d9a114c5","modified":1637900623615},{"_id":"themes/yilia/scripts/highlight.js","hash":"c0c4dcc78f2abaf149cb934186b087f16402198a","modified":1637900623616},{"_id":"themes/yilia/source/.DS_Store","hash":"99fba842ea69f6c482eebaa777273e75c107667d","modified":1637900623616},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"75f951e6e8aa192a754e22af11caf6492c1ea75f","modified":1637900623609},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"3c0f5ea9ac44f0d071825d0f133808ea2d3d0e6e","modified":1637900623610},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"88f7662e9d46f329b7d29bc9311935f757932c6f","modified":1637900623610},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"fa31dcb2601ee9fd6aec3a2344af1b766e2d509b","modified":1637900623610},{"_id":"themes/yilia/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1637900623611},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8a06b4905968413f9e3701dbe7f151e6c589495c","modified":1637900623610},{"_id":"themes/yilia/layout/_partial/gitment.ejs","hash":"628d8adee8199cc0f76f9e96a42cdaee46ba7756","modified":1637900623611},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1637900623611},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"2a393b9a494171c48dc00da91ad88c7f0a1ebae7","modified":1637900623611},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"dd06463e87fd6d9d6e8935c33fc3c0acbc075483","modified":1637900623611},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"d73066a84879781256b0be18b37477c185bd5022","modified":1637900623612},{"_id":"themes/yilia/layout/_partial/sidebar.ejs","hash":"a146f0c042211e30aa35a025feea3a66342afefc","modified":1637900623613},{"_id":"themes/yilia/layout/_widget/archive.ejs","hash":"bd245a425bcf2f5f6caece2e0702c56ebf477dcc","modified":1637900623613},{"_id":"themes/yilia/layout/_widget/blogroll.ejs","hash":"62ad592473b2754f6f820fc6b05a74fc5f941cc0","modified":1637900623613},{"_id":"themes/yilia/layout/_widget/category.ejs","hash":"6bc8348c356e0d80c92b66bc0f3eb051462341bc","modified":1637900623613},{"_id":"themes/yilia/layout/_widget/recent_posts.ejs","hash":"6af428e72ea8ab33788aec1a86a8cabd1ddb1c06","modified":1637900623613},{"_id":"themes/yilia/layout/_widget/tag.ejs","hash":"17d9e79c460f5a071e279feed94c8838e62fc661","modified":1637900623614},{"_id":"themes/yilia/layout/_widget/tagcloud.ejs","hash":"22bc741ab452749dea32e2592551362f3cc827fc","modified":1637900623614},{"_id":"themes/yilia/layout/_widget/userinfo.ejs","hash":"feaedc51844b74dc861572f74b85797b45cf07ef","modified":1637900623614},{"_id":"themes/yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1637900623617},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1637900623617},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1637900623618},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1637900623618},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1637900623618},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1637900623618},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1637900623620},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1637900623620},{"_id":"themes/yilia/source/css/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1637900623616},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1637900623620},{"_id":"themes/yilia/source/css/gitment.css","hash":"cdc2ace67fb3f1a74ce5cbeaf175e192e905955b","modified":1637900623616},{"_id":"themes/yilia/source/css/highlight.css","hash":"982c0d5beda4b6c8f703948e658a73da0a7b0f9b","modified":1637900623617},{"_id":"themes/yilia/source/css/style.css","hash":"4d850e41486fd2629287c4aaf0e328df10e43b47","modified":1637900623617},{"_id":"themes/yilia/source/js/script.js","hash":"94e04303419a61a10f2999f33f8085879f3cdb05","modified":1637900623630},{"_id":"themes/yilia/source/images/.DS_Store","hash":"5431738d0c753c190549005feaeb87b6da96566d","modified":1637900623621},{"_id":"themes/yilia/source/images/default-avatar.jpg","hash":"93e8abd83d87278933a668806e169f8378bdf197","modified":1637900623625},{"_id":"themes/yilia/source/images/default-avatar.webp","hash":"7e8038610eaf540c08764e848350bb4df8a3dd10","modified":1637900623625},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1637900623612},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1637900623612},{"_id":"themes/yilia/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1637900623612},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1637900623612},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1637900623613},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"54d88188fe5daa3a1b3a76ca8e43a361a98767cd","modified":1637900623612},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1637900623619},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1637900623619},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1637900623619},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1637900623619},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1637900623620},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1637900623620},{"_id":"themes/yilia/source/images/icons/.DS_Store","hash":"abc4ebcfd8325a4225fd09ad358633f7d5adcac4","modified":1637900623626},{"_id":"themes/yilia/source/images/icons/css_cloud.png","hash":"df67b83b62174a2965628d81abe9b8a5c4a89728","modified":1637900623626},{"_id":"themes/yilia/source/images/icons/css_doorframe.png","hash":"f5cbaefd062abc90337148e0e593949e0b1d6b2a","modified":1637900623626},{"_id":"themes/yilia/source/images/icons/css_pattern_bottom.png","hash":"ff30fbc4ee81471ff3e44c2a8e15ba121e995f78","modified":1637900623626},{"_id":"themes/yilia/source/images/icons/css_patterns.png","hash":"9345361fe1c631c74022759189bc44aa4a7053df","modified":1637900623627},{"_id":"themes/yilia/source/images/icons/css_tag.png","hash":"25e3e0f37f0a86cf06463063e0f5381442d1a72a","modified":1637900623627},{"_id":"themes/yilia/source/images/icons/css_texture.png","hash":"874074999995e6981d7602a7d5a770043a10b932","modified":1637900623627},{"_id":"themes/yilia/source/images/icons/css_window_frame.png","hash":"7f985fc949cbecaf12982327d4b14e684bc2b205","modified":1637900623628},{"_id":"themes/yilia/source/js/jquery-2.0.3.min.js","hash":"bbc61d6a6dd66b913c6f237f29475a889fbe3015","modified":1637900623630},{"_id":"themes/yilia/source/js/gitment.js","hash":"b15998a45d5f386d30905cfbfbb1658336acbb5b","modified":1637900623629},{"_id":"themes/yilia/source/images/bg.webp","hash":"782caa6411f07e19461a6a8b76897e058fd0e246","modified":1637900623625},{"_id":"themes/yilia/source/images/bg.jpg","hash":"d098391d1d2b19f09dbf24869d066b2fba300553","modified":1637900623623},{"_id":"public/9999/09/09/奶茶/index.html","hash":"87af673aabcf984dd845501ee2cfc454f3ece5db","modified":1638163212464},{"_id":"public/2021/11/29/hello-world/index.html","hash":"dc6aac4b9b8398a05e4ce2816ad117571f57dee2","modified":1638163212464},{"_id":"public/2020/06/18/关于vue/index.html","hash":"a10b4008da197e15b464bda00f41ead46d0c1513","modified":1638163212464},{"_id":"public/2020/05/21/关于HTTP/index.html","hash":"cac37612cd21b51f62bd54d2d0d0a681abac6a74","modified":1638163212464},{"_id":"public/2019/11/06/BFC/index.html","hash":"d239d2f3cedabe74ba55a724d40af5274597ee45","modified":1638163212464},{"_id":"public/2019/10/21/元素类型/index.html","hash":"1cbdcc3d565be85c5486668657e7f73c0ac824f6","modified":1638163212464},{"_id":"public/2019/10/19/blog/index.html","hash":"470d83498dac9d1b9de09255b26092c4c09da25c","modified":1638163212464},{"_id":"public/archives/page/3/index.html","hash":"7e02aefbdec696c7b8c2037621f5df12eeb4380d","modified":1638163212464},{"_id":"public/archives/2019/10/index.html","hash":"78a7b9663ed1319765f0a9582becdaf9a5a86b9a","modified":1638163212464},{"_id":"public/archives/2019/11/index.html","hash":"0df637156e805d73f3d43ebbea43f81b6705fc09","modified":1638163212464},{"_id":"public/archives/2019/12/index.html","hash":"41e75650efd78d0fbef04d9a4fdbbbe3a9352774","modified":1638163212464},{"_id":"public/archives/2020/01/index.html","hash":"078a577ce9f7e03c179d796be6feb818467afccd","modified":1638163212464},{"_id":"public/archives/2020/02/index.html","hash":"603726dc634571b3facbbe30cd514053f462eb67","modified":1638163212464},{"_id":"public/archives/2020/03/index.html","hash":"a7a93c614e959cc64cae9d419bc5aa1d702bda56","modified":1638163212464},{"_id":"public/archives/2020/04/index.html","hash":"c23531d7232e874c77dd8fab9cfd669003a97c63","modified":1638163212464},{"_id":"public/archives/2020/05/index.html","hash":"41dd678ba364acf459c8948586fdabf1c059ed26","modified":1638163212464},{"_id":"public/archives/2020/06/index.html","hash":"492de685c8c4e2a14e6a5e3a8740997abbaa64b9","modified":1638163212464},{"_id":"public/archives/2020/07/index.html","hash":"07bd06d827924226d6ac7d7116d009a344326126","modified":1638163212464},{"_id":"public/archives/2021/index.html","hash":"dea617e9cc077b6cc241928147aa66c3352d28e5","modified":1638163212464},{"_id":"public/archives/2021/11/index.html","hash":"3fe08f2ee16a8819d5d8ab7c26ae9408a5303c36","modified":1638163212464},{"_id":"public/archives/9999/index.html","hash":"56b5d23ed1d750587c725103eb347a1f0d17dbd3","modified":1638163212464},{"_id":"public/archives/9999/09/index.html","hash":"f5dec6c031399c37a4cf9292441ee92b600b5df3","modified":1638163212464},{"_id":"public/tags/css、BFC/index.html","hash":"4009ccab85e47f23c4edc2cba8e1260d8979d873","modified":1638163212464},{"_id":"public/tags/javaScript、es6/index.html","hash":"ae06447ae2735cca0618748b1bea5cc0a16f530a","modified":1638163212464},{"_id":"public/tags/blog、bash/index.html","hash":"5e667cad6915262aa1ffeb02880a47b6380f5446","modified":1638163212464},{"_id":"public/tags/javaScript/index.html","hash":"4dcfb13bfe0c04a2495280aabb998135157e6bb8","modified":1638163212464},{"_id":"public/tags/css/index.html","hash":"b573e4d8bcea34ed6d34fe39f1ac36e50a66808c","modified":1638163212464},{"_id":"public/tags/vue/index.html","hash":"b8f4894ddda4574f029bb6144d3a4a9cb57c87c1","modified":1638163212464},{"_id":"public/tags/js/index.html","hash":"43b23363e7a898880053dcf493b153cfe3ab7ae8","modified":1638163212464},{"_id":"public/tags/HTTP/index.html","hash":"75a2ba86bbfe206618d34898da22d1a789b195dc","modified":1638163212464},{"_id":"public/tags/vuex/index.html","hash":"69fca40e0931a97f46a22d0d658f3fac601ff8c2","modified":1638163212464},{"_id":"public/tags/javaScript、css/index.html","hash":"e1460e49a402f344ea137a0e40f3b6f54e4d4027","modified":1638163212464},{"_id":"public/tags/javaScript、Array/index.html","hash":"e050b100c3478e87b37076a864d81b9fc706b255","modified":1638163212464},{"_id":"public/tags/css、盒模型/index.html","hash":"e06e39f0a62e404ff3323d0e302e60a49e2ab643","modified":1638163212464},{"_id":"public/tags/html、css/index.html","hash":"de6e19a82e0efea5f8d19c5a8b3a271e2754d206","modified":1638163212464},{"_id":"public/page/3/index.html","hash":"b2074abb10bfcde7f761bebf7f59f611cf88c076","modified":1638163212464},{"_id":"public/2020/07/11/关于vuex/index.html","hash":"24e6d0100cef085a376d2a54fa36aece4f85c119","modified":1638163212464},{"_id":"public/2020/06/13/vue随笔/index.html","hash":"904389c90298077e4ed11eab55ee28832c5b7e05","modified":1638163212464},{"_id":"public/2020/05/15/localStorage本地存储/index.html","hash":"73eba79833387b6bb24458122adedf6ca79e1509","modified":1638163212464},{"_id":"public/2020/04/18/关于闭包/index.html","hash":"56df97168edb12e29a298d501d3eea237053631a","modified":1638163212464},{"_id":"public/2020/04/14/面向对象/index.html","hash":"6b673d85a05571b88c0db2ef51db6c6e0d4bc497","modified":1638163212464},{"_id":"public/2020/03/22/浏览器兼容和精灵图/index.html","hash":"bb8c168f6e4195ac686ffe3340aa75c4ab34d420","modified":1638163212464},{"_id":"public/2020/02/08/ES6/index.html","hash":"b1a15655101fc682a152354dc1d055150bd7a211","modified":1638163212464},{"_id":"public/2020/01/12/移动端布局/index.html","hash":"5fa94cd4cee4d06eda4129cd3f619e2f83db7fd6","modified":1638163212464},{"_id":"public/2019/12/11/事件Event/index.html","hash":"416f7be6194ae7f6672ee0f739a582a91a0de673","modified":1638163212464},{"_id":"public/2019/11/30/JS基本语法/index.html","hash":"546c1083421affecf2dd75a954442956e08cfd0b","modified":1638163212464},{"_id":"public/2019/11/22/数组/index.html","hash":"44b75e7fee73c65e757e09274a7cdf4af976de49","modified":1638163212464},{"_id":"public/2019/11/15/关于ES5和字符串string/index.html","hash":"b97df2293838704d43dba45b6c4a0010008170eb","modified":1638163212464},{"_id":"public/2019/10/26/盒模型/index.html","hash":"1be75a54d02b3815f17d994d563e258d2152a772","modified":1638163212464},{"_id":"public/2019/10/24/函数/index.html","hash":"d1a06863bed3e51adf25859775a0c986be61f247","modified":1638163212464},{"_id":"public/2019/10/22/css3D转换和关键帧动画/index.html","hash":"cef7f20debab6e30168b185c158f9854a5a46f7d","modified":1638163212464},{"_id":"public/archives/index.html","hash":"8245593222bcfcf053d3cb931cc6a28f1aefa652","modified":1638163212464},{"_id":"public/archives/page/2/index.html","hash":"200602e35d06652311f4db882beaa3060dac7d58","modified":1638163212464},{"_id":"public/archives/2019/index.html","hash":"827a1fdc87f9d073d22779f6b66ecc92d6d90f4f","modified":1638163212464},{"_id":"public/archives/2020/index.html","hash":"88881ab96deb0165aab8f3ec009685178b396fba","modified":1638163212464},{"_id":"public/index.html","hash":"d4ea1b2ad892dac026f2ce2f3fdabc812e2c42e6","modified":1638163212464},{"_id":"public/page/2/index.html","hash":"95887f702ecf1401f0db549ac5443f7ddde0c5d6","modified":1638163212464},{"_id":"public/images/title.ico","hash":"ce7e52d02e89940d8a03b0b987dde0728009dd5f","modified":1638163212464},{"_id":"public/images/title.png","hash":"a217992356d0c7c38ae7391b8276a31e25c15244","modified":1638163212464},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1638163212464},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1638163212464},{"_id":"public/images/vuex.jpg","hash":"178e2532d5b3f2498fd76a2b3df6ea8fb2de175f","modified":1638163212464},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1638163212464},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1638163212464},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1638163212464},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1638163212464},{"_id":"public/images/default-avatar.jpg","hash":"93e8abd83d87278933a668806e169f8378bdf197","modified":1638163212464},{"_id":"public/images/default-avatar.webp","hash":"7e8038610eaf540c08764e848350bb4df8a3dd10","modified":1638163212464},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1638163212464},{"_id":"public/images/icons/css_cloud.png","hash":"df67b83b62174a2965628d81abe9b8a5c4a89728","modified":1638163212464},{"_id":"public/images/icons/css_pattern_bottom.png","hash":"ff30fbc4ee81471ff3e44c2a8e15ba121e995f78","modified":1638163212464},{"_id":"public/images/icons/css_tag.png","hash":"25e3e0f37f0a86cf06463063e0f5381442d1a72a","modified":1638163212464},{"_id":"public/images/icons/css_doorframe.png","hash":"f5cbaefd062abc90337148e0e593949e0b1d6b2a","modified":1638163212464},{"_id":"public/images/icons/css_patterns.png","hash":"9345361fe1c631c74022759189bc44aa4a7053df","modified":1638163212464},{"_id":"public/images/icons/css_texture.png","hash":"874074999995e6981d7602a7d5a770043a10b932","modified":1638163212464},{"_id":"public/images/icons/css_window_frame.png","hash":"7f985fc949cbecaf12982327d4b14e684bc2b205","modified":1638163212464},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1638163212464},{"_id":"public/css/highlight.css","hash":"358c8414fbc5eafa50fddfb67dbd6159d54e40ec","modified":1638163212464},{"_id":"public/css/style.css","hash":"2603b303d42facdff262ae26be036e49c3b79576","modified":1638163212464},{"_id":"public/js/script.js","hash":"00e5e2b43068555a83d09f7713c7194dfd8b8889","modified":1638163212464},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1638163212464},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1638163212464},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1638163212464},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1638163212464},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1638163212464},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1638163212464},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1638163212464},{"_id":"public/css/gitment.css","hash":"e55f6e10aa635347ca5d9a610f12d295dbdc824f","modified":1638163212464},{"_id":"public/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1638163212464},{"_id":"public/js/jquery-2.0.3.min.js","hash":"fbf9c77d0c4e3c34a485980c1e5316b6212160c8","modified":1638163212464},{"_id":"public/images/bg.webp","hash":"782caa6411f07e19461a6a8b76897e058fd0e246","modified":1638163212464},{"_id":"public/images/pander.jpg","hash":"255a66b7f07f2e773ee72412ff49b10914711834","modified":1638163212464},{"_id":"public/images/bg.jpg","hash":"d098391d1d2b19f09dbf24869d066b2fba300553","modified":1638163212464}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"盒模型","date":"2019-11-05T16:00:00.000Z","_content":"\n### 什么是 BFC\n\nBFC(Block formatting context)译为”块格式化上下文”，是一个独立的渲染区域，规定了内部的子元素如何布局，并且与这个区域外部毫不相干。\n\n<!--more--> \n\n### 哪些元素会生成 BFC\n\n1. 根元素 html\n2. float 属性不为 none\n3. position 为 absolute 或 fixed\n4. display 为 inline-block, table-cell, table-caption, flex, inline-flex\n5. overflow 不为 visible（除非该值已经被传播到视口）\n\n### BFC 布局规则是怎样的\n\n1. 内部的 Box 会在垂直方向，一个接一个地放置。\n2. Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n3. 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n4. BFC 的区域不会与 float box 重叠。\n5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n6. 计算 BFC 的高度时，浮动元素也参与计算\n7. 并不是只有块元素才会生成 BFC，任何元素只要符合条件即可生成 BFC\n\n### BFC 的应用\n\n1. 自适应两栏布局\n2. 清除内部浮动\n3. 防止 margin 上下重叠\n\n---\n\n本文作者： 一只野生东子","source":"_posts/BFC.md","raw":"---\ntitle: 盒模型\ndate: 2019-11-06\ntags: css、BFC\n---\n\n### 什么是 BFC\n\nBFC(Block formatting context)译为”块格式化上下文”，是一个独立的渲染区域，规定了内部的子元素如何布局，并且与这个区域外部毫不相干。\n\n<!--more--> \n\n### 哪些元素会生成 BFC\n\n1. 根元素 html\n2. float 属性不为 none\n3. position 为 absolute 或 fixed\n4. display 为 inline-block, table-cell, table-caption, flex, inline-flex\n5. overflow 不为 visible（除非该值已经被传播到视口）\n\n### BFC 布局规则是怎样的\n\n1. 内部的 Box 会在垂直方向，一个接一个地放置。\n2. Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n3. 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n4. BFC 的区域不会与 float box 重叠。\n5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n6. 计算 BFC 的高度时，浮动元素也参与计算\n7. 并不是只有块元素才会生成 BFC，任何元素只要符合条件即可生成 BFC\n\n### BFC 的应用\n\n1. 自适应两栏布局\n2. 清除内部浮动\n3. 防止 margin 上下重叠\n\n---\n\n本文作者： 一只野生东子","slug":"BFC","published":1,"updated":"2021-11-26T06:35:29.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2300009co31033bf8q","content":"<h3 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h3><p>BFC(Block formatting context)译为”块格式化上下文”，是一个独立的渲染区域，规定了内部的子元素如何布局，并且与这个区域外部毫不相干。</p>\n<span id=\"more\"></span> \n\n<h3 id=\"哪些元素会生成-BFC\"><a href=\"#哪些元素会生成-BFC\" class=\"headerlink\" title=\"哪些元素会生成 BFC\"></a>哪些元素会生成 BFC</h3><ol>\n<li>根元素 html</li>\n<li>float 属性不为 none</li>\n<li>position 为 absolute 或 fixed</li>\n<li>display 为 inline-block, table-cell, table-caption, flex, inline-flex</li>\n<li>overflow 不为 visible（除非该值已经被传播到视口）</li>\n</ol>\n<h3 id=\"BFC-布局规则是怎样的\"><a href=\"#BFC-布局规则是怎样的\" class=\"headerlink\" title=\"BFC 布局规则是怎样的\"></a>BFC 布局规则是怎样的</h3><ol>\n<li>内部的 Box 会在垂直方向，一个接一个地放置。</li>\n<li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>\n<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC 的区域不会与 float box 重叠。</li>\n<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算 BFC 的高度时，浮动元素也参与计算</li>\n<li>并不是只有块元素才会生成 BFC，任何元素只要符合条件即可生成 BFC</li>\n</ol>\n<h3 id=\"BFC-的应用\"><a href=\"#BFC-的应用\" class=\"headerlink\" title=\"BFC 的应用\"></a>BFC 的应用</h3><ol>\n<li>自适应两栏布局</li>\n<li>清除内部浮动</li>\n<li>防止 margin 上下重叠</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h3><p>BFC(Block formatting context)译为”块格式化上下文”，是一个独立的渲染区域，规定了内部的子元素如何布局，并且与这个区域外部毫不相干。</p>","more":"<h3 id=\"哪些元素会生成-BFC\"><a href=\"#哪些元素会生成-BFC\" class=\"headerlink\" title=\"哪些元素会生成 BFC\"></a>哪些元素会生成 BFC</h3><ol>\n<li>根元素 html</li>\n<li>float 属性不为 none</li>\n<li>position 为 absolute 或 fixed</li>\n<li>display 为 inline-block, table-cell, table-caption, flex, inline-flex</li>\n<li>overflow 不为 visible（除非该值已经被传播到视口）</li>\n</ol>\n<h3 id=\"BFC-布局规则是怎样的\"><a href=\"#BFC-布局规则是怎样的\" class=\"headerlink\" title=\"BFC 布局规则是怎样的\"></a>BFC 布局规则是怎样的</h3><ol>\n<li>内部的 Box 会在垂直方向，一个接一个地放置。</li>\n<li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>\n<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC 的区域不会与 float box 重叠。</li>\n<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算 BFC 的高度时，浮动元素也参与计算</li>\n<li>并不是只有块元素才会生成 BFC，任何元素只要符合条件即可生成 BFC</li>\n</ol>\n<h3 id=\"BFC-的应用\"><a href=\"#BFC-的应用\" class=\"headerlink\" title=\"BFC 的应用\"></a>BFC 的应用</h3><ol>\n<li>自适应两栏布局</li>\n<li>清除内部浮动</li>\n<li>防止 margin 上下重叠</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"ES6","date":"2020-02-07T16:00:00.000Z","_content":"\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n<!--more--> \n\n### this 关键字\n\nthis 可以用在构造函数之中，表示实例对象。除此之外，this 还可以用在别的场合。但不管是什么场合，this 都有一个共同点：它总是返回一个对象\n简单说，this 就是属性或方法“当前”所在的对象。\n\n```js\nvar person = {\n  name: \"张三\",\n  describe: function () {\n    return \"姓名：\" + this.name;\n  },\n};\nperson.describe(); // \"姓名：张三\"\n```\n\n上面代码中，this.name表示 name 属性所在的那个对象。由于this.name是在 describe 方法中调用，而 describe 方法所在的当前对象是 person，因此 this 指向 person，this.name就是person.name。\n\n### this 主要有以下几个使用场合\n\n1. 全局环境\n   全局环境使用 this，它指的就是顶层对象 window。\n\n```js\nthis === window; // true\nfunction f() {\n  console.log(this === window);\n}\nf(); // true\n//注：严格模式下 普通函数内部 this 等于 undefined\n```\n\n2. 构造函数\n   构造函数中的 this，指的是实例对象\n\n```js\nfunction Person(p) {\n  this.p = p;\n}\nvar obj = new Person();\n```\n\n3. 对象的方法\n   如果对象的方法里面包含 this，this 的指向就是方法运行时所在的对象。\n\n```js\nvar obj = {\n  foo: function () {\n    console.log(this);\n  },\n};\nobj.foo(); // obj\n```\n\n### bind 方法\n\nbind 方法用于将函数体内的 this 绑定到某个对象，然后返回一个新函数。\n\n```js\nvar dog = {\n  name: \"wangcai\",\n  age: 18,\n  wang: function () {\n    console.log(this);\n  },\n};\nvar person = { name: \"小明\" };\nvar func = dog.wang.bind(person);\nfunc();\n//上面代码将person绑定到了func函数内部\n``` \n\n### let/const\n\n1. ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。\n\n```js\n{\n  let a = 10;\n  var b = 1;\n}\na; // ReferenceError: a is not defined.\nb; // 1\n```\n\n上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。\n\nfor 循环的计数器，就很合适使用 let 命令。\n\n```js\nvar oLis = document.getElementsByTagName(\"li\");\nfor (let i = 0; i < oLis.length; i++) {\n  // ...\n  oLis[i].onclick = function () {\n    console.log(i); // 0 1 2 3 4\n  };\n}\nconsole.log(i);\n// ReferenceError: i is not defined\n//上面代码相当与产生了几个块级作用域\n{\n  var i = 0;\n  oLis[i].onclick = function () {\n    console.log(i);\n  };\n}\n{\n  var i = 1;\n  oLis[i].onclick = function () {\n    console.log(i);\n  };\n}\n```\n\n上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。\n\nES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let 实际上为 JavaScript 新增了块级作用域。\n\nvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。\n\n为了纠正这种现象，let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。\n\n2. const 命令\n   const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n   const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值\n\n```js\nconst PI = 3.1415;\nPI; // 3.1415\nPI = 3;\n// TypeError: Assignment to constant variable.\n```\n\n上面代码表明改变常量的值会报错。\n\n### 箭头函数\n\nES6 允许使用“箭头”（=>）定义函数。\n\n```js\nvar f = (v) => v;\n// 等同于\nvar f = function (v) {\n  return v;\n};\n```\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\n```js\nvar f = () => 5;\n// 等同于\nvar f = function () {\n  return 5;\n};\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function (num1, num2) {\n  return num1 + num2;\n};\n```\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。\n\n```js\nvar sum = (num1, num2) => {\n  return num1 + num2;\n};\n```\n\n箭头函数使得表达更加简洁。\n\n```js\nconst isEven = (n) => n % 2 == 0;\nconst square = (n) => n * n;\n```\n\n上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。\n\n箭头函数的一个用处是简化回调函数\n\n```js\n// 正常函数写法\n[1, 2, 3].map(function (x) {\n  return x * x;\n});\n// 箭头函数写法\n[1, 2, 3].map((x) => x * x);\n\n// 正常函数写法\nvar result = values.sort(function (a, b) {\n  return a - b;\n});\n// 箭头函数写法\nvar result = values.sort((a, b) => a - b);\n```\n\n箭头函数有几个使用注意点。\n\n1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。\n2. 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。\n3. 不可以使用 arguments 对象，该对象在函数体内不存在。\n\n### 变量解构（解构赋值）\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n以前，为变量赋值，只能直接指定值。\n\n```js\nlet a = 1;\nlet b = 2;\nlet c = 3;\n```\n\nES6 允许写成下面这样。\n\n```js\nlet [a, b, c] = [1, 2, 3];\n```\n\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值\n解构不仅可以用于数组，还可以用于对象\n\n```js\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo; // \"aaa\"\nbar; // \"bbb\"\n```\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值\n\n```js\nlet { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo; // \"aaa\"\nbar; // \"bbb\"\nlet { foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo; // \"aaa\"\n```\n\n### 字符串扩展\n\n模板字符串（template string）是增强版的字符串\n\n传统的 JavaScript 语言，输出模板通常是这样写的。\n\n```js\nvar a = 1;\nvar b = 2;\nvar sum = a + b;\nvar res = a + \"+\" + b + \"的和是<b>\" + c + \"</b>\";\nconsole.log(res);\nbox.innerHTML = res;\nvar obj = { name: \"zhangsan\", age: 18 };\nvar str = \"<b>姓名</b>：\" + obj.name + \"<b>年龄</b>:\" + obj.age;\ndiv.innerHTML = str;\n```\n\n上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\n模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在${}之中。\n\n```js\nvar a = 1;\nvar b = 2;\nvar sum = a + b;\nvar res = `a+b的和是<b>${c}</b>`;\nconsole.log(res);\nbox.innerHTML = res;\nvar obj = { name: \"zhangsan\", age: 18 };\nvar str = `<b>姓名</b>：${obj.name}<b>年龄</b>:${obj.age}`;\ndiv.innerHTML = str;\n```\n上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义\n\n```js\nlet greeting = `\\`Yo\\` World!`;\n```\n\n如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中\n\n```js\noDiv.innerHTML = `\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`;\n```\n\n大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\n\n```js\net x = 1;let y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n```\n\n模板字符串之中还能调用函数\n\n```js\nfunction fn() {\n  return \"Hello World\";\n}\n\n`foo ${fn()} bar`;\n// foo Hello World bar\n```\n\n字符串扩张方法\n传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\nincludes()：返回布尔值，表示是否找到了参数字符串。\nstartsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\nendsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\n```js\nlet s = \"Hello world!\";\n\ns.startsWith(\"Hello\"); // true\ns.endsWith(\"!\"); // true\ns.includes(\"o\"); // true\n``` \n\nrepeat 方法返回一个新字符串，表示将原字符串重复 n 次\n\n```js\n\"x\".repeat(3); // \"xxx\"\n\"hello\".repeat(2); // \"hellohello\"\n\"na\".repeat(0); // \"\"\n```\n\n### 数组新增方法\n\nArray.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 Set 和 Map）\n下面是一个类似数组的对象，Array.from 将它转为真正的数组\n\n```js\nlet arrayLike = {\n  0: \"a\",\n  1: \"b\",\n  2: \"c\",\n  length: 3,\n};\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n``` \n\n实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组\n\n### 对象扩展\n\nES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\n```js\nconst foo = \"bar\";\nconst baz = { foo };\nbaz; // {foo: \"bar\"}\n// 等同于\nconst baz = { foo: foo };\n```\n\n除了属性简写，方法也可以简写。\n\n```js\nconst o = {\n  method() {\n    return \"Hello!\";\n  },\n};\n// 等同于\nconst o = {\n  method: function () {\n    return \"Hello!\";\n  },\n};\n```\n\n### 扩展运算符\n\n对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n```js\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn; // { a: 3, b: 4 }\n```\n\n由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\n\n```js\nlet foo = { ...[\"a\", \"b\", \"c\"] };\nfoo;\n// {0: \"a\", 1: \"b\", 2: \"c\"}\n```\n\n对象的扩展运算符等同于使用Object.assign()方法。\n\n```js\nlet aClone = { ...a };\n// 等同于\nlet aClone = Object.assign({}, a);\n```\n\n```js\nfunction add(x, y) {\n  return x + y;\n}\nvar numbers = [4, 38];\nadd(...numbers); //\n//该运算符将一个数组，变为参数序列\n```\n\n```js\nvar arr1 = [\"a\", \"b\"];\nvar arr2 = [\"c\"];\nvar arr3 = [\"d\", \"e\"];\n// 合并数组\n[...arr1, ...arr2, ...arr3];\n```\n\n### 函数参数默认值\n\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n\n```js\nfunction log(x, y) {\n  y = y || \"World\";\n  console.log(x, y);\n}\nlog(\"Hello\"); // Hello World\nlog(\"Hello\", \"China\"); // Hello China\n//这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。\n```\n\nES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n```js\nfunction log(x, y = \"World\") {\n  console.log(x, y);\n}\nlog(\"Hello\"); // Hello World\nlog(\"Hello\", \"China\"); // Hello China\n```\n\n可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。\n\n### Symbol 类型\n\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因\n\nES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\n\nSymbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突\n\n```js\nlet s = Symbol();\ntypeof s;\n// \"symbol\"\n```\n\n上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型\n注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\nSymbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n\n```js\nlet s1 = Symbol(\"foo\");\nlet s2 = Symbol(\"bar\");\ns1; // Symbol(foo)\ns2; // Symbol(bar)\ns1.toString(); // \"Symbol(foo)\"\ns2.toString(); // \"Symbol(bar)\"\n```\n\n上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n\n注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。\n\n```js\n// 没有参数的情况\nlet s1 = Symbol();\nlet s2 = Symbol();\ns1 === s2; // false\n// 有参数的情况\nlet s1 = Symbol(\"foo\");\nlet s2 = Symbol(\"foo\");\ns1 === s2; // false\n```\n\n上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。\nSymbol 值也可以转为布尔值，但是不能转为数值\n\n```js\nlet sym = Symbol();\nBoolean(sym); // true\n!sym; // false\nif (sym) {\n  // ...\n}\n\nNumber(sym); // TypeError\nsym + 2; // TypeError\n```\n\n作为属性名的 Symbol\n由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。\n\n```js\n// 第一种写法\nlet a = {};\na[mySymbol] = \"Hello!\";\n// 第二种写法\nlet a = {\n  [mySymbol]: \"Hello!\",\n};\n// 以上写法都得到同样结果\na[mySymbol]; // \"Hello!\"\n```\n\n注意，Symbol 值作为对象属性名时，不能用点运算符。\n\n```js\nconst mySymbol = Symbol();\nconst a = {};\n\na.mySymbol = \"Hello!\";\na[mySymbol]; // undefined\na[\"mySymbol\"]; // \"Hello!\"\n```\n\n上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。\n同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\n\n```js\nlet s = Symbol();\n\nlet obj = {\n  [s]: function (arg) { ... }};\n\nobj[s](123);\n```\n\n上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s，而不是 s 所代表的那个 Symbol 值。\n\n### Set 和 Map 结构\n\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\nSet 本身是一个构造函数，用来生成 Set 数据结构。\n\n```js\nconst s = new Set();\n[2, 3, 5, 4, 5, 2, 2].forEach((x) => s.add(x));\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n上面代码通过 add 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\nSet 函数可以接受一个数组（获取 dom 的 nodelist 对象）作为参数，用来初始化。\n\n```js\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set];\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size; // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll(\"div\"));\nset.size; // 56\n```\n\n上面代码也展示了一种去除数组重复成员的方法。\n\n```js\n// 去除数组的重复成员\n[...new Set(array)];\n```\n\n向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。\n\n```js\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset; // Set {NaN}\n```\n\nSet 结构的实例有以下属性\nconstructor：构造函数，默认就是 Set 函数。\nsize：返回 Set 实例的成员总数。\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面四个操作方法\n\n```js\n//add(value):添加某个值，返回 Set 结构本身。\n//delete(value):删除某个值，返回一个布尔值，表示删除是否成功。\n//has(value)：返回一个布尔值，表示该值是否为Set的成员。\n//clear()：清除所有成员，没有返回值。\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\ns.size; // 2\ns.has(1); // true\ns.has(2); // true\ns.has(3); // false\ns.delete(2);\ns.has(2); // false\n```\n\n### Array.from 方法可以将 Set 结构转为数组。\n\n```js\nlet set = new Set([\"red\", \"green\", \"blue\"]);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n```\n\nSet 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。\n\n```js\nset = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + \" : \" + value));\n// 1 : 1\n// 4 : 4\n// 9 : 9\n```\n\n上面代码说明，forEach 方法的参数就是一个处理函数。该函数的参数与数组的 forEach 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\n\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\n```js\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n```\n\nmap 结构\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\nES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\nMap 结构的实例有以下属性和操作方法。\n\n1. size 属性\n   size 属性返回 Map 结构的成员总数。\n\n```js\nconst map = new Map();\nmap.set(\"foo\", true);\nmap.set(\"bar\", false);\n\nmap.size; // 2\n```\n\n2. set(key, value)\n   set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。\n\n```js\nconst m = new Map();\nm.set(\"edition\", 6); // 键是字符串\nm.set(262, \"standard\"); // 键是数值\nm.set(undefined, \"nah\"); // 键是 undefined\n```\n\nset 方法返回的是当前的 Map 对象，因此可以采用链式写法。\n\n```js\nlet map = new Map().set(1, \"a\").set(2, \"b\").set(3, \"c\");\n```\n\n3. get(key)\n   get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。\n\n```js\nconst m = new Map();\n\nconst hello = function () {\n  console.log(\"hello\");\n};\nm.set(hello, \"Hello ES6!\"); // 键是函数\n\nm.get(hello); // Hello ES6!\n```\n\n4. has(key)\n   has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\n\n```js\nconst m = new Map();\n\nm.set(\"edition\", 6);\nm.set(262, \"standard\");\nm.set(undefined, \"nah\");\n\nm.has(\"edition\"); // true\nm.has(\"years\"); // false\nm.has(262); // true\nm.has(undefined); // true\n``` \n\n5. delete(key)\n   delete 方法删除某个键，返回 true。如果删除失败，返回 false。\n\n```js\nconst m = new Map();\nm.set(undefined, \"nah\");\nm.has(undefined); // true\n\nm.delete(undefined);\nm.has(undefined); // false\n``` \n\n6. clear()\n   clear 方法清除所有成员，没有返回值。\n\n```js\nlet map = new Map();\nmap.set(\"foo\", true);\nmap.set(\"bar\", false);\nmap.size; // 2\nmap.clear();\nmap.size; // 0\n``` \n\n遍历 map\n\n需要特别注意的是，Map 的遍历顺序就是插入顺序\n\n```js\nconst map = new Map([\n  [\"F\", \"no\"],\n  [\"T\", \"yes\"],\n]);\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n``` \n\n### Generators 生成器函数\n\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）\n\n```js\nfunction* helloWorldGenerator() {\n  yield \"hello\";\n  yield \"world\";\n  return \"ending\";\n}\nvar hw = helloWorldGenerator();\n``` \n\n上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（hello 和 world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象\n\n### yield 表达式\n\n由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 表达式就是暂停标志。\n\n1. 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。\n2. 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。\n3. 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。\n4. 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined\n\n下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。\n\n```js \nhw.next();\n// { value: 'hello', done: false }\nhw.next();\n// { value: 'world', done: false }\nhw.next();\n// { value: 'ending', done: true }\nhw.next();\n// { value: undefined, done: true }\n```\n\n上面代码一共调用了四次 next 方法。\n第一次调用，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello，done 属性的值 false，表示遍历还没有结束。\n第二次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world，done 属性的值 false，表示遍历还没有结束。\n第三次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。\n第四次调用，此时 Generator 函数已经运行完毕，next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后再调用 next 方法，返回的都是这个值。\n\n总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。\n\n### class 的写法及继承\n\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子\n\n```js\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \")\";\n};\n\nvar p = new Point(1, 2);\n``` \n\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。\n\n基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 class 改写，就是下面这样。\n\n```js\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return \"(\" + this.x + \", \" + this.y + \")\";\n  }\n}\n``` \n\n上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法\n\npoint 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\n```js\n//hasOwnProperty 可以用来判断对象是否有每一个属性\npoint.hasOwnProperty(\"x\"); // true\npoint.hasOwnProperty(\"y\"); // true\n```\n\nES6 的类，完全可以看作构造函数的另一种写法\n\n```js\nclass Point {\n  // ...\n}\n\ntypeof Point; // \"function\"\n```\n\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数\n\n类的属性名，可以采用表达式。\n\n```js\nlet methodName = \"getArea\";\n\nclass Square {\n  constructor(length) {\n    // ...\n  }\n\n  [methodName]() {\n    // ...\n  }\n}\n``` \n\n上面代码中，Square 类的方法名 getArea，是从表达式得到的。\n\n类内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。\n\n考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\n\n### constructor 方法\n\nconstructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。\n\n```js\nclass Point {}\n// 等同于\nclass Point {\n  constructor() {}\n}\n```\n\n上面代码中，定义了一个空的类 Point，JavaScript 引擎会自动为它添加一个空的 constructor 方法。\n\nconstructor 方法默认返回实例对象（即 this）\n\n类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。\n\n```js\nclass Foo {\n  constructor() {}\n}\n\nFoo();\n// TypeError: Class constructor Foo cannot be invoked without 'new'\n```\n\n生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new，像函数那样调用 Class，将会报错。\n\n```js\nclass Point {\n  // ...\n}\n// 报错\nvar point = Point(2, 3);\n// 正确\nvar point = new Point(2, 3);\n```\n\n类不存在变量提升（hoist），这一点与 ES5 完全不同。\n\n```js\nnew Foo(); // ReferenceError\nclass Foo {}\n```\n\n类方法\n加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n\n```js\nclass Foo {\n  static classMethod() {\n    return \"hello\";\n  }\n}\n\nFoo.classMethod(); // 'hello'\nvar foo = new Foo();\nfoo.classMethod();\n// TypeError: foo.classMethod is not a function\n```\n\n上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n### 类的继承\n\nClass 可以通过 extends 关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。\n\n```js\nclass Point {}\n\nclass ColorPoint extends Point {}\n```\n\n上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。\n\n```js\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + \" \" + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。\n\nES6 要求，子类的构造函数必须执行一次 super 函数\n\n子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。\n\n```js\nclass Point {\n  /* ... */\n}\n\nclass ColorPoint extends Point {\n  constructor() {}\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n```\n\n上面代码中，ColorPoint 继承了父类 Point，但是它的构造函数没有调用 super 方法，导致新建实例时报错。\n\n需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例\n\n```js\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n```\n\n上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。\n\n--- \n\n本文作者： 一只野生东子","source":"_posts/ES6.md","raw":"---\ntitle: ES6\ndate: 2020-02-08\ntags: javaScript、es6\n---\n\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n<!--more--> \n\n### this 关键字\n\nthis 可以用在构造函数之中，表示实例对象。除此之外，this 还可以用在别的场合。但不管是什么场合，this 都有一个共同点：它总是返回一个对象\n简单说，this 就是属性或方法“当前”所在的对象。\n\n```js\nvar person = {\n  name: \"张三\",\n  describe: function () {\n    return \"姓名：\" + this.name;\n  },\n};\nperson.describe(); // \"姓名：张三\"\n```\n\n上面代码中，this.name表示 name 属性所在的那个对象。由于this.name是在 describe 方法中调用，而 describe 方法所在的当前对象是 person，因此 this 指向 person，this.name就是person.name。\n\n### this 主要有以下几个使用场合\n\n1. 全局环境\n   全局环境使用 this，它指的就是顶层对象 window。\n\n```js\nthis === window; // true\nfunction f() {\n  console.log(this === window);\n}\nf(); // true\n//注：严格模式下 普通函数内部 this 等于 undefined\n```\n\n2. 构造函数\n   构造函数中的 this，指的是实例对象\n\n```js\nfunction Person(p) {\n  this.p = p;\n}\nvar obj = new Person();\n```\n\n3. 对象的方法\n   如果对象的方法里面包含 this，this 的指向就是方法运行时所在的对象。\n\n```js\nvar obj = {\n  foo: function () {\n    console.log(this);\n  },\n};\nobj.foo(); // obj\n```\n\n### bind 方法\n\nbind 方法用于将函数体内的 this 绑定到某个对象，然后返回一个新函数。\n\n```js\nvar dog = {\n  name: \"wangcai\",\n  age: 18,\n  wang: function () {\n    console.log(this);\n  },\n};\nvar person = { name: \"小明\" };\nvar func = dog.wang.bind(person);\nfunc();\n//上面代码将person绑定到了func函数内部\n``` \n\n### let/const\n\n1. ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。\n\n```js\n{\n  let a = 10;\n  var b = 1;\n}\na; // ReferenceError: a is not defined.\nb; // 1\n```\n\n上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。\n\nfor 循环的计数器，就很合适使用 let 命令。\n\n```js\nvar oLis = document.getElementsByTagName(\"li\");\nfor (let i = 0; i < oLis.length; i++) {\n  // ...\n  oLis[i].onclick = function () {\n    console.log(i); // 0 1 2 3 4\n  };\n}\nconsole.log(i);\n// ReferenceError: i is not defined\n//上面代码相当与产生了几个块级作用域\n{\n  var i = 0;\n  oLis[i].onclick = function () {\n    console.log(i);\n  };\n}\n{\n  var i = 1;\n  oLis[i].onclick = function () {\n    console.log(i);\n  };\n}\n```\n\n上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。\n\nES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let 实际上为 JavaScript 新增了块级作用域。\n\nvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。\n\n为了纠正这种现象，let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。\n\n2. const 命令\n   const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n   const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值\n\n```js\nconst PI = 3.1415;\nPI; // 3.1415\nPI = 3;\n// TypeError: Assignment to constant variable.\n```\n\n上面代码表明改变常量的值会报错。\n\n### 箭头函数\n\nES6 允许使用“箭头”（=>）定义函数。\n\n```js\nvar f = (v) => v;\n// 等同于\nvar f = function (v) {\n  return v;\n};\n```\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\n```js\nvar f = () => 5;\n// 等同于\nvar f = function () {\n  return 5;\n};\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function (num1, num2) {\n  return num1 + num2;\n};\n```\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。\n\n```js\nvar sum = (num1, num2) => {\n  return num1 + num2;\n};\n```\n\n箭头函数使得表达更加简洁。\n\n```js\nconst isEven = (n) => n % 2 == 0;\nconst square = (n) => n * n;\n```\n\n上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。\n\n箭头函数的一个用处是简化回调函数\n\n```js\n// 正常函数写法\n[1, 2, 3].map(function (x) {\n  return x * x;\n});\n// 箭头函数写法\n[1, 2, 3].map((x) => x * x);\n\n// 正常函数写法\nvar result = values.sort(function (a, b) {\n  return a - b;\n});\n// 箭头函数写法\nvar result = values.sort((a, b) => a - b);\n```\n\n箭头函数有几个使用注意点。\n\n1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。\n2. 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。\n3. 不可以使用 arguments 对象，该对象在函数体内不存在。\n\n### 变量解构（解构赋值）\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n以前，为变量赋值，只能直接指定值。\n\n```js\nlet a = 1;\nlet b = 2;\nlet c = 3;\n```\n\nES6 允许写成下面这样。\n\n```js\nlet [a, b, c] = [1, 2, 3];\n```\n\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值\n解构不仅可以用于数组，还可以用于对象\n\n```js\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo; // \"aaa\"\nbar; // \"bbb\"\n```\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值\n\n```js\nlet { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo; // \"aaa\"\nbar; // \"bbb\"\nlet { foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo; // \"aaa\"\n```\n\n### 字符串扩展\n\n模板字符串（template string）是增强版的字符串\n\n传统的 JavaScript 语言，输出模板通常是这样写的。\n\n```js\nvar a = 1;\nvar b = 2;\nvar sum = a + b;\nvar res = a + \"+\" + b + \"的和是<b>\" + c + \"</b>\";\nconsole.log(res);\nbox.innerHTML = res;\nvar obj = { name: \"zhangsan\", age: 18 };\nvar str = \"<b>姓名</b>：\" + obj.name + \"<b>年龄</b>:\" + obj.age;\ndiv.innerHTML = str;\n```\n\n上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\n模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在${}之中。\n\n```js\nvar a = 1;\nvar b = 2;\nvar sum = a + b;\nvar res = `a+b的和是<b>${c}</b>`;\nconsole.log(res);\nbox.innerHTML = res;\nvar obj = { name: \"zhangsan\", age: 18 };\nvar str = `<b>姓名</b>：${obj.name}<b>年龄</b>:${obj.age}`;\ndiv.innerHTML = str;\n```\n上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义\n\n```js\nlet greeting = `\\`Yo\\` World!`;\n```\n\n如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中\n\n```js\noDiv.innerHTML = `\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`;\n```\n\n大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\n\n```js\net x = 1;let y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n```\n\n模板字符串之中还能调用函数\n\n```js\nfunction fn() {\n  return \"Hello World\";\n}\n\n`foo ${fn()} bar`;\n// foo Hello World bar\n```\n\n字符串扩张方法\n传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\nincludes()：返回布尔值，表示是否找到了参数字符串。\nstartsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\nendsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\n```js\nlet s = \"Hello world!\";\n\ns.startsWith(\"Hello\"); // true\ns.endsWith(\"!\"); // true\ns.includes(\"o\"); // true\n``` \n\nrepeat 方法返回一个新字符串，表示将原字符串重复 n 次\n\n```js\n\"x\".repeat(3); // \"xxx\"\n\"hello\".repeat(2); // \"hellohello\"\n\"na\".repeat(0); // \"\"\n```\n\n### 数组新增方法\n\nArray.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 Set 和 Map）\n下面是一个类似数组的对象，Array.from 将它转为真正的数组\n\n```js\nlet arrayLike = {\n  0: \"a\",\n  1: \"b\",\n  2: \"c\",\n  length: 3,\n};\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n``` \n\n实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组\n\n### 对象扩展\n\nES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\n```js\nconst foo = \"bar\";\nconst baz = { foo };\nbaz; // {foo: \"bar\"}\n// 等同于\nconst baz = { foo: foo };\n```\n\n除了属性简写，方法也可以简写。\n\n```js\nconst o = {\n  method() {\n    return \"Hello!\";\n  },\n};\n// 等同于\nconst o = {\n  method: function () {\n    return \"Hello!\";\n  },\n};\n```\n\n### 扩展运算符\n\n对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n```js\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn; // { a: 3, b: 4 }\n```\n\n由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\n\n```js\nlet foo = { ...[\"a\", \"b\", \"c\"] };\nfoo;\n// {0: \"a\", 1: \"b\", 2: \"c\"}\n```\n\n对象的扩展运算符等同于使用Object.assign()方法。\n\n```js\nlet aClone = { ...a };\n// 等同于\nlet aClone = Object.assign({}, a);\n```\n\n```js\nfunction add(x, y) {\n  return x + y;\n}\nvar numbers = [4, 38];\nadd(...numbers); //\n//该运算符将一个数组，变为参数序列\n```\n\n```js\nvar arr1 = [\"a\", \"b\"];\nvar arr2 = [\"c\"];\nvar arr3 = [\"d\", \"e\"];\n// 合并数组\n[...arr1, ...arr2, ...arr3];\n```\n\n### 函数参数默认值\n\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n\n```js\nfunction log(x, y) {\n  y = y || \"World\";\n  console.log(x, y);\n}\nlog(\"Hello\"); // Hello World\nlog(\"Hello\", \"China\"); // Hello China\n//这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。\n```\n\nES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n```js\nfunction log(x, y = \"World\") {\n  console.log(x, y);\n}\nlog(\"Hello\"); // Hello World\nlog(\"Hello\", \"China\"); // Hello China\n```\n\n可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。\n\n### Symbol 类型\n\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因\n\nES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\n\nSymbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突\n\n```js\nlet s = Symbol();\ntypeof s;\n// \"symbol\"\n```\n\n上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型\n注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\nSymbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n\n```js\nlet s1 = Symbol(\"foo\");\nlet s2 = Symbol(\"bar\");\ns1; // Symbol(foo)\ns2; // Symbol(bar)\ns1.toString(); // \"Symbol(foo)\"\ns2.toString(); // \"Symbol(bar)\"\n```\n\n上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n\n注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。\n\n```js\n// 没有参数的情况\nlet s1 = Symbol();\nlet s2 = Symbol();\ns1 === s2; // false\n// 有参数的情况\nlet s1 = Symbol(\"foo\");\nlet s2 = Symbol(\"foo\");\ns1 === s2; // false\n```\n\n上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。\nSymbol 值也可以转为布尔值，但是不能转为数值\n\n```js\nlet sym = Symbol();\nBoolean(sym); // true\n!sym; // false\nif (sym) {\n  // ...\n}\n\nNumber(sym); // TypeError\nsym + 2; // TypeError\n```\n\n作为属性名的 Symbol\n由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。\n\n```js\n// 第一种写法\nlet a = {};\na[mySymbol] = \"Hello!\";\n// 第二种写法\nlet a = {\n  [mySymbol]: \"Hello!\",\n};\n// 以上写法都得到同样结果\na[mySymbol]; // \"Hello!\"\n```\n\n注意，Symbol 值作为对象属性名时，不能用点运算符。\n\n```js\nconst mySymbol = Symbol();\nconst a = {};\n\na.mySymbol = \"Hello!\";\na[mySymbol]; // undefined\na[\"mySymbol\"]; // \"Hello!\"\n```\n\n上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。\n同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\n\n```js\nlet s = Symbol();\n\nlet obj = {\n  [s]: function (arg) { ... }};\n\nobj[s](123);\n```\n\n上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s，而不是 s 所代表的那个 Symbol 值。\n\n### Set 和 Map 结构\n\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\nSet 本身是一个构造函数，用来生成 Set 数据结构。\n\n```js\nconst s = new Set();\n[2, 3, 5, 4, 5, 2, 2].forEach((x) => s.add(x));\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n上面代码通过 add 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\nSet 函数可以接受一个数组（获取 dom 的 nodelist 对象）作为参数，用来初始化。\n\n```js\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set];\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size; // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll(\"div\"));\nset.size; // 56\n```\n\n上面代码也展示了一种去除数组重复成员的方法。\n\n```js\n// 去除数组的重复成员\n[...new Set(array)];\n```\n\n向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。\n\n```js\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset; // Set {NaN}\n```\n\nSet 结构的实例有以下属性\nconstructor：构造函数，默认就是 Set 函数。\nsize：返回 Set 实例的成员总数。\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面四个操作方法\n\n```js\n//add(value):添加某个值，返回 Set 结构本身。\n//delete(value):删除某个值，返回一个布尔值，表示删除是否成功。\n//has(value)：返回一个布尔值，表示该值是否为Set的成员。\n//clear()：清除所有成员，没有返回值。\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\ns.size; // 2\ns.has(1); // true\ns.has(2); // true\ns.has(3); // false\ns.delete(2);\ns.has(2); // false\n```\n\n### Array.from 方法可以将 Set 结构转为数组。\n\n```js\nlet set = new Set([\"red\", \"green\", \"blue\"]);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n```\n\nSet 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。\n\n```js\nset = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + \" : \" + value));\n// 1 : 1\n// 4 : 4\n// 9 : 9\n```\n\n上面代码说明，forEach 方法的参数就是一个处理函数。该函数的参数与数组的 forEach 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\n\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\n```js\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n```\n\nmap 结构\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\nES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\nMap 结构的实例有以下属性和操作方法。\n\n1. size 属性\n   size 属性返回 Map 结构的成员总数。\n\n```js\nconst map = new Map();\nmap.set(\"foo\", true);\nmap.set(\"bar\", false);\n\nmap.size; // 2\n```\n\n2. set(key, value)\n   set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。\n\n```js\nconst m = new Map();\nm.set(\"edition\", 6); // 键是字符串\nm.set(262, \"standard\"); // 键是数值\nm.set(undefined, \"nah\"); // 键是 undefined\n```\n\nset 方法返回的是当前的 Map 对象，因此可以采用链式写法。\n\n```js\nlet map = new Map().set(1, \"a\").set(2, \"b\").set(3, \"c\");\n```\n\n3. get(key)\n   get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。\n\n```js\nconst m = new Map();\n\nconst hello = function () {\n  console.log(\"hello\");\n};\nm.set(hello, \"Hello ES6!\"); // 键是函数\n\nm.get(hello); // Hello ES6!\n```\n\n4. has(key)\n   has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\n\n```js\nconst m = new Map();\n\nm.set(\"edition\", 6);\nm.set(262, \"standard\");\nm.set(undefined, \"nah\");\n\nm.has(\"edition\"); // true\nm.has(\"years\"); // false\nm.has(262); // true\nm.has(undefined); // true\n``` \n\n5. delete(key)\n   delete 方法删除某个键，返回 true。如果删除失败，返回 false。\n\n```js\nconst m = new Map();\nm.set(undefined, \"nah\");\nm.has(undefined); // true\n\nm.delete(undefined);\nm.has(undefined); // false\n``` \n\n6. clear()\n   clear 方法清除所有成员，没有返回值。\n\n```js\nlet map = new Map();\nmap.set(\"foo\", true);\nmap.set(\"bar\", false);\nmap.size; // 2\nmap.clear();\nmap.size; // 0\n``` \n\n遍历 map\n\n需要特别注意的是，Map 的遍历顺序就是插入顺序\n\n```js\nconst map = new Map([\n  [\"F\", \"no\"],\n  [\"T\", \"yes\"],\n]);\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n``` \n\n### Generators 生成器函数\n\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）\n\n```js\nfunction* helloWorldGenerator() {\n  yield \"hello\";\n  yield \"world\";\n  return \"ending\";\n}\nvar hw = helloWorldGenerator();\n``` \n\n上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（hello 和 world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象\n\n### yield 表达式\n\n由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 表达式就是暂停标志。\n\n1. 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。\n2. 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。\n3. 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。\n4. 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined\n\n下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。\n\n```js \nhw.next();\n// { value: 'hello', done: false }\nhw.next();\n// { value: 'world', done: false }\nhw.next();\n// { value: 'ending', done: true }\nhw.next();\n// { value: undefined, done: true }\n```\n\n上面代码一共调用了四次 next 方法。\n第一次调用，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello，done 属性的值 false，表示遍历还没有结束。\n第二次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world，done 属性的值 false，表示遍历还没有结束。\n第三次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。\n第四次调用，此时 Generator 函数已经运行完毕，next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后再调用 next 方法，返回的都是这个值。\n\n总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。\n\n### class 的写法及继承\n\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子\n\n```js\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \")\";\n};\n\nvar p = new Point(1, 2);\n``` \n\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。\n\n基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 class 改写，就是下面这样。\n\n```js\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return \"(\" + this.x + \", \" + this.y + \")\";\n  }\n}\n``` \n\n上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法\n\npoint 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\n```js\n//hasOwnProperty 可以用来判断对象是否有每一个属性\npoint.hasOwnProperty(\"x\"); // true\npoint.hasOwnProperty(\"y\"); // true\n```\n\nES6 的类，完全可以看作构造函数的另一种写法\n\n```js\nclass Point {\n  // ...\n}\n\ntypeof Point; // \"function\"\n```\n\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数\n\n类的属性名，可以采用表达式。\n\n```js\nlet methodName = \"getArea\";\n\nclass Square {\n  constructor(length) {\n    // ...\n  }\n\n  [methodName]() {\n    // ...\n  }\n}\n``` \n\n上面代码中，Square 类的方法名 getArea，是从表达式得到的。\n\n类内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。\n\n考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\n\n### constructor 方法\n\nconstructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。\n\n```js\nclass Point {}\n// 等同于\nclass Point {\n  constructor() {}\n}\n```\n\n上面代码中，定义了一个空的类 Point，JavaScript 引擎会自动为它添加一个空的 constructor 方法。\n\nconstructor 方法默认返回实例对象（即 this）\n\n类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。\n\n```js\nclass Foo {\n  constructor() {}\n}\n\nFoo();\n// TypeError: Class constructor Foo cannot be invoked without 'new'\n```\n\n生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new，像函数那样调用 Class，将会报错。\n\n```js\nclass Point {\n  // ...\n}\n// 报错\nvar point = Point(2, 3);\n// 正确\nvar point = new Point(2, 3);\n```\n\n类不存在变量提升（hoist），这一点与 ES5 完全不同。\n\n```js\nnew Foo(); // ReferenceError\nclass Foo {}\n```\n\n类方法\n加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n\n```js\nclass Foo {\n  static classMethod() {\n    return \"hello\";\n  }\n}\n\nFoo.classMethod(); // 'hello'\nvar foo = new Foo();\nfoo.classMethod();\n// TypeError: foo.classMethod is not a function\n```\n\n上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n### 类的继承\n\nClass 可以通过 extends 关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。\n\n```js\nclass Point {}\n\nclass ColorPoint extends Point {}\n```\n\n上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。\n\n```js\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + \" \" + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。\n\nES6 要求，子类的构造函数必须执行一次 super 函数\n\n子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。\n\n```js\nclass Point {\n  /* ... */\n}\n\nclass ColorPoint extends Point {\n  constructor() {}\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n```\n\n上面代码中，ColorPoint 继承了父类 Point，但是它的构造函数没有调用 super 方法，导致新建实例时报错。\n\n需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例\n\n```js\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n```\n\n上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。\n\n--- \n\n本文作者： 一只野生东子","slug":"ES6","published":1,"updated":"2021-11-26T08:44:14.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2700019co345cifszz","content":"<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n<span id=\"more\"></span> \n\n<h3 id=\"this-关键字\"><a href=\"#this-关键字\" class=\"headerlink\" title=\"this 关键字\"></a>this 关键字</h3><p>this 可以用在构造函数之中，表示实例对象。除此之外，this 还可以用在别的场合。但不管是什么场合，this 都有一个共同点：它总是返回一个对象<br>简单说，this 就是属性或方法“当前”所在的对象。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">describe</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;姓名：&quot;</span> + <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">person.describe(); <span class=\"comment\">// &quot;姓名：张三&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，this.name表示 name 属性所在的那个对象。由于this.name是在 describe 方法中调用，而 describe 方法所在的当前对象是 person，因此 this 指向 person，this.name就是person.name。</p>\n<h3 id=\"this-主要有以下几个使用场合\"><a href=\"#this-主要有以下几个使用场合\" class=\"headerlink\" title=\"this 主要有以下几个使用场合\"></a>this 主要有以下几个使用场合</h3><ol>\n<li>全局环境<br>全局环境使用 this，它指的就是顶层对象 window。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span> === <span class=\"built_in\">window</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">//注：严格模式下 普通函数内部 this 等于 undefined</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>构造函数<br>构造函数中的 this，指的是实例对象</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.p = p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li>对象的方法<br>如果对象的方法里面包含 this，this 的指向就是方法运行时所在的对象。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h3><p>bind 方法用于将函数体内的 this 绑定到某个对象，然后返回一个新函数。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;wangcai&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  <span class=\"attr\">wang</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;小明&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = dog.wang.bind(person);</span><br><span class=\"line\">func();</span><br><span class=\"line\"><span class=\"comment\">//上面代码将person绑定到了func函数内部</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"let-const\"><a href=\"#let-const\" class=\"headerlink\" title=\"let/const\"></a>let/const</h3><ol>\n<li>ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a; <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。</p>\n<p>for 循环的计数器，就很合适使用 let 命令。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> oLis = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;li&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; oLis.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  oLis[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 0 1 2 3 4</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"><span class=\"comment\">// ReferenceError: i is not defined</span></span><br><span class=\"line\"><span class=\"comment\">//上面代码相当与产生了几个块级作用域</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  oLis[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  oLis[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。</p>\n<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let 实际上为 JavaScript 新增了块级作用域。</p>\n<p>var 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>\n<p>为了纠正这种现象，let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>\n<ol start=\"2\">\n<li>const 命令<br>const 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\">PI; <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\">PI = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码表明改变常量的值会报错。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> v;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">() =&gt;</span> <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>箭头函数使得表达更加简洁。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n * n;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>\n<p>箭头函数的一个用处是简化回调函数</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正常函数写法</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 箭头函数写法</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正常函数写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 箭头函数写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure></div>\n\n<p>箭头函数有几个使用注意点。</p>\n<ol>\n<li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li>\n<li>不可以使用 arguments 对象，该对象在函数体内不存在。</li>\n</ol>\n<h3 id=\"变量解构（解构赋值）\"><a href=\"#变量解构（解构赋值）\" class=\"headerlink\" title=\"变量解构（解构赋值）\"></a>变量解构（解构赋值）</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构<br>以前，为变量赋值，只能直接指定值。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>ES6 允许写成下面这样。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure></div>\n\n<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值<br>解构不仅可以用于数组，还可以用于对象</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo, bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"attr\">bar</span>: <span class=\"string\">&quot;bbb&quot;</span> &#125;;</span><br><span class=\"line\">foo; <span class=\"comment\">// &quot;aaa&quot;</span></span><br><span class=\"line\">bar; <span class=\"comment\">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; bar, foo &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"attr\">bar</span>: <span class=\"string\">&quot;bbb&quot;</span> &#125;;</span><br><span class=\"line\">foo; <span class=\"comment\">// &quot;aaa&quot;</span></span><br><span class=\"line\">bar; <span class=\"comment\">// &quot;bbb&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"attr\">bar</span>: <span class=\"string\">&quot;bbb&quot;</span> &#125;;</span><br><span class=\"line\">foo; <span class=\"comment\">// &quot;aaa&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"字符串扩展\"><a href=\"#字符串扩展\" class=\"headerlink\" title=\"字符串扩展\"></a>字符串扩展</h3><p>模板字符串（template string）是增强版的字符串</p>\n<p>传统的 JavaScript 语言，输出模板通常是这样写的。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = a + b;</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = a + <span class=\"string\">&quot;+&quot;</span> + b + <span class=\"string\">&quot;的和是&lt;b&gt;&quot;</span> + c + <span class=\"string\">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">box.innerHTML = res;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;&lt;b&gt;姓名&lt;/b&gt;：&quot;</span> + obj.name + <span class=\"string\">&quot;&lt;b&gt;年龄&lt;/b&gt;:&quot;</span> + obj.age;</span><br><span class=\"line\">div.innerHTML = str;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。<br>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在${}之中。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = a + b;</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"string\">`a+b的和是&lt;b&gt;<span class=\"subst\">$&#123;c&#125;</span>&lt;/b&gt;`</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">box.innerHTML = res;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;b&gt;姓名&lt;/b&gt;：<span class=\"subst\">$&#123;obj.name&#125;</span>&lt;b&gt;年龄&lt;/b&gt;:<span class=\"subst\">$&#123;obj.age&#125;</span>`</span>;</span><br><span class=\"line\">div.innerHTML = str;</span><br></pre></td></tr></table></figure></div>\n<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> greeting = <span class=\"string\">`\\`Yo\\` World!`</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oDiv.innerHTML = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">&lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">et x = <span class=\"number\">1</span>;<span class=\"keyword\">let</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y&#125;</span> = <span class=\"subst\">$&#123;x + y&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;1 + 2 = 3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y * <span class=\"number\">2</span>&#125;</span> = <span class=\"subst\">$&#123;x + y * <span class=\"number\">2</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;1 + 4 = 5&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;obj.x + obj.y&#125;</span>`</span></span><br></pre></td></tr></table></figure></div>\n\n<p>模板字符串之中还能调用函数</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`foo <span class=\"subst\">$&#123;fn()&#125;</span> bar`</span>;</span><br><span class=\"line\"><span class=\"comment\">// foo Hello World bar</span></span><br></pre></td></tr></table></figure></div>\n\n<p>字符串扩张方法<br>传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。<br>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">s.startsWith(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.endsWith(<span class=\"string\">&quot;!&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.includes(<span class=\"string\">&quot;o&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></div>\n\n<p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;x&quot;</span>.repeat(<span class=\"number\">3</span>); <span class=\"comment\">// &quot;xxx&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello&quot;</span>.repeat(<span class=\"number\">2</span>); <span class=\"comment\">// &quot;hellohello&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;na&quot;</span>.repeat(<span class=\"number\">0</span>); <span class=\"comment\">// &quot;&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"数组新增方法\"><a href=\"#数组新增方法\" class=\"headerlink\" title=\"数组新增方法\"></a>数组新增方法</h3><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 Set 和 Map）<br>下面是一个类似数组的对象，Array.from 将它转为真正的数组</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">&quot;a&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&quot;b&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">&quot;c&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组</p>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; foo &#125;;</span><br><span class=\"line\">baz; <span class=\"comment\">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; <span class=\"attr\">foo</span>: foo &#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>除了属性简写，方法也可以简写。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  <span class=\"attr\">method</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h3><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = &#123; ...z &#125;;</span><br><span class=\"line\">n; <span class=\"comment\">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123; ...[<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>] &#125;;</span><br><span class=\"line\">foo;</span><br><span class=\"line\"><span class=\"comment\">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>对象的扩展运算符等同于使用Object.assign()方法。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> aClone = &#123; ...a &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aClone = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure></div>\n\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">4</span>, <span class=\"number\">38</span>];</span><br><span class=\"line\">add(...numbers); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//该运算符将一个数组，变为参数序列</span></span><br></pre></td></tr></table></figure></div>\n\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 合并数组</span></span><br><span class=\"line\">[...arr1, ...arr2, ...arr3];</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"函数参数默认值\"><a href=\"#函数参数默认值\" class=\"headerlink\" title=\"函数参数默认值\"></a>函数参数默认值</h3><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  y = y || <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;China&quot;</span>); <span class=\"comment\">// Hello China</span></span><br><span class=\"line\"><span class=\"comment\">//这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。</span></span><br></pre></td></tr></table></figure></div>\n\n<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y = <span class=\"string\">&quot;World&quot;</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;China&quot;</span>); <span class=\"comment\">// Hello China</span></span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。</p>\n<h3 id=\"Symbol-类型\"><a href=\"#Symbol-类型\" class=\"headerlink\" title=\"Symbol 类型\"></a>Symbol 类型</h3><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因</p>\n<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）</p>\n<p>Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s;</span><br><span class=\"line\"><span class=\"comment\">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型<br>注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<br>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">s1; <span class=\"comment\">// Symbol(foo)</span></span><br><span class=\"line\">s2; <span class=\"comment\">// Symbol(bar)</span></span><br><span class=\"line\">s1.toString(); <span class=\"comment\">// &quot;Symbol(foo)&quot;</span></span><br><span class=\"line\">s2.toString(); <span class=\"comment\">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>\n<p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有参数的情况</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\">s1 === s2; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">// 有参数的情况</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">s1 === s2; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。<br>Symbol 值也可以转为布尔值，但是不能转为数值</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(sym); <span class=\"comment\">// true</span></span><br><span class=\"line\">!sym; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (sym) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(sym); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">sym + <span class=\"number\">2</span>; <span class=\"comment\">// TypeError</span></span><br></pre></td></tr></table></figure></div>\n\n<p>作为属性名的 Symbol<br>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;&#125;;</span><br><span class=\"line\">a[mySymbol] = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">  [mySymbol]: <span class=\"string\">&quot;Hello!&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 以上写法都得到同样结果</span></span><br><span class=\"line\">a[mySymbol]; <span class=\"comment\">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.mySymbol = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\">a[mySymbol]; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a[<span class=\"string\">&quot;mySymbol&quot;</span>]; <span class=\"comment\">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。<br>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg</span>) </span>&#123; ... &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj[s](<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s，而不是 s 所代表的那个 Symbol 值。</p>\n<h3 id=\"Set-和-Map-结构\"><a href=\"#Set-和-Map-结构\" class=\"headerlink\" title=\"Set 和 Map 结构\"></a>Set 和 Map 结构</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].forEach(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> s.add(x));</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 3 5 4</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码通过 add 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。<br>Set 函数可以接受一个数组（获取 dom 的 nodelist 对象）作为参数，用来初始化。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set];</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">items.size; <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">&quot;div&quot;</span>));</span><br><span class=\"line\">set.size; <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码也展示了一种去除数组重复成员的方法。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>(array)];</span><br></pre></td></tr></table></figure></div>\n\n<p>向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\">set.add(a);</span><br><span class=\"line\">set.add(b);</span><br><span class=\"line\">set; <span class=\"comment\">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>Set 结构的实例有以下属性<br>constructor：构造函数，默认就是 Set 函数。<br>size：返回 Set 实例的成员总数。<br>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面四个操作方法</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(value):添加某个值，返回 Set 结构本身。</span></span><br><span class=\"line\"><span class=\"comment\">//delete(value):删除某个值，返回一个布尔值，表示删除是否成功。</span></span><br><span class=\"line\"><span class=\"comment\">//has(value)：返回一个布尔值，表示该值是否为Set的成员。</span></span><br><span class=\"line\"><span class=\"comment\">//clear()：清除所有成员，没有返回值。</span></span><br><span class=\"line\">s.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 注意2被加入了两次</span></span><br><span class=\"line\">s.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">s.has(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">2</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">3</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">s.delete(<span class=\"number\">2</span>);</span><br><span class=\"line\">s.has(<span class=\"number\">2</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Array-from-方法可以将-Set-结构转为数组。\"><a href=\"#Array-from-方法可以将-Set-结构转为数组。\" class=\"headerlink\" title=\"Array.from 方法可以将 Set 结构转为数组。\"></a>Array.from 方法可以将 Set 结构转为数组。</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> set) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br></pre></td></tr></table></figure></div>\n\n<p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>]);</span><br><span class=\"line\">set.forEach(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(key + <span class=\"string\">&quot; : &quot;</span> + value));</span><br><span class=\"line\"><span class=\"comment\">// 1 : 1</span></span><br><span class=\"line\"><span class=\"comment\">// 4 : 4</span></span><br><span class=\"line\"><span class=\"comment\">// 9 : 9</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码说明，forEach 方法的参数就是一个处理函数。该函数的参数与数组的 forEach 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>\n<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>map 结构<br>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<p>Map 结构的实例有以下属性和操作方法。</p>\n<ol>\n<li>size 属性<br>size 属性返回 Map 结构的成员总数。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>set(key, value)<br>set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 键是字符串</span></span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>); <span class=\"comment\">// 键是数值</span></span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>); <span class=\"comment\">// 键是 undefined</span></span><br></pre></td></tr></table></figure></div>\n\n<p>set 方法返回的是当前的 Map 对象，因此可以采用链式写法。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"number\">1</span>, <span class=\"string\">&quot;a&quot;</span>).set(<span class=\"number\">2</span>, <span class=\"string\">&quot;b&quot;</span>).set(<span class=\"number\">3</span>, <span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li>get(key)<br>get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">m.set(hello, <span class=\"string\">&quot;Hello ES6!&quot;</span>); <span class=\"comment\">// 键是函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.get(hello); <span class=\"comment\">// Hello ES6!</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"4\">\n<li>has(key)<br>has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>);</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;edition&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;years&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">m.has(<span class=\"number\">262</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"5\">\n<li>delete(key)<br>delete 方法删除某个键，返回 true。如果删除失败，返回 false。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.delete(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"6\">\n<li>clear()<br>clear 方法清除所有成员，没有返回值。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.clear();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure></div>\n\n<p>遍历 map</p>\n<p>需要特别注意的是，Map 的遍历顺序就是插入顺序</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">&quot;F&quot;</span>, <span class=\"string\">&quot;no&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;yes&quot;</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot; &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot; &quot;yes&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Generators-生成器函数\"><a href=\"#Generators-生成器函数\" class=\"headerlink\" title=\"Generators 生成器函数\"></a>Generators 生成器函数</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同<br>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;ending&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（hello 和 world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>\n<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p>\n<h3 id=\"yield-表达式\"><a href=\"#yield-表达式\" class=\"headerlink\" title=\"yield 表达式\"></a>yield 表达式</h3><p>由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 表达式就是暂停标志。</p>\n<ol>\n<li>遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</li>\n<li>下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。</li>\n<li>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</li>\n<li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined</li>\n</ol>\n<p>下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码一共调用了四次 next 方法。<br>第一次调用，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello，done 属性的值 false，表示遍历还没有结束。<br>第二次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world，done 属性的值 false，表示遍历还没有结束。<br>第三次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。<br>第四次调用，此时 Generator 函数已经运行完毕，next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后再调用 next 方法，返回的都是这个值。</p>\n<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p>\n<h3 id=\"class-的写法及继承\"><a href=\"#class-的写法及继承\" class=\"headerlink\" title=\"class 的写法及继承\"></a>class 的写法及继承</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。<br>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。</p>\n<p>基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 class 改写，就是下面这样。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法</p>\n<p>point 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hasOwnProperty 可以用来判断对象是否有每一个属性</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;x&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></div>\n\n<p>ES6 的类，完全可以看作构造函数的另一种写法</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> Point; <span class=\"comment\">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数</p>\n<p>类的属性名，可以采用表达式。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> methodName = <span class=\"string\">&quot;getArea&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">length</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [methodName]() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，Square 类的方法名 getArea，是从表达式得到的。</p>\n<p>类内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>\n<p>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>\n<h3 id=\"constructor-方法\"><a href=\"#constructor-方法\" class=\"headerlink\" title=\"constructor 方法\"></a>constructor 方法</h3><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，定义了一个空的类 Point，JavaScript 引擎会自动为它添加一个空的 constructor 方法。</p>\n<p>constructor 方法默认返回实例对象（即 this）</p>\n<p>类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Class constructor Foo cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new，像函数那样调用 Class，将会报错。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Foo(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>类方法<br>加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">classMethod</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.classMethod(); <span class=\"comment\">// &#x27;hello&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.classMethod();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><p>Class 可以通过 extends 关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y, color</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(x, y); <span class=\"comment\">// 调用父类的constructor(x, y)</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.color + <span class=\"string\">&quot; &quot;</span> + <span class=\"built_in\">super</span>.toString(); <span class=\"comment\">// 调用父类的toString()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。</p>\n<p>ES6 要求，子类的构造函数必须执行一次 super 函数</p>\n<p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，ColorPoint 继承了父类 Point，但是它的构造函数没有调用 super 方法，导致新建实例时报错。</p>\n<p>需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y, color</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>(x, y);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>","more":"<h3 id=\"this-关键字\"><a href=\"#this-关键字\" class=\"headerlink\" title=\"this 关键字\"></a>this 关键字</h3><p>this 可以用在构造函数之中，表示实例对象。除此之外，this 还可以用在别的场合。但不管是什么场合，this 都有一个共同点：它总是返回一个对象<br>简单说，this 就是属性或方法“当前”所在的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">describe</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;姓名：&quot;</span> + <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">person.describe(); <span class=\"comment\">// &quot;姓名：张三&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，this.name表示 name 属性所在的那个对象。由于this.name是在 describe 方法中调用，而 describe 方法所在的当前对象是 person，因此 this 指向 person，this.name就是person.name。</p>\n<h3 id=\"this-主要有以下几个使用场合\"><a href=\"#this-主要有以下几个使用场合\" class=\"headerlink\" title=\"this 主要有以下几个使用场合\"></a>this 主要有以下几个使用场合</h3><ol>\n<li>全局环境<br>全局环境使用 this，它指的就是顶层对象 window。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span> === <span class=\"built_in\">window</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">//注：严格模式下 普通函数内部 this 等于 undefined</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>构造函数<br>构造函数中的 this，指的是实例对象</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.p = p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>对象的方法<br>如果对象的方法里面包含 this，this 的指向就是方法运行时所在的对象。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h3><p>bind 方法用于将函数体内的 this 绑定到某个对象，然后返回一个新函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;wangcai&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  <span class=\"attr\">wang</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;小明&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = dog.wang.bind(person);</span><br><span class=\"line\">func();</span><br><span class=\"line\"><span class=\"comment\">//上面代码将person绑定到了func函数内部</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"let-const\"><a href=\"#let-const\" class=\"headerlink\" title=\"let/const\"></a>let/const</h3><ol>\n<li>ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a; <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。</p>\n<p>for 循环的计数器，就很合适使用 let 命令。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> oLis = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;li&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; oLis.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  oLis[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 0 1 2 3 4</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"><span class=\"comment\">// ReferenceError: i is not defined</span></span><br><span class=\"line\"><span class=\"comment\">//上面代码相当与产生了几个块级作用域</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  oLis[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  oLis[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。</p>\n<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let 实际上为 JavaScript 新增了块级作用域。</p>\n<p>var 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>\n<p>为了纠正这种现象，let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>\n<ol start=\"2\">\n<li>const 命令<br>const 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\">PI; <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\">PI = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表明改变常量的值会报错。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> v;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">() =&gt;</span> <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>箭头函数使得表达更加简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n * n;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>\n<p>箭头函数的一个用处是简化回调函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正常函数写法</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 箭头函数写法</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正常函数写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 箭头函数写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>\n\n<p>箭头函数有几个使用注意点。</p>\n<ol>\n<li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li>\n<li>不可以使用 arguments 对象，该对象在函数体内不存在。</li>\n</ol>\n<h3 id=\"变量解构（解构赋值）\"><a href=\"#变量解构（解构赋值）\" class=\"headerlink\" title=\"变量解构（解构赋值）\"></a>变量解构（解构赋值）</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构<br>以前，为变量赋值，只能直接指定值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>ES6 允许写成下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值<br>解构不仅可以用于数组，还可以用于对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo, bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"attr\">bar</span>: <span class=\"string\">&quot;bbb&quot;</span> &#125;;</span><br><span class=\"line\">foo; <span class=\"comment\">// &quot;aaa&quot;</span></span><br><span class=\"line\">bar; <span class=\"comment\">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; bar, foo &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"attr\">bar</span>: <span class=\"string\">&quot;bbb&quot;</span> &#125;;</span><br><span class=\"line\">foo; <span class=\"comment\">// &quot;aaa&quot;</span></span><br><span class=\"line\">bar; <span class=\"comment\">// &quot;bbb&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"attr\">bar</span>: <span class=\"string\">&quot;bbb&quot;</span> &#125;;</span><br><span class=\"line\">foo; <span class=\"comment\">// &quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串扩展\"><a href=\"#字符串扩展\" class=\"headerlink\" title=\"字符串扩展\"></a>字符串扩展</h3><p>模板字符串（template string）是增强版的字符串</p>\n<p>传统的 JavaScript 语言，输出模板通常是这样写的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = a + b;</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = a + <span class=\"string\">&quot;+&quot;</span> + b + <span class=\"string\">&quot;的和是&lt;b&gt;&quot;</span> + c + <span class=\"string\">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">box.innerHTML = res;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;&lt;b&gt;姓名&lt;/b&gt;：&quot;</span> + obj.name + <span class=\"string\">&quot;&lt;b&gt;年龄&lt;/b&gt;:&quot;</span> + obj.age;</span><br><span class=\"line\">div.innerHTML = str;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。<br>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在${}之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = a + b;</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"string\">`a+b的和是&lt;b&gt;<span class=\"subst\">$&#123;c&#125;</span>&lt;/b&gt;`</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">box.innerHTML = res;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;b&gt;姓名&lt;/b&gt;：<span class=\"subst\">$&#123;obj.name&#125;</span>&lt;b&gt;年龄&lt;/b&gt;:<span class=\"subst\">$&#123;obj.age&#125;</span>`</span>;</span><br><span class=\"line\">div.innerHTML = str;</span><br></pre></td></tr></table></figure>\n<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> greeting = <span class=\"string\">`\\`Yo\\` World!`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oDiv.innerHTML = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">&lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">et x = <span class=\"number\">1</span>;<span class=\"keyword\">let</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y&#125;</span> = <span class=\"subst\">$&#123;x + y&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;1 + 2 = 3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y * <span class=\"number\">2</span>&#125;</span> = <span class=\"subst\">$&#123;x + y * <span class=\"number\">2</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;1 + 4 = 5&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;obj.x + obj.y&#125;</span>`</span></span><br></pre></td></tr></table></figure>\n\n<p>模板字符串之中还能调用函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`foo <span class=\"subst\">$&#123;fn()&#125;</span> bar`</span>;</span><br><span class=\"line\"><span class=\"comment\">// foo Hello World bar</span></span><br></pre></td></tr></table></figure>\n\n<p>字符串扩张方法<br>传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。<br>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">s.startsWith(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.endsWith(<span class=\"string\">&quot;!&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.includes(<span class=\"string\">&quot;o&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;x&quot;</span>.repeat(<span class=\"number\">3</span>); <span class=\"comment\">// &quot;xxx&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello&quot;</span>.repeat(<span class=\"number\">2</span>); <span class=\"comment\">// &quot;hellohello&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;na&quot;</span>.repeat(<span class=\"number\">0</span>); <span class=\"comment\">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组新增方法\"><a href=\"#数组新增方法\" class=\"headerlink\" title=\"数组新增方法\"></a>数组新增方法</h3><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 Set 和 Map）<br>下面是一个类似数组的对象，Array.from 将它转为真正的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">&quot;a&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&quot;b&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">&quot;c&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组</p>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; foo &#125;;</span><br><span class=\"line\">baz; <span class=\"comment\">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; <span class=\"attr\">foo</span>: foo &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>除了属性简写，方法也可以简写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  <span class=\"attr\">method</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h3><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = &#123; ...z &#125;;</span><br><span class=\"line\">n; <span class=\"comment\">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123; ...[<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>] &#125;;</span><br><span class=\"line\">foo;</span><br><span class=\"line\"><span class=\"comment\">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>对象的扩展运算符等同于使用Object.assign()方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> aClone = &#123; ...a &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> aClone = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">4</span>, <span class=\"number\">38</span>];</span><br><span class=\"line\">add(...numbers); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//该运算符将一个数组，变为参数序列</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 合并数组</span></span><br><span class=\"line\">[...arr1, ...arr2, ...arr3];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数参数默认值\"><a href=\"#函数参数默认值\" class=\"headerlink\" title=\"函数参数默认值\"></a>函数参数默认值</h3><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  y = y || <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;China&quot;</span>); <span class=\"comment\">// Hello China</span></span><br><span class=\"line\"><span class=\"comment\">//这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y = <span class=\"string\">&quot;World&quot;</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\">log(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;China&quot;</span>); <span class=\"comment\">// Hello China</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。</p>\n<h3 id=\"Symbol-类型\"><a href=\"#Symbol-类型\" class=\"headerlink\" title=\"Symbol 类型\"></a>Symbol 类型</h3><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因</p>\n<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）</p>\n<p>Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s;</span><br><span class=\"line\"><span class=\"comment\">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型<br>注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<br>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">s1; <span class=\"comment\">// Symbol(foo)</span></span><br><span class=\"line\">s2; <span class=\"comment\">// Symbol(bar)</span></span><br><span class=\"line\">s1.toString(); <span class=\"comment\">// &quot;Symbol(foo)&quot;</span></span><br><span class=\"line\">s2.toString(); <span class=\"comment\">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>\n<p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有参数的情况</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\">s1 === s2; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">// 有参数的情况</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">s1 === s2; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。<br>Symbol 值也可以转为布尔值，但是不能转为数值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(sym); <span class=\"comment\">// true</span></span><br><span class=\"line\">!sym; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (sym) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(sym); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">sym + <span class=\"number\">2</span>; <span class=\"comment\">// TypeError</span></span><br></pre></td></tr></table></figure>\n\n<p>作为属性名的 Symbol<br>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;&#125;;</span><br><span class=\"line\">a[mySymbol] = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">  [mySymbol]: <span class=\"string\">&quot;Hello!&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 以上写法都得到同样结果</span></span><br><span class=\"line\">a[mySymbol]; <span class=\"comment\">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.mySymbol = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\">a[mySymbol]; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a[<span class=\"string\">&quot;mySymbol&quot;</span>]; <span class=\"comment\">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。<br>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg</span>) </span>&#123; ... &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj[s](<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s，而不是 s 所代表的那个 Symbol 值。</p>\n<h3 id=\"Set-和-Map-结构\"><a href=\"#Set-和-Map-结构\" class=\"headerlink\" title=\"Set 和 Map 结构\"></a>Set 和 Map 结构</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].forEach(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> s.add(x));</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码通过 add 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。<br>Set 函数可以接受一个数组（获取 dom 的 nodelist 对象）作为参数，用来初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set];</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">items.size; <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">&quot;div&quot;</span>));</span><br><span class=\"line\">set.size; <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码也展示了一种去除数组重复成员的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>(array)];</span><br></pre></td></tr></table></figure>\n\n<p>向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\">set.add(a);</span><br><span class=\"line\">set.add(b);</span><br><span class=\"line\">set; <span class=\"comment\">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>Set 结构的实例有以下属性<br>constructor：构造函数，默认就是 Set 函数。<br>size：返回 Set 实例的成员总数。<br>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面四个操作方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add(value):添加某个值，返回 Set 结构本身。</span></span><br><span class=\"line\"><span class=\"comment\">//delete(value):删除某个值，返回一个布尔值，表示删除是否成功。</span></span><br><span class=\"line\"><span class=\"comment\">//has(value)：返回一个布尔值，表示该值是否为Set的成员。</span></span><br><span class=\"line\"><span class=\"comment\">//clear()：清除所有成员，没有返回值。</span></span><br><span class=\"line\">s.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 注意2被加入了两次</span></span><br><span class=\"line\">s.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">s.has(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">2</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">3</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">s.delete(<span class=\"number\">2</span>);</span><br><span class=\"line\">s.has(<span class=\"number\">2</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Array-from-方法可以将-Set-结构转为数组。\"><a href=\"#Array-from-方法可以将-Set-结构转为数组。\" class=\"headerlink\" title=\"Array.from 方法可以将 Set 结构转为数组。\"></a>Array.from 方法可以将 Set 结构转为数组。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> set) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br></pre></td></tr></table></figure>\n\n<p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>]);</span><br><span class=\"line\">set.forEach(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(key + <span class=\"string\">&quot; : &quot;</span> + value));</span><br><span class=\"line\"><span class=\"comment\">// 1 : 1</span></span><br><span class=\"line\"><span class=\"comment\">// 4 : 4</span></span><br><span class=\"line\"><span class=\"comment\">// 9 : 9</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码说明，forEach 方法的参数就是一个处理函数。该函数的参数与数组的 forEach 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>\n<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>map 结构<br>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<p>Map 结构的实例有以下属性和操作方法。</p>\n<ol>\n<li>size 属性<br>size 属性返回 Map 结构的成员总数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>set(key, value)<br>set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 键是字符串</span></span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>); <span class=\"comment\">// 键是数值</span></span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>); <span class=\"comment\">// 键是 undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>set 方法返回的是当前的 Map 对象，因此可以采用链式写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"number\">1</span>, <span class=\"string\">&quot;a&quot;</span>).set(<span class=\"number\">2</span>, <span class=\"string\">&quot;b&quot;</span>).set(<span class=\"number\">3</span>, <span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>get(key)<br>get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">m.set(hello, <span class=\"string\">&quot;Hello ES6!&quot;</span>); <span class=\"comment\">// 键是函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.get(hello); <span class=\"comment\">// Hello ES6!</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>has(key)<br>has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>);</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;edition&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;years&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">m.has(<span class=\"number\">262</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>delete(key)<br>delete 方法删除某个键，返回 true。如果删除失败，返回 false。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.delete(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>clear()<br>clear 方法清除所有成员，没有返回值。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.clear();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>遍历 map</p>\n<p>需要特别注意的是，Map 的遍历顺序就是插入顺序</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">&quot;F&quot;</span>, <span class=\"string\">&quot;no&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;yes&quot;</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot; &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot; &quot;yes&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Generators-生成器函数\"><a href=\"#Generators-生成器函数\" class=\"headerlink\" title=\"Generators 生成器函数\"></a>Generators 生成器函数</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同<br>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;ending&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（hello 和 world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>\n<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p>\n<h3 id=\"yield-表达式\"><a href=\"#yield-表达式\" class=\"headerlink\" title=\"yield 表达式\"></a>yield 表达式</h3><p>由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 表达式就是暂停标志。</p>\n<ol>\n<li>遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</li>\n<li>下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。</li>\n<li>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</li>\n<li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined</li>\n</ol>\n<p>下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class=\"line\">hw.next();</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码一共调用了四次 next 方法。<br>第一次调用，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello，done 属性的值 false，表示遍历还没有结束。<br>第二次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world，done 属性的值 false，表示遍历还没有结束。<br>第三次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。<br>第四次调用，此时 Generator 函数已经运行完毕，next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后再调用 next 方法，返回的都是这个值。</p>\n<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p>\n<h3 id=\"class-的写法及继承\"><a href=\"#class-的写法及继承\" class=\"headerlink\" title=\"class 的写法及继承\"></a>class 的写法及继承</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。<br>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。</p>\n<p>基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 class 改写，就是下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法</p>\n<p>point 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hasOwnProperty 可以用来判断对象是否有每一个属性</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;x&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6 的类，完全可以看作构造函数的另一种写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> Point; <span class=\"comment\">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数</p>\n<p>类的属性名，可以采用表达式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> methodName = <span class=\"string\">&quot;getArea&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">length</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [methodName]() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Square 类的方法名 getArea，是从表达式得到的。</p>\n<p>类内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>\n<p>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>\n<h3 id=\"constructor-方法\"><a href=\"#constructor-方法\" class=\"headerlink\" title=\"constructor 方法\"></a>constructor 方法</h3><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，定义了一个空的类 Point，JavaScript 引擎会自动为它添加一个空的 constructor 方法。</p>\n<p>constructor 方法默认返回实例对象（即 this）</p>\n<p>类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Class constructor Foo cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new，像函数那样调用 Class，将会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Foo(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类方法<br>加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">classMethod</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.classMethod(); <span class=\"comment\">// &#x27;hello&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.classMethod();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><p>Class 可以通过 extends 关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y, color</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(x, y); <span class=\"comment\">// 调用父类的constructor(x, y)</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.color + <span class=\"string\">&quot; &quot;</span> + <span class=\"built_in\">super</span>.toString(); <span class=\"comment\">// 调用父类的toString()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。</p>\n<p>ES6 要求，子类的构造函数必须执行一次 super 函数</p>\n<p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，ColorPoint 继承了父类 Point，但是它的构造函数没有调用 super 方法，导致新建实例时报错。</p>\n<p>需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x, y, color</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>(x, y);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"hexo+yilia搭建博客的坎坷历程","date":"2019-10-19T04:04:18.000Z","_content":"### 我为什么要搭建一篇博客？\n---\n\n<!--more--> \n\n&#10052; 之前在学习的过程中，遇到过的很多问题，基本上都是通过百度解决的，然后也见了很多人搭建了自己博客，并且每个人的博客对于他们来说的作用都不一样，我决定搭建一个博客也是觉得我的学习历程可以被记录下来，就当做我在前端进阶之路上的一个日记本吧。\n\n&#10052; 也有出于挑战一下的心态，我选了 hexo 加 github 搭建博客，hexo 还没接触过，但是知道这样搭建的博客还是基于 node.js 的，同时也希望在搭建的过程中学习到一些新的东西。\n\n&#10052; 反正酷就完事儿了！\n\n```\n 这是我的第一片原创文章\n```\n&#10052; 具体搭建的方法网上有很多，我就不写了(因为本人比较懒~哈哈哈)  \n\n&#10052; 这里给大家放个[链接https://www.jianshu.com/p/6745fe11bc7f](https://www.jianshu.com/p/6745fe11bc7f) 可以自己看看\n\n## 主题\n\n### 选主题\n\n&#10052; 这里先放一个 [hexo](https://hexo.io/themes/) 官网的主题库，可以选一下想要的主题\n\n### 下载主题\n\n&#10052; 在你的博客文件目录下打开 git Bash，执行下列命令：\n\n```bash\ngit clone https://github.com/yiluyanxia/hexo-theme-antiquity.git themes/yilia\n```\n&#10052; 然后打开你的博客目录，会发现themes文件下多出一个yilia文件夹, 默认的应该只有个landscape\n\n### 修改配置\n\n&#10052; 打开博客文件根目录下的_config.yml 文件，进行修改\n\n```\ntheme：antiquity  #初始值应该是landscape\n```\n\n&#10052; 然后执行 hexo s 就可以在本地看到更新后的主题了。\n\n### 注：\n\n&#10052; 如果有其他不懂得地方多参考官方教程和相关教程，多搜索，读文档，慢慢修改，先本地服务器查看一下，确认无误后再上传到giuhub\n\n---\n\n本文作者： 一只野生东子","source":"_posts/blog.md","raw":"---\ntitle: hexo+yilia搭建博客的坎坷历程\ndate: 2019-10-19 12:04:18\ntags: blog、bash\n---\n### 我为什么要搭建一篇博客？\n---\n\n<!--more--> \n\n&#10052; 之前在学习的过程中，遇到过的很多问题，基本上都是通过百度解决的，然后也见了很多人搭建了自己博客，并且每个人的博客对于他们来说的作用都不一样，我决定搭建一个博客也是觉得我的学习历程可以被记录下来，就当做我在前端进阶之路上的一个日记本吧。\n\n&#10052; 也有出于挑战一下的心态，我选了 hexo 加 github 搭建博客，hexo 还没接触过，但是知道这样搭建的博客还是基于 node.js 的，同时也希望在搭建的过程中学习到一些新的东西。\n\n&#10052; 反正酷就完事儿了！\n\n```\n 这是我的第一片原创文章\n```\n&#10052; 具体搭建的方法网上有很多，我就不写了(因为本人比较懒~哈哈哈)  \n\n&#10052; 这里给大家放个[链接https://www.jianshu.com/p/6745fe11bc7f](https://www.jianshu.com/p/6745fe11bc7f) 可以自己看看\n\n## 主题\n\n### 选主题\n\n&#10052; 这里先放一个 [hexo](https://hexo.io/themes/) 官网的主题库，可以选一下想要的主题\n\n### 下载主题\n\n&#10052; 在你的博客文件目录下打开 git Bash，执行下列命令：\n\n```bash\ngit clone https://github.com/yiluyanxia/hexo-theme-antiquity.git themes/yilia\n```\n&#10052; 然后打开你的博客目录，会发现themes文件下多出一个yilia文件夹, 默认的应该只有个landscape\n\n### 修改配置\n\n&#10052; 打开博客文件根目录下的_config.yml 文件，进行修改\n\n```\ntheme：antiquity  #初始值应该是landscape\n```\n\n&#10052; 然后执行 hexo s 就可以在本地看到更新后的主题了。\n\n### 注：\n\n&#10052; 如果有其他不懂得地方多参考官方教程和相关教程，多搜索，读文档，慢慢修改，先本地服务器查看一下，确认无误后再上传到giuhub\n\n---\n\n本文作者： 一只野生东子","slug":"blog","published":1,"updated":"2021-11-26T09:02:32.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2a00039co32lth6zkp","content":"<h3 id=\"我为什么要搭建一篇博客？\"><a href=\"#我为什么要搭建一篇博客？\" class=\"headerlink\" title=\"我为什么要搭建一篇博客？\"></a>我为什么要搭建一篇博客？</h3><hr>\n<span id=\"more\"></span> \n\n<p>&#10052; 之前在学习的过程中，遇到过的很多问题，基本上都是通过百度解决的，然后也见了很多人搭建了自己博客，并且每个人的博客对于他们来说的作用都不一样，我决定搭建一个博客也是觉得我的学习历程可以被记录下来，就当做我在前端进阶之路上的一个日记本吧。</p>\n<p>&#10052; 也有出于挑战一下的心态，我选了 hexo 加 github 搭建博客，hexo 还没接触过，但是知道这样搭建的博客还是基于 node.js 的，同时也希望在搭建的过程中学习到一些新的东西。</p>\n<p>&#10052; 反正酷就完事儿了！</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是我的第一片原创文章</span><br></pre></td></tr></table></figure></div>\n<p>&#10052; 具体搭建的方法网上有很多，我就不写了(因为本人比较懒~哈哈哈)  </p>\n<p>&#10052; 这里给大家放个<a href=\"https://www.jianshu.com/p/6745fe11bc7f\">链接https://www.jianshu.com/p/6745fe11bc7f</a> 可以自己看看</p>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><h3 id=\"选主题\"><a href=\"#选主题\" class=\"headerlink\" title=\"选主题\"></a>选主题</h3><p>&#10052; 这里先放一个 <a href=\"https://hexo.io/themes/\">hexo</a> 官网的主题库，可以选一下想要的主题</p>\n<h3 id=\"下载主题\"><a href=\"#下载主题\" class=\"headerlink\" title=\"下载主题\"></a>下载主题</h3><p>&#10052; 在你的博客文件目录下打开 git Bash，执行下列命令：</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight /bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/yiluyanxia/hexo-theme-antiquity.git themes/yilia</span><br></pre></td></tr></table></figure></div>\n<p>&#10052; 然后打开你的博客目录，会发现themes文件下多出一个yilia文件夹, 默认的应该只有个landscape</p>\n<h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3><p>&#10052; 打开博客文件根目录下的_config.yml 文件，进行修改</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme：antiquity  #初始值应该是landscape</span><br></pre></td></tr></table></figure></div>\n\n<p>&#10052; 然后执行 hexo s 就可以在本地看到更新后的主题了。</p>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><p>&#10052; 如果有其他不懂得地方多参考官方教程和相关教程，多搜索，读文档，慢慢修改，先本地服务器查看一下，确认无误后再上传到giuhub</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"我为什么要搭建一篇博客？\"><a href=\"#我为什么要搭建一篇博客？\" class=\"headerlink\" title=\"我为什么要搭建一篇博客？\"></a>我为什么要搭建一篇博客？</h3><hr>","more":"<p>&#10052; 之前在学习的过程中，遇到过的很多问题，基本上都是通过百度解决的，然后也见了很多人搭建了自己博客，并且每个人的博客对于他们来说的作用都不一样，我决定搭建一个博客也是觉得我的学习历程可以被记录下来，就当做我在前端进阶之路上的一个日记本吧。</p>\n<p>&#10052; 也有出于挑战一下的心态，我选了 hexo 加 github 搭建博客，hexo 还没接触过，但是知道这样搭建的博客还是基于 node.js 的，同时也希望在搭建的过程中学习到一些新的东西。</p>\n<p>&#10052; 反正酷就完事儿了！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是我的第一片原创文章</span><br></pre></td></tr></table></figure>\n<p>&#10052; 具体搭建的方法网上有很多，我就不写了(因为本人比较懒~哈哈哈)  </p>\n<p>&#10052; 这里给大家放个<a href=\"https://www.jianshu.com/p/6745fe11bc7f\">链接https://www.jianshu.com/p/6745fe11bc7f</a> 可以自己看看</p>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><h3 id=\"选主题\"><a href=\"#选主题\" class=\"headerlink\" title=\"选主题\"></a>选主题</h3><p>&#10052; 这里先放一个 <a href=\"https://hexo.io/themes/\">hexo</a> 官网的主题库，可以选一下想要的主题</p>\n<h3 id=\"下载主题\"><a href=\"#下载主题\" class=\"headerlink\" title=\"下载主题\"></a>下载主题</h3><p>&#10052; 在你的博客文件目录下打开 git Bash，执行下列命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/yiluyanxia/hexo-theme-antiquity.git themes/yilia</span><br></pre></td></tr></table></figure>\n<p>&#10052; 然后打开你的博客目录，会发现themes文件下多出一个yilia文件夹, 默认的应该只有个landscape</p>\n<h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3><p>&#10052; 打开博客文件根目录下的_config.yml 文件，进行修改</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme：antiquity  #初始值应该是landscape</span><br></pre></td></tr></table></figure>\n\n<p>&#10052; 然后执行 hexo s 就可以在本地看到更新后的主题了。</p>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><p>&#10052; 如果有其他不懂得地方多参考官方教程和相关教程，多搜索，读文档，慢慢修改，先本地服务器查看一下，确认无误后再上传到giuhub</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"JS基本语法","date":"2019-11-29T16:00:00.000Z","_content":"\n### JavaScript 基本介绍及发展趋势\n\nECMAScript\n通过 ECMA-262 标准化的脚本程序语言，JavaScript 是其实现和扩展。\n1999 年 ES3 发布，成为 JavaScript 的通行标准。\n2009 年 ES5 发布，在所有现代浏览器中得到了相当完全的实现\n2015 年 ES6 发布，被部分实现于大部分现代浏览器\n\n<!--more--> \n\n原生应用 web 应用 （跨平台） app\nJavaScript 概念\nJavaScript 是基于对象和事件驱动，并具有安全性能的客户端脚本语言，弱类型的语言。\n解释执行 （编译-》代码转为 0 和 1）\n由三部分组成：\nECMAScript（核心）\nDOM（文档对象模型）document object model\nBOM（浏览器对象模型）browser object model\n高级编程， 面向对象编程\n\n### JavaScript 和 HTML5 的关系\n\nHTML5 的新特性\n新的内容元素\n新的表单控件\n媒介元素\n绘画\n本地存储\n\n广义的 HTML5 是包括 HTML、CSS、JavaScript 在内的一套技术组合\n狭义的 HTML5 更多的是指 JavaScript.\n\n### 编写 JS 及如何运行 JS\n\n1. 在 HTML 标签中直接写入 JS 代码（用的少）\n\n```<div id='div1' onclick='alert(“你好”)'>点击</div>```\n\n2. 在 HTML 文档中写入代码\n```<script></script>```\n\n3. 在*.js 文件中写入 JS 代码(工作中常用)\n```<script src=”a.js”></script>```\n\n4. 注释\n  //\n  /**/\n\n### 变量及命名规则\n\n1. 变量的声明和定义\n   var a = 10;\n   var 是关键字， a 是变量名， =是赋值符号 10 是值\n2. 变量的命名规则\n   变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。\n  （驼峰法则，见名知义）\n3. 关键字\n   ECMAScript 描述了一组特定用途的关键字，不能用作变量名，例如：If else do while for in 等。\n\n### 算术、赋值、关系运算符\n\n算术运算符\n\n```js\n+\t -    *    /      %\n\n```\n\n赋值运算符\n\n```js\n=   +=  -=  *=   /=  %=\n```\n\n关系运算符\n\n```js\n>   <   >=   <=   ==  !=    ===   !==\n```\n\nvar num = 3.11111\nnum.toFixed(3)// toFixed(n) 保留 n 位小数\n\n### 数据类型及类型转换\n\nJavaScript 数据类型\n数值、字符串、布尔、undefined、null、对象\n\nJavaScript 类型转换\n隐式转换\n显式转换\n\n### 逻辑运算符\n\n逻辑与 && and\n\n逻辑或 || or\n\n逻辑非 ！ not\n\n### 自增自减运算\n\n自增++\n自减–\n\n### 八进制和十六进制\n\n八进制 071\n十六进制 0x12\n\n### Number 方法的应用，NaN\n\nNaN(not a number):不是一个数字\nNumber()：将值转化为数字\n\n---\n\n本文作者： 一只野生东子","source":"_posts/JS基本语法.md","raw":"---\ntitle: JS基本语法\ndate: 2019-11-30\ntags: javaScript\n---\n\n### JavaScript 基本介绍及发展趋势\n\nECMAScript\n通过 ECMA-262 标准化的脚本程序语言，JavaScript 是其实现和扩展。\n1999 年 ES3 发布，成为 JavaScript 的通行标准。\n2009 年 ES5 发布，在所有现代浏览器中得到了相当完全的实现\n2015 年 ES6 发布，被部分实现于大部分现代浏览器\n\n<!--more--> \n\n原生应用 web 应用 （跨平台） app\nJavaScript 概念\nJavaScript 是基于对象和事件驱动，并具有安全性能的客户端脚本语言，弱类型的语言。\n解释执行 （编译-》代码转为 0 和 1）\n由三部分组成：\nECMAScript（核心）\nDOM（文档对象模型）document object model\nBOM（浏览器对象模型）browser object model\n高级编程， 面向对象编程\n\n### JavaScript 和 HTML5 的关系\n\nHTML5 的新特性\n新的内容元素\n新的表单控件\n媒介元素\n绘画\n本地存储\n\n广义的 HTML5 是包括 HTML、CSS、JavaScript 在内的一套技术组合\n狭义的 HTML5 更多的是指 JavaScript.\n\n### 编写 JS 及如何运行 JS\n\n1. 在 HTML 标签中直接写入 JS 代码（用的少）\n\n```<div id='div1' onclick='alert(“你好”)'>点击</div>```\n\n2. 在 HTML 文档中写入代码\n```<script></script>```\n\n3. 在*.js 文件中写入 JS 代码(工作中常用)\n```<script src=”a.js”></script>```\n\n4. 注释\n  //\n  /**/\n\n### 变量及命名规则\n\n1. 变量的声明和定义\n   var a = 10;\n   var 是关键字， a 是变量名， =是赋值符号 10 是值\n2. 变量的命名规则\n   变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。\n  （驼峰法则，见名知义）\n3. 关键字\n   ECMAScript 描述了一组特定用途的关键字，不能用作变量名，例如：If else do while for in 等。\n\n### 算术、赋值、关系运算符\n\n算术运算符\n\n```js\n+\t -    *    /      %\n\n```\n\n赋值运算符\n\n```js\n=   +=  -=  *=   /=  %=\n```\n\n关系运算符\n\n```js\n>   <   >=   <=   ==  !=    ===   !==\n```\n\nvar num = 3.11111\nnum.toFixed(3)// toFixed(n) 保留 n 位小数\n\n### 数据类型及类型转换\n\nJavaScript 数据类型\n数值、字符串、布尔、undefined、null、对象\n\nJavaScript 类型转换\n隐式转换\n显式转换\n\n### 逻辑运算符\n\n逻辑与 && and\n\n逻辑或 || or\n\n逻辑非 ！ not\n\n### 自增自减运算\n\n自增++\n自减–\n\n### 八进制和十六进制\n\n八进制 071\n十六进制 0x12\n\n### Number 方法的应用，NaN\n\nNaN(not a number):不是一个数字\nNumber()：将值转化为数字\n\n---\n\n本文作者： 一只野生东子","slug":"JS基本语法","published":1,"updated":"2021-11-26T07:12:41.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2b00049co3bndyaibe","content":"<h3 id=\"JavaScript-基本介绍及发展趋势\"><a href=\"#JavaScript-基本介绍及发展趋势\" class=\"headerlink\" title=\"JavaScript 基本介绍及发展趋势\"></a>JavaScript 基本介绍及发展趋势</h3><p>ECMAScript<br>通过 ECMA-262 标准化的脚本程序语言，JavaScript 是其实现和扩展。<br>1999 年 ES3 发布，成为 JavaScript 的通行标准。<br>2009 年 ES5 发布，在所有现代浏览器中得到了相当完全的实现<br>2015 年 ES6 发布，被部分实现于大部分现代浏览器</p>\n<span id=\"more\"></span> \n\n<p>原生应用 web 应用 （跨平台） app<br>JavaScript 概念<br>JavaScript 是基于对象和事件驱动，并具有安全性能的客户端脚本语言，弱类型的语言。<br>解释执行 （编译-》代码转为 0 和 1）<br>由三部分组成：<br>ECMAScript（核心）<br>DOM（文档对象模型）document object model<br>BOM（浏览器对象模型）browser object model<br>高级编程， 面向对象编程</p>\n<h3 id=\"JavaScript-和-HTML5-的关系\"><a href=\"#JavaScript-和-HTML5-的关系\" class=\"headerlink\" title=\"JavaScript 和 HTML5 的关系\"></a>JavaScript 和 HTML5 的关系</h3><p>HTML5 的新特性<br>新的内容元素<br>新的表单控件<br>媒介元素<br>绘画<br>本地存储</p>\n<p>广义的 HTML5 是包括 HTML、CSS、JavaScript 在内的一套技术组合<br>狭义的 HTML5 更多的是指 JavaScript.</p>\n<h3 id=\"编写-JS-及如何运行-JS\"><a href=\"#编写-JS-及如何运行-JS\" class=\"headerlink\" title=\"编写 JS 及如何运行 JS\"></a>编写 JS 及如何运行 JS</h3><ol>\n<li>在 HTML 标签中直接写入 JS 代码（用的少）</li>\n</ol>\n<p><code>&lt;div id=&#39;div1&#39; onclick=&#39;alert(“你好”)&#39;&gt;点击&lt;/div&gt;</code></p>\n<ol start=\"2\">\n<li><p>在 HTML 文档中写入代码<br><code>&lt;script&gt;&lt;/script&gt;</code></p>\n</li>\n<li><p>在*.js 文件中写入 JS 代码(工作中常用)<br><code>&lt;script src=”a.js”&gt;&lt;/script&gt;</code></p>\n</li>\n<li><p>注释<br>//<br>/**/</p>\n</li>\n</ol>\n<h3 id=\"变量及命名规则\"><a href=\"#变量及命名规则\" class=\"headerlink\" title=\"变量及命名规则\"></a>变量及命名规则</h3><ol>\n<li>变量的声明和定义<br>var a = 10;<br>var 是关键字， a 是变量名， =是赋值符号 10 是值</li>\n<li>变量的命名规则<br>变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。<br>（驼峰法则，见名知义）</li>\n<li>关键字<br>ECMAScript 描述了一组特定用途的关键字，不能用作变量名，例如：If else do while for in 等。</li>\n</ol>\n<h3 id=\"算术、赋值、关系运算符\"><a href=\"#算术、赋值、关系运算符\" class=\"headerlink\" title=\"算术、赋值、关系运算符\"></a>算术、赋值、关系运算符</h3><p>算术运算符</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+\t -    *    /      %</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>赋值运算符</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=   +=  -=  *=   /=  %=</span><br></pre></td></tr></table></figure></div>\n\n<p>关系运算符</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;   &lt;   &gt;=   &lt;=   ==  !=    ===   !==</span><br></pre></td></tr></table></figure></div>\n\n<p>var num = 3.11111<br>num.toFixed(3)// toFixed(n) 保留 n 位小数</p>\n<h3 id=\"数据类型及类型转换\"><a href=\"#数据类型及类型转换\" class=\"headerlink\" title=\"数据类型及类型转换\"></a>数据类型及类型转换</h3><p>JavaScript 数据类型<br>数值、字符串、布尔、undefined、null、对象</p>\n<p>JavaScript 类型转换<br>隐式转换<br>显式转换</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>逻辑与 &amp;&amp; and</p>\n<p>逻辑或 || or</p>\n<p>逻辑非 ！ not</p>\n<h3 id=\"自增自减运算\"><a href=\"#自增自减运算\" class=\"headerlink\" title=\"自增自减运算\"></a>自增自减运算</h3><p>自增++<br>自减–</p>\n<h3 id=\"八进制和十六进制\"><a href=\"#八进制和十六进制\" class=\"headerlink\" title=\"八进制和十六进制\"></a>八进制和十六进制</h3><p>八进制 071<br>十六进制 0x12</p>\n<h3 id=\"Number-方法的应用，NaN\"><a href=\"#Number-方法的应用，NaN\" class=\"headerlink\" title=\"Number 方法的应用，NaN\"></a>Number 方法的应用，NaN</h3><p>NaN(not a number):不是一个数字<br>Number()：将值转化为数字</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"JavaScript-基本介绍及发展趋势\"><a href=\"#JavaScript-基本介绍及发展趋势\" class=\"headerlink\" title=\"JavaScript 基本介绍及发展趋势\"></a>JavaScript 基本介绍及发展趋势</h3><p>ECMAScript<br>通过 ECMA-262 标准化的脚本程序语言，JavaScript 是其实现和扩展。<br>1999 年 ES3 发布，成为 JavaScript 的通行标准。<br>2009 年 ES5 发布，在所有现代浏览器中得到了相当完全的实现<br>2015 年 ES6 发布，被部分实现于大部分现代浏览器</p>","more":"<p>原生应用 web 应用 （跨平台） app<br>JavaScript 概念<br>JavaScript 是基于对象和事件驱动，并具有安全性能的客户端脚本语言，弱类型的语言。<br>解释执行 （编译-》代码转为 0 和 1）<br>由三部分组成：<br>ECMAScript（核心）<br>DOM（文档对象模型）document object model<br>BOM（浏览器对象模型）browser object model<br>高级编程， 面向对象编程</p>\n<h3 id=\"JavaScript-和-HTML5-的关系\"><a href=\"#JavaScript-和-HTML5-的关系\" class=\"headerlink\" title=\"JavaScript 和 HTML5 的关系\"></a>JavaScript 和 HTML5 的关系</h3><p>HTML5 的新特性<br>新的内容元素<br>新的表单控件<br>媒介元素<br>绘画<br>本地存储</p>\n<p>广义的 HTML5 是包括 HTML、CSS、JavaScript 在内的一套技术组合<br>狭义的 HTML5 更多的是指 JavaScript.</p>\n<h3 id=\"编写-JS-及如何运行-JS\"><a href=\"#编写-JS-及如何运行-JS\" class=\"headerlink\" title=\"编写 JS 及如何运行 JS\"></a>编写 JS 及如何运行 JS</h3><ol>\n<li>在 HTML 标签中直接写入 JS 代码（用的少）</li>\n</ol>\n<p><code>&lt;div id=&#39;div1&#39; onclick=&#39;alert(“你好”)&#39;&gt;点击&lt;/div&gt;</code></p>\n<ol start=\"2\">\n<li><p>在 HTML 文档中写入代码<br><code>&lt;script&gt;&lt;/script&gt;</code></p>\n</li>\n<li><p>在*.js 文件中写入 JS 代码(工作中常用)<br><code>&lt;script src=”a.js”&gt;&lt;/script&gt;</code></p>\n</li>\n<li><p>注释<br>//<br>/**/</p>\n</li>\n</ol>\n<h3 id=\"变量及命名规则\"><a href=\"#变量及命名规则\" class=\"headerlink\" title=\"变量及命名规则\"></a>变量及命名规则</h3><ol>\n<li>变量的声明和定义<br>var a = 10;<br>var 是关键字， a 是变量名， =是赋值符号 10 是值</li>\n<li>变量的命名规则<br>变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。<br>（驼峰法则，见名知义）</li>\n<li>关键字<br>ECMAScript 描述了一组特定用途的关键字，不能用作变量名，例如：If else do while for in 等。</li>\n</ol>\n<h3 id=\"算术、赋值、关系运算符\"><a href=\"#算术、赋值、关系运算符\" class=\"headerlink\" title=\"算术、赋值、关系运算符\"></a>算术、赋值、关系运算符</h3><p>算术运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+\t -    *    /      %</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>赋值运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=   +=  -=  *=   /=  %=</span><br></pre></td></tr></table></figure>\n\n<p>关系运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;   &lt;   &gt;=   &lt;=   ==  !=    ===   !==</span><br></pre></td></tr></table></figure>\n\n<p>var num = 3.11111<br>num.toFixed(3)// toFixed(n) 保留 n 位小数</p>\n<h3 id=\"数据类型及类型转换\"><a href=\"#数据类型及类型转换\" class=\"headerlink\" title=\"数据类型及类型转换\"></a>数据类型及类型转换</h3><p>JavaScript 数据类型<br>数值、字符串、布尔、undefined、null、对象</p>\n<p>JavaScript 类型转换<br>隐式转换<br>显式转换</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>逻辑与 &amp;&amp; and</p>\n<p>逻辑或 || or</p>\n<p>逻辑非 ！ not</p>\n<h3 id=\"自增自减运算\"><a href=\"#自增自减运算\" class=\"headerlink\" title=\"自增自减运算\"></a>自增自减运算</h3><p>自增++<br>自减–</p>\n<h3 id=\"八进制和十六进制\"><a href=\"#八进制和十六进制\" class=\"headerlink\" title=\"八进制和十六进制\"></a>八进制和十六进制</h3><p>八进制 071<br>十六进制 0x12</p>\n<h3 id=\"Number-方法的应用，NaN\"><a href=\"#Number-方法的应用，NaN\" class=\"headerlink\" title=\"Number 方法的应用，NaN\"></a>Number 方法的应用，NaN</h3><p>NaN(not a number):不是一个数字<br>Number()：将值转化为数字</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"css3D转换和关键帧动画","date":"2019-10-21T16:00:00.000Z","_content":"\n### css 3D 转换\n\nCSS3 3D 转换 transform(3D 位移、缩放、旋转)\n\n让元素方式 3d 的变换，同 2d 变换一样，通过 transform 来设置\n**位移**：translate3D(x,y,z)\n**缩放**：scale3d(x,y,z) scalez()不能单独使用；\n**旋转**：rotatex(80deg) rotatey(80deg) rotatez(80deg)\n\n<!--more--> \n\n转换是使元素改变形状、尺寸和位置的一种效果。\n\n可以使用 2D 或 3D 转换来转换元素。\n\n在转换概念当中：是没有 display 这么一说的，\n通过改变元素的透明度去实现从无到有\n\nIE 10 和 Firefox 支持 3D 转换。\n\nChrome 和 Safari 需要前缀 -webkit-。\n\nOpera 仍然不支持 3D 转换（它只支持 2D 转换）。\n\n1. 观察的场所—-3D 空间 transform-style\n   transform-style:preserve-3d;   表示所有子元素在 3D 空间呈现\n2. 近大远小—-景深 perspective\n   元素距离观察点的距离（物体和眼睛的距离越小，近大远小的效果越明显）\n   perspective:1200px;(在父元素中使用）\n   通常的数值在 900-1200 之间，如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉\n3. 观察 3D 元素的（位置）角度—-景深的角度perspective-origin\n   perspective-origin:left top （左上角）\n\n### 这三种写法是等价\n```css\ntransform: translate3d(30px,30px,800px )\n\ntransform:translateZ(800px)  translateX(30px)  translateY(30px) ;\n\ntransform:translateZ(800px) translate(30px,30px);\n```\n\n### preserve-3d放到父元素\n\n```css\n-webkit-transform-style: preserve-3d;\n-moz-transform-style: preserve-3d;\n-ms-transform-style: preserve-3d;\n-o-transform-style: preserve-3d;\ntransform-style: preserve-3d;\n```\n\ntransform 向元素应用 2D 或 3D 转换。\ntransform-origin 允许你改变被转换元素的位置。\ntransform-style 规定被嵌套元素如何在 3D 空间中显示。\nperspective 规定 3D 元素的透视效果。\nperspective-origin 规定 3D 元素的底部位置。\nbackface-visibility 定义元素在不面对屏幕时是否可见\n\n### 2D Transform 方法\n\nmatrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。\ntranslate3d(x,y,z) 定义 3D 转化。\ntranslateX(x) 定义 3D 转化，仅使用用于 X 轴的值。\ntranslateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。\ntranslateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。\nscale3d(x,y,z) 定义 3D 缩放转换。\nscaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。\nscaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。\nscaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。\nrotate3d(x,y,z,angle) 定义 3D 旋转。\nrotateX(angle) 定义沿 X 轴的 3D 旋转。\nrotateY(angle) 定义沿 Y 轴的 3D 旋转。\nrotateZ(angle) 定义沿 Z 轴的 3D 旋转。\nperspective(n) 定义 3D 转换元素的透视视图。\n\n### CSS3 动画\n\n通过 CSS3，我们能够创建动画，\n这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript\n\n1. CSS3 @keyframes 规则\n   如需在 CSS3 中创建动画，需要学习 @keyframes 规则。\n   @keyframes 规则用于创建动画。\n   在 @keyframes 中规定某项 CSS 样式，\n   就能创建由当前样式逐渐改为新样式的动画效果。\n   Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。\n   Chrome 和 Safari 需要前缀 -webkit-。\n\n注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。\n\n2. 使用方法\n\n第一步：\n```css\n@-webkit-keyframes  动画名称{\n    0%｛ 本关键帧中的样式｝\n    10%｛ 本关键帧中的样式｝\n      ......\n    100%｛ 本关键帧中的样式｝\n}\n```\n\n第二步：动画设计好后，使用 animation 属性调用动画。方法如下：\n```css\n想加动画元素的选择器{ -webkit-animation:  move 2s 3s linear 2 normal ｝\n  /* 动画名称  持续时间   延迟时间       运动形式     播放次数  是否倒放*/\n```\n\n### 关键帧语法\n```css\n@keyframes name {\n  from {\n    properties: Properties value;\n  }\n  to {\n    properties: Properties value;\n  }\n}\n```\n\n样例\n```css\n@-webkit-keyframes move {\n    0% {\n      margin-left: 100px;\n      background: green;\n    }\n    40% {\n      margin-left: 150px;\n      background: orange;\n    }\n    60% {\n      margin-left: 75px;\n      background: blue;\n    }\n    100% {\n      margin-left: 100px;\n      background: red;\n    }\n}\n```\n```css\n-webkit-animation-name: move; /*动画属性名，前面keyframes样例定义的动画名*/\n-webkit-animation-duration: 10s; /*动画持续时间*/\n-webkit-animation-timing-function: ease-in-out; /*动画帧频，和transition-timing-function是一样的*/\n/*ease | linear | ease-in | ease-out | cubic-Bezier (n1 , n2, n3, n4)*/\n-webkit-animation-delay: 2s; /*动画延迟时间*/\n-webkit-animation-iteration-count: 10; /*动画循环次数，infinite为无限次*/\n-webkit-animation-direction: normal; /*定义动画播放方式*/\n/*默认normal，动画正常播放；  alternate，动画轮流反向播放*/\n```\n\n3. 实现动画的方法：\n   A、linear：从开始到结束都是以同样的速度进行.\n   B、ease-in：开始速度很慢，然后沿着曲线进行加快.\n   C、ease-out：开始速度很快，然后沿着曲线进行减速.\n   D、ease：开始时速度很快，然后沿着曲线进行减速，然后再沿着曲线加速.\n   E、ease-in-out：开始时速度很慢，然后沿着曲线进行加速，然后再沿着曲线减速.\n   F、step-start; /_ 马上跳到动画每一结束桢的状态 _/\n\n### CSS3 动画属性\n\n@keyframes 规定动画。\nanimation 所有动画属性的简写属性，除了 animation-play-state 属性。\nanimation-name 规定 @keyframes 动画的名称。\nanimation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。\nanimation-timing-function 规定动画的速度曲线。默认是 “ease”。\nanimation-delay 规定动画何时开始。默认是 0。\nanimation-iteration-count 规定动画被播放的次数。默认是 1。\nanimation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。\nanimation-play-state 规定动画是否正在运行或暂停。默认是 “running”。\nanimation-fill-mode 规定对象动画时间之外的状态。\n\n---\n本文作者： 一只野生东子","source":"_posts/css3D转换和关键帧动画.md","raw":"---\ntitle: css3D转换和关键帧动画\ndate: 2019-10-22\ntags: css\n---\n\n### css 3D 转换\n\nCSS3 3D 转换 transform(3D 位移、缩放、旋转)\n\n让元素方式 3d 的变换，同 2d 变换一样，通过 transform 来设置\n**位移**：translate3D(x,y,z)\n**缩放**：scale3d(x,y,z) scalez()不能单独使用；\n**旋转**：rotatex(80deg) rotatey(80deg) rotatez(80deg)\n\n<!--more--> \n\n转换是使元素改变形状、尺寸和位置的一种效果。\n\n可以使用 2D 或 3D 转换来转换元素。\n\n在转换概念当中：是没有 display 这么一说的，\n通过改变元素的透明度去实现从无到有\n\nIE 10 和 Firefox 支持 3D 转换。\n\nChrome 和 Safari 需要前缀 -webkit-。\n\nOpera 仍然不支持 3D 转换（它只支持 2D 转换）。\n\n1. 观察的场所—-3D 空间 transform-style\n   transform-style:preserve-3d;   表示所有子元素在 3D 空间呈现\n2. 近大远小—-景深 perspective\n   元素距离观察点的距离（物体和眼睛的距离越小，近大远小的效果越明显）\n   perspective:1200px;(在父元素中使用）\n   通常的数值在 900-1200 之间，如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉\n3. 观察 3D 元素的（位置）角度—-景深的角度perspective-origin\n   perspective-origin:left top （左上角）\n\n### 这三种写法是等价\n```css\ntransform: translate3d(30px,30px,800px )\n\ntransform:translateZ(800px)  translateX(30px)  translateY(30px) ;\n\ntransform:translateZ(800px) translate(30px,30px);\n```\n\n### preserve-3d放到父元素\n\n```css\n-webkit-transform-style: preserve-3d;\n-moz-transform-style: preserve-3d;\n-ms-transform-style: preserve-3d;\n-o-transform-style: preserve-3d;\ntransform-style: preserve-3d;\n```\n\ntransform 向元素应用 2D 或 3D 转换。\ntransform-origin 允许你改变被转换元素的位置。\ntransform-style 规定被嵌套元素如何在 3D 空间中显示。\nperspective 规定 3D 元素的透视效果。\nperspective-origin 规定 3D 元素的底部位置。\nbackface-visibility 定义元素在不面对屏幕时是否可见\n\n### 2D Transform 方法\n\nmatrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。\ntranslate3d(x,y,z) 定义 3D 转化。\ntranslateX(x) 定义 3D 转化，仅使用用于 X 轴的值。\ntranslateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。\ntranslateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。\nscale3d(x,y,z) 定义 3D 缩放转换。\nscaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。\nscaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。\nscaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。\nrotate3d(x,y,z,angle) 定义 3D 旋转。\nrotateX(angle) 定义沿 X 轴的 3D 旋转。\nrotateY(angle) 定义沿 Y 轴的 3D 旋转。\nrotateZ(angle) 定义沿 Z 轴的 3D 旋转。\nperspective(n) 定义 3D 转换元素的透视视图。\n\n### CSS3 动画\n\n通过 CSS3，我们能够创建动画，\n这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript\n\n1. CSS3 @keyframes 规则\n   如需在 CSS3 中创建动画，需要学习 @keyframes 规则。\n   @keyframes 规则用于创建动画。\n   在 @keyframes 中规定某项 CSS 样式，\n   就能创建由当前样式逐渐改为新样式的动画效果。\n   Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。\n   Chrome 和 Safari 需要前缀 -webkit-。\n\n注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。\n\n2. 使用方法\n\n第一步：\n```css\n@-webkit-keyframes  动画名称{\n    0%｛ 本关键帧中的样式｝\n    10%｛ 本关键帧中的样式｝\n      ......\n    100%｛ 本关键帧中的样式｝\n}\n```\n\n第二步：动画设计好后，使用 animation 属性调用动画。方法如下：\n```css\n想加动画元素的选择器{ -webkit-animation:  move 2s 3s linear 2 normal ｝\n  /* 动画名称  持续时间   延迟时间       运动形式     播放次数  是否倒放*/\n```\n\n### 关键帧语法\n```css\n@keyframes name {\n  from {\n    properties: Properties value;\n  }\n  to {\n    properties: Properties value;\n  }\n}\n```\n\n样例\n```css\n@-webkit-keyframes move {\n    0% {\n      margin-left: 100px;\n      background: green;\n    }\n    40% {\n      margin-left: 150px;\n      background: orange;\n    }\n    60% {\n      margin-left: 75px;\n      background: blue;\n    }\n    100% {\n      margin-left: 100px;\n      background: red;\n    }\n}\n```\n```css\n-webkit-animation-name: move; /*动画属性名，前面keyframes样例定义的动画名*/\n-webkit-animation-duration: 10s; /*动画持续时间*/\n-webkit-animation-timing-function: ease-in-out; /*动画帧频，和transition-timing-function是一样的*/\n/*ease | linear | ease-in | ease-out | cubic-Bezier (n1 , n2, n3, n4)*/\n-webkit-animation-delay: 2s; /*动画延迟时间*/\n-webkit-animation-iteration-count: 10; /*动画循环次数，infinite为无限次*/\n-webkit-animation-direction: normal; /*定义动画播放方式*/\n/*默认normal，动画正常播放；  alternate，动画轮流反向播放*/\n```\n\n3. 实现动画的方法：\n   A、linear：从开始到结束都是以同样的速度进行.\n   B、ease-in：开始速度很慢，然后沿着曲线进行加快.\n   C、ease-out：开始速度很快，然后沿着曲线进行减速.\n   D、ease：开始时速度很快，然后沿着曲线进行减速，然后再沿着曲线加速.\n   E、ease-in-out：开始时速度很慢，然后沿着曲线进行加速，然后再沿着曲线减速.\n   F、step-start; /_ 马上跳到动画每一结束桢的状态 _/\n\n### CSS3 动画属性\n\n@keyframes 规定动画。\nanimation 所有动画属性的简写属性，除了 animation-play-state 属性。\nanimation-name 规定 @keyframes 动画的名称。\nanimation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。\nanimation-timing-function 规定动画的速度曲线。默认是 “ease”。\nanimation-delay 规定动画何时开始。默认是 0。\nanimation-iteration-count 规定动画被播放的次数。默认是 1。\nanimation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。\nanimation-play-state 规定动画是否正在运行或暂停。默认是 “running”。\nanimation-fill-mode 规定对象动画时间之外的状态。\n\n---\n本文作者： 一只野生东子","slug":"css3D转换和关键帧动画","published":1,"updated":"2021-11-26T06:13:46.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2c00059co374vqbld5","content":"<h3 id=\"css-3D-转换\"><a href=\"#css-3D-转换\" class=\"headerlink\" title=\"css 3D 转换\"></a>css 3D 转换</h3><p>CSS3 3D 转换 transform(3D 位移、缩放、旋转)</p>\n<p>让元素方式 3d 的变换，同 2d 变换一样，通过 transform 来设置<br><strong>位移</strong>：translate3D(x,y,z)<br><strong>缩放</strong>：scale3d(x,y,z) scalez()不能单独使用；<br><strong>旋转</strong>：rotatex(80deg) rotatey(80deg) rotatez(80deg)</p>\n<span id=\"more\"></span> \n\n<p>转换是使元素改变形状、尺寸和位置的一种效果。</p>\n<p>可以使用 2D 或 3D 转换来转换元素。</p>\n<p>在转换概念当中：是没有 display 这么一说的，<br>通过改变元素的透明度去实现从无到有</p>\n<p>IE 10 和 Firefox 支持 3D 转换。</p>\n<p>Chrome 和 Safari 需要前缀 -webkit-。</p>\n<p>Opera 仍然不支持 3D 转换（它只支持 2D 转换）。</p>\n<ol>\n<li>观察的场所—-3D 空间 transform-style<br>transform-style:preserve-3d;   表示所有子元素在 3D 空间呈现</li>\n<li>近大远小—-景深 perspective<br>元素距离观察点的距离（物体和眼睛的距离越小，近大远小的效果越明显）<br>perspective:1200px;(在父元素中使用）<br>通常的数值在 900-1200 之间，如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉</li>\n<li>观察 3D 元素的（位置）角度—-景深的角度perspective-origin<br>perspective-origin:left top （左上角）</li>\n</ol>\n<h3 id=\"这三种写法是等价\"><a href=\"#这三种写法是等价\" class=\"headerlink\" title=\"这三种写法是等价\"></a>这三种写法是等价</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">transform</span>: <span class=\"built_in\">translate3d</span>(<span class=\"number\">30px</span>,<span class=\"number\">30px</span>,<span class=\"number\">800px</span> )</span><br><span class=\"line\"></span><br><span class=\"line\">transform:<span class=\"built_in\">translateZ</span>(<span class=\"number\">800px</span>)  <span class=\"built_in\">translateX</span>(<span class=\"number\">30px</span>)  <span class=\"built_in\">translateY</span>(<span class=\"number\">30px</span>) ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">transform</span>:<span class=\"built_in\">translateZ</span>(<span class=\"number\">800px</span>) <span class=\"built_in\">translate</span>(<span class=\"number\">30px</span>,<span class=\"number\">30px</span>);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"preserve-3d放到父元素\"><a href=\"#preserve-3d放到父元素\" class=\"headerlink\" title=\"preserve-3d放到父元素\"></a>preserve-3d放到父元素</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">-moz-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">-ms-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">-o-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\"><span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br></pre></td></tr></table></figure></div>\n\n<p>transform 向元素应用 2D 或 3D 转换。<br>transform-origin 允许你改变被转换元素的位置。<br>transform-style 规定被嵌套元素如何在 3D 空间中显示。<br>perspective 规定 3D 元素的透视效果。<br>perspective-origin 规定 3D 元素的底部位置。<br>backface-visibility 定义元素在不面对屏幕时是否可见</p>\n<h3 id=\"2D-Transform-方法\"><a href=\"#2D-Transform-方法\" class=\"headerlink\" title=\"2D Transform 方法\"></a>2D Transform 方法</h3><p>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。<br>translate3d(x,y,z) 定义 3D 转化。<br>translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。<br>translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。<br>translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。<br>scale3d(x,y,z) 定义 3D 缩放转换。<br>scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。<br>scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。<br>scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。<br>rotate3d(x,y,z,angle) 定义 3D 旋转。<br>rotateX(angle) 定义沿 X 轴的 3D 旋转。<br>rotateY(angle) 定义沿 Y 轴的 3D 旋转。<br>rotateZ(angle) 定义沿 Z 轴的 3D 旋转。<br>perspective(n) 定义 3D 转换元素的透视视图。</p>\n<h3 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a>CSS3 动画</h3><p>通过 CSS3，我们能够创建动画，<br>这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript</p>\n<ol>\n<li>CSS3 @keyframes 规则<br>如需在 CSS3 中创建动画，需要学习 @keyframes 规则。<br>@keyframes 规则用于创建动画。<br>在 @keyframes 中规定某项 CSS 样式，<br>就能创建由当前样式逐渐改为新样式的动画效果。<br>Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。<br>Chrome 和 Safari 需要前缀 -webkit-。</li>\n</ol>\n<p>注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。</p>\n<ol start=\"2\">\n<li>使用方法</li>\n</ol>\n<p>第一步：</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@-webkit-keyframes</span>  动画名称&#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>｛ 本关键帧中的样式｝</span><br><span class=\"line\">    <span class=\"number\">10%</span>｛ 本关键帧中的样式｝</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    <span class=\"number\">100%</span>｛ 本关键帧中的样式｝</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>第二步：动画设计好后，使用 animation 属性调用动画。方法如下：</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">想加动画元素的选择器&#123; -webkit-<span class=\"attribute\">animation</span>:  move <span class=\"number\">2s</span> <span class=\"number\">3s</span> linear <span class=\"number\">2</span> normal ｝</span><br><span class=\"line\">  /* 动画名称  持续时间   延迟时间       运动形式     播放次数  是否倒放*/</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"关键帧语法\"><a href=\"#关键帧语法\" class=\"headerlink\" title=\"关键帧语法\"></a>关键帧语法</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> name &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">    properties: Properties value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">    properties: Properties value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>样例</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@-webkit-keyframes</span> move &#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">40%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: orange;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">60%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">75px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-<span class=\"attribute\">animation-name</span>: move; <span class=\"comment\">/*动画属性名，前面keyframes样例定义的动画名*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-duration</span>: <span class=\"number\">10s</span>; <span class=\"comment\">/*动画持续时间*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-timing-function</span>: ease-in-out; <span class=\"comment\">/*动画帧频，和transition-timing-function是一样的*/</span></span><br><span class=\"line\"><span class=\"comment\">/*ease | linear | ease-in | ease-out | cubic-Bezier (n1 , n2, n3, n4)*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-delay</span>: <span class=\"number\">2s</span>; <span class=\"comment\">/*动画延迟时间*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-iteration-count</span>: <span class=\"number\">10</span>; <span class=\"comment\">/*动画循环次数，infinite为无限次*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-direction</span>: normal; <span class=\"comment\">/*定义动画播放方式*/</span></span><br><span class=\"line\"><span class=\"comment\">/*默认normal，动画正常播放；  alternate，动画轮流反向播放*/</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li>实现动画的方法：<br>A、linear：从开始到结束都是以同样的速度进行.<br>B、ease-in：开始速度很慢，然后沿着曲线进行加快.<br>C、ease-out：开始速度很快，然后沿着曲线进行减速.<br>D、ease：开始时速度很快，然后沿着曲线进行减速，然后再沿着曲线加速.<br>E、ease-in-out：开始时速度很慢，然后沿着曲线进行加速，然后再沿着曲线减速.<br>F、step-start; /_ 马上跳到动画每一结束桢的状态 _/</li>\n</ol>\n<h3 id=\"CSS3-动画属性\"><a href=\"#CSS3-动画属性\" class=\"headerlink\" title=\"CSS3 动画属性\"></a>CSS3 动画属性</h3><p>@keyframes 规定动画。<br>animation 所有动画属性的简写属性，除了 animation-play-state 属性。<br>animation-name 规定 @keyframes 动画的名称。<br>animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。<br>animation-timing-function 规定动画的速度曲线。默认是 “ease”。<br>animation-delay 规定动画何时开始。默认是 0。<br>animation-iteration-count 规定动画被播放的次数。默认是 1。<br>animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。<br>animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。<br>animation-fill-mode 规定对象动画时间之外的状态。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"css-3D-转换\"><a href=\"#css-3D-转换\" class=\"headerlink\" title=\"css 3D 转换\"></a>css 3D 转换</h3><p>CSS3 3D 转换 transform(3D 位移、缩放、旋转)</p>\n<p>让元素方式 3d 的变换，同 2d 变换一样，通过 transform 来设置<br><strong>位移</strong>：translate3D(x,y,z)<br><strong>缩放</strong>：scale3d(x,y,z) scalez()不能单独使用；<br><strong>旋转</strong>：rotatex(80deg) rotatey(80deg) rotatez(80deg)</p>","more":"<p>转换是使元素改变形状、尺寸和位置的一种效果。</p>\n<p>可以使用 2D 或 3D 转换来转换元素。</p>\n<p>在转换概念当中：是没有 display 这么一说的，<br>通过改变元素的透明度去实现从无到有</p>\n<p>IE 10 和 Firefox 支持 3D 转换。</p>\n<p>Chrome 和 Safari 需要前缀 -webkit-。</p>\n<p>Opera 仍然不支持 3D 转换（它只支持 2D 转换）。</p>\n<ol>\n<li>观察的场所—-3D 空间 transform-style<br>transform-style:preserve-3d;   表示所有子元素在 3D 空间呈现</li>\n<li>近大远小—-景深 perspective<br>元素距离观察点的距离（物体和眼睛的距离越小，近大远小的效果越明显）<br>perspective:1200px;(在父元素中使用）<br>通常的数值在 900-1200 之间，如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉</li>\n<li>观察 3D 元素的（位置）角度—-景深的角度perspective-origin<br>perspective-origin:left top （左上角）</li>\n</ol>\n<h3 id=\"这三种写法是等价\"><a href=\"#这三种写法是等价\" class=\"headerlink\" title=\"这三种写法是等价\"></a>这三种写法是等价</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">transform</span>: <span class=\"built_in\">translate3d</span>(<span class=\"number\">30px</span>,<span class=\"number\">30px</span>,<span class=\"number\">800px</span> )</span><br><span class=\"line\"></span><br><span class=\"line\">transform:<span class=\"built_in\">translateZ</span>(<span class=\"number\">800px</span>)  <span class=\"built_in\">translateX</span>(<span class=\"number\">30px</span>)  <span class=\"built_in\">translateY</span>(<span class=\"number\">30px</span>) ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">transform</span>:<span class=\"built_in\">translateZ</span>(<span class=\"number\">800px</span>) <span class=\"built_in\">translate</span>(<span class=\"number\">30px</span>,<span class=\"number\">30px</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"preserve-3d放到父元素\"><a href=\"#preserve-3d放到父元素\" class=\"headerlink\" title=\"preserve-3d放到父元素\"></a>preserve-3d放到父元素</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">-moz-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">-ms-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\">-o-<span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br><span class=\"line\"><span class=\"attribute\">transform-style</span>: preserve-<span class=\"number\">3</span>d;</span><br></pre></td></tr></table></figure>\n\n<p>transform 向元素应用 2D 或 3D 转换。<br>transform-origin 允许你改变被转换元素的位置。<br>transform-style 规定被嵌套元素如何在 3D 空间中显示。<br>perspective 规定 3D 元素的透视效果。<br>perspective-origin 规定 3D 元素的底部位置。<br>backface-visibility 定义元素在不面对屏幕时是否可见</p>\n<h3 id=\"2D-Transform-方法\"><a href=\"#2D-Transform-方法\" class=\"headerlink\" title=\"2D Transform 方法\"></a>2D Transform 方法</h3><p>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。<br>translate3d(x,y,z) 定义 3D 转化。<br>translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。<br>translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。<br>translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。<br>scale3d(x,y,z) 定义 3D 缩放转换。<br>scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。<br>scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。<br>scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。<br>rotate3d(x,y,z,angle) 定义 3D 旋转。<br>rotateX(angle) 定义沿 X 轴的 3D 旋转。<br>rotateY(angle) 定义沿 Y 轴的 3D 旋转。<br>rotateZ(angle) 定义沿 Z 轴的 3D 旋转。<br>perspective(n) 定义 3D 转换元素的透视视图。</p>\n<h3 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a>CSS3 动画</h3><p>通过 CSS3，我们能够创建动画，<br>这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript</p>\n<ol>\n<li>CSS3 @keyframes 规则<br>如需在 CSS3 中创建动画，需要学习 @keyframes 规则。<br>@keyframes 规则用于创建动画。<br>在 @keyframes 中规定某项 CSS 样式，<br>就能创建由当前样式逐渐改为新样式的动画效果。<br>Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。<br>Chrome 和 Safari 需要前缀 -webkit-。</li>\n</ol>\n<p>注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。</p>\n<ol start=\"2\">\n<li>使用方法</li>\n</ol>\n<p>第一步：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@-webkit-keyframes</span>  动画名称&#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>｛ 本关键帧中的样式｝</span><br><span class=\"line\">    <span class=\"number\">10%</span>｛ 本关键帧中的样式｝</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    <span class=\"number\">100%</span>｛ 本关键帧中的样式｝</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：动画设计好后，使用 animation 属性调用动画。方法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">想加动画元素的选择器&#123; -webkit-<span class=\"attribute\">animation</span>:  move <span class=\"number\">2s</span> <span class=\"number\">3s</span> linear <span class=\"number\">2</span> normal ｝</span><br><span class=\"line\">  /* 动画名称  持续时间   延迟时间       运动形式     播放次数  是否倒放*/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键帧语法\"><a href=\"#关键帧语法\" class=\"headerlink\" title=\"关键帧语法\"></a>关键帧语法</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> name &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">    properties: Properties value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">    properties: Properties value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>样例</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@-webkit-keyframes</span> move &#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">40%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: orange;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">60%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">75px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-<span class=\"attribute\">animation-name</span>: move; <span class=\"comment\">/*动画属性名，前面keyframes样例定义的动画名*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-duration</span>: <span class=\"number\">10s</span>; <span class=\"comment\">/*动画持续时间*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-timing-function</span>: ease-in-out; <span class=\"comment\">/*动画帧频，和transition-timing-function是一样的*/</span></span><br><span class=\"line\"><span class=\"comment\">/*ease | linear | ease-in | ease-out | cubic-Bezier (n1 , n2, n3, n4)*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-delay</span>: <span class=\"number\">2s</span>; <span class=\"comment\">/*动画延迟时间*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-iteration-count</span>: <span class=\"number\">10</span>; <span class=\"comment\">/*动画循环次数，infinite为无限次*/</span></span><br><span class=\"line\">-webkit-<span class=\"attribute\">animation-direction</span>: normal; <span class=\"comment\">/*定义动画播放方式*/</span></span><br><span class=\"line\"><span class=\"comment\">/*默认normal，动画正常播放；  alternate，动画轮流反向播放*/</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>实现动画的方法：<br>A、linear：从开始到结束都是以同样的速度进行.<br>B、ease-in：开始速度很慢，然后沿着曲线进行加快.<br>C、ease-out：开始速度很快，然后沿着曲线进行减速.<br>D、ease：开始时速度很快，然后沿着曲线进行减速，然后再沿着曲线加速.<br>E、ease-in-out：开始时速度很慢，然后沿着曲线进行加速，然后再沿着曲线减速.<br>F、step-start; /_ 马上跳到动画每一结束桢的状态 _/</li>\n</ol>\n<h3 id=\"CSS3-动画属性\"><a href=\"#CSS3-动画属性\" class=\"headerlink\" title=\"CSS3 动画属性\"></a>CSS3 动画属性</h3><p>@keyframes 规定动画。<br>animation 所有动画属性的简写属性，除了 animation-play-state 属性。<br>animation-name 规定 @keyframes 动画的名称。<br>animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。<br>animation-timing-function 规定动画的速度曲线。默认是 “ease”。<br>animation-delay 规定动画何时开始。默认是 0。<br>animation-iteration-count 规定动画被播放的次数。默认是 1。<br>animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。<br>animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。<br>animation-fill-mode 规定对象动画时间之外的状态。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-11-29T05:17:39.288Z","updated":"2021-11-26T03:11:40.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2d00089co30bi2gita","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight /bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight /bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></div>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight /bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></div>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight /bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></div>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"localStorage本地存储","date":"2020-05-14T16:00:00.000Z","_content":"\n### 什么是 localStorage\n\n在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，\n解决了 cookie 存储空间不足的问题(cookie 中每条 cookie 的存储空间为 4k)，\nlocalStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同\n\n<!--more--> \n\n### localStorage 的优势\n\n1. localStorage 拓展了 cookie 的 4K 限制\n2. localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于 cookie 可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\n### localStorage 的局限\n\n1. 浏览器的大小不统一，并且在 IE8 以上的 IE 版本才支持 localStorage 这个属性\n2. 目前所有的浏览器中都会把 localStorage 的值类型限定为 string 类型，这个在对我们日常比较常见的 JSON 对象类型需要一些转换\n\n### localStorage 的写入\n\nlocalStorage 的写入有三种方法。 localStorage 只支持 string 类型的存储\n\n```js\nvar storage = window.localStorage;\n//写入a字段\nstorage[\"a\"] = 1;\n//写入b字段\nstorage.a = 1;\n//写入c字段\nstorage.setItem(\"c\", 3);\n```\n\n### 三种对 localStorage 的读取\n\n其中官方推荐的是 getItem\\setItem 这两种方法对其进行存取\n\n```js\n//第一种方法读取\nvar a = storage.a;\nconsole.log(a);\n//第二种方法读取\nvar b = storage[\"b\"];\nconsole.log(b);\n//第三种方法读取\nvar c = storage.getItem(\"c\");\nconsole.log(c);\n``` \n### localStorage 的修改\n\n改这个步骤比较好理解，思路跟重新更改全局变量的值一样\n\n```js\nvar storage = window.localStorage;\n//写入a字段\nstorage[\"a\"] = 1;\nstorage.a = 4; //修改\nconsole.log(storage.a);\n``` \n\n### localStorage 的删除\n\n将 localStorage 中的某个键值对删除\n\n```js\nstorage.setItem(\"c\", 3);\nconsole.log(storage);\nstorage.removeItem(\"a\");\n```\n\n### 将 localStorage 的所有内容清除\n\n```js\nstorage.clear();\n```\n\n### localStorage 其他注意事项\n\n一般我们会将 JSON(js 中的对象)存入 localStorage 中，但是在 localStorage 会自动将 localStorage 转换成为字符串形式\n这个时候我们可以使用 JSON.stringify()这个方法，来将 JSON 转换成为 JSON 字符串\n\n```js\nvar data = {\n  name: \"zhangsan\",\n  sex: \"man\",\n};\nvar d = JSON.stringify(data);\nstorage.setItem(\"data\", d);\n//将JSON字符串转换成为JSON对象输出\nvar json = storage.getItem(\"data\");\nvar jsonObj = JSON.parse(json);\n```\n\n---\n\n本文作者： 一只野生东子","source":"_posts/localStorage本地存储.md","raw":"---\ntitle: localStorage本地存储\ndate: 2020-05-15\ntags: javaScript\n---\n\n### 什么是 localStorage\n\n在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，\n解决了 cookie 存储空间不足的问题(cookie 中每条 cookie 的存储空间为 4k)，\nlocalStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同\n\n<!--more--> \n\n### localStorage 的优势\n\n1. localStorage 拓展了 cookie 的 4K 限制\n2. localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于 cookie 可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\n### localStorage 的局限\n\n1. 浏览器的大小不统一，并且在 IE8 以上的 IE 版本才支持 localStorage 这个属性\n2. 目前所有的浏览器中都会把 localStorage 的值类型限定为 string 类型，这个在对我们日常比较常见的 JSON 对象类型需要一些转换\n\n### localStorage 的写入\n\nlocalStorage 的写入有三种方法。 localStorage 只支持 string 类型的存储\n\n```js\nvar storage = window.localStorage;\n//写入a字段\nstorage[\"a\"] = 1;\n//写入b字段\nstorage.a = 1;\n//写入c字段\nstorage.setItem(\"c\", 3);\n```\n\n### 三种对 localStorage 的读取\n\n其中官方推荐的是 getItem\\setItem 这两种方法对其进行存取\n\n```js\n//第一种方法读取\nvar a = storage.a;\nconsole.log(a);\n//第二种方法读取\nvar b = storage[\"b\"];\nconsole.log(b);\n//第三种方法读取\nvar c = storage.getItem(\"c\");\nconsole.log(c);\n``` \n### localStorage 的修改\n\n改这个步骤比较好理解，思路跟重新更改全局变量的值一样\n\n```js\nvar storage = window.localStorage;\n//写入a字段\nstorage[\"a\"] = 1;\nstorage.a = 4; //修改\nconsole.log(storage.a);\n``` \n\n### localStorage 的删除\n\n将 localStorage 中的某个键值对删除\n\n```js\nstorage.setItem(\"c\", 3);\nconsole.log(storage);\nstorage.removeItem(\"a\");\n```\n\n### 将 localStorage 的所有内容清除\n\n```js\nstorage.clear();\n```\n\n### localStorage 其他注意事项\n\n一般我们会将 JSON(js 中的对象)存入 localStorage 中，但是在 localStorage 会自动将 localStorage 转换成为字符串形式\n这个时候我们可以使用 JSON.stringify()这个方法，来将 JSON 转换成为 JSON 字符串\n\n```js\nvar data = {\n  name: \"zhangsan\",\n  sex: \"man\",\n};\nvar d = JSON.stringify(data);\nstorage.setItem(\"data\", d);\n//将JSON字符串转换成为JSON对象输出\nvar json = storage.getItem(\"data\");\nvar jsonObj = JSON.parse(json);\n```\n\n---\n\n本文作者： 一只野生东子","slug":"localStorage本地存储","published":1,"updated":"2021-11-26T09:01:08.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2e00099co30ykh85aj","content":"<h3 id=\"什么是-localStorage\"><a href=\"#什么是-localStorage\" class=\"headerlink\" title=\"什么是 localStorage\"></a>什么是 localStorage</h3><p>在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，<br>解决了 cookie 存储空间不足的问题(cookie 中每条 cookie 的存储空间为 4k)，<br>localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同</p>\n<span id=\"more\"></span> \n\n<h3 id=\"localStorage-的优势\"><a href=\"#localStorage-的优势\" class=\"headerlink\" title=\"localStorage 的优势\"></a>localStorage 的优势</h3><ol>\n<li>localStorage 拓展了 cookie 的 4K 限制</li>\n<li>localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于 cookie 可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</li>\n</ol>\n<h3 id=\"localStorage-的局限\"><a href=\"#localStorage-的局限\" class=\"headerlink\" title=\"localStorage 的局限\"></a>localStorage 的局限</h3><ol>\n<li>浏览器的大小不统一，并且在 IE8 以上的 IE 版本才支持 localStorage 这个属性</li>\n<li>目前所有的浏览器中都会把 localStorage 的值类型限定为 string 类型，这个在对我们日常比较常见的 JSON 对象类型需要一些转换</li>\n</ol>\n<h3 id=\"localStorage-的写入\"><a href=\"#localStorage-的写入\" class=\"headerlink\" title=\"localStorage 的写入\"></a>localStorage 的写入</h3><p>localStorage 的写入有三种方法。 localStorage 只支持 string 类型的存储</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> storage = <span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"><span class=\"comment\">//写入a字段</span></span><br><span class=\"line\">storage[<span class=\"string\">&quot;a&quot;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//写入b字段</span></span><br><span class=\"line\">storage.a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//写入c字段</span></span><br><span class=\"line\">storage.setItem(<span class=\"string\">&quot;c&quot;</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"三种对-localStorage-的读取\"><a href=\"#三种对-localStorage-的读取\" class=\"headerlink\" title=\"三种对 localStorage 的读取\"></a>三种对 localStorage 的读取</h3><p>其中官方推荐的是 getItem\\setItem 这两种方法对其进行存取</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种方法读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = storage.a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"comment\">//第二种方法读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = storage[<span class=\"string\">&quot;b&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">//第三种方法读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = storage.getItem(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c);</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"localStorage-的修改\"><a href=\"#localStorage-的修改\" class=\"headerlink\" title=\"localStorage 的修改\"></a>localStorage 的修改</h3><p>改这个步骤比较好理解，思路跟重新更改全局变量的值一样</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> storage = <span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"><span class=\"comment\">//写入a字段</span></span><br><span class=\"line\">storage[<span class=\"string\">&quot;a&quot;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">storage.a = <span class=\"number\">4</span>; <span class=\"comment\">//修改</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage.a);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"localStorage-的删除\"><a href=\"#localStorage-的删除\" class=\"headerlink\" title=\"localStorage 的删除\"></a>localStorage 的删除</h3><p>将 localStorage 中的某个键值对删除</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage.setItem(<span class=\"string\">&quot;c&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage);</span><br><span class=\"line\">storage.removeItem(<span class=\"string\">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"将-localStorage-的所有内容清除\"><a href=\"#将-localStorage-的所有内容清除\" class=\"headerlink\" title=\"将 localStorage 的所有内容清除\"></a>将 localStorage 的所有内容清除</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage.clear();</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"localStorage-其他注意事项\"><a href=\"#localStorage-其他注意事项\" class=\"headerlink\" title=\"localStorage 其他注意事项\"></a>localStorage 其他注意事项</h3><p>一般我们会将 JSON(js 中的对象)存入 localStorage 中，但是在 localStorage 会自动将 localStorage 转换成为字符串形式<br>这个时候我们可以使用 JSON.stringify()这个方法，来将 JSON 转换成为 JSON 字符串</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;zhangsan&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">&quot;man&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">JSON</span>.stringify(data);</span><br><span class=\"line\">storage.setItem(<span class=\"string\">&quot;data&quot;</span>, d);</span><br><span class=\"line\"><span class=\"comment\">//将JSON字符串转换成为JSON对象输出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = storage.getItem(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonObj = <span class=\"built_in\">JSON</span>.parse(json);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是-localStorage\"><a href=\"#什么是-localStorage\" class=\"headerlink\" title=\"什么是 localStorage\"></a>什么是 localStorage</h3><p>在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，<br>解决了 cookie 存储空间不足的问题(cookie 中每条 cookie 的存储空间为 4k)，<br>localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同</p>","more":"<h3 id=\"localStorage-的优势\"><a href=\"#localStorage-的优势\" class=\"headerlink\" title=\"localStorage 的优势\"></a>localStorage 的优势</h3><ol>\n<li>localStorage 拓展了 cookie 的 4K 限制</li>\n<li>localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于 cookie 可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</li>\n</ol>\n<h3 id=\"localStorage-的局限\"><a href=\"#localStorage-的局限\" class=\"headerlink\" title=\"localStorage 的局限\"></a>localStorage 的局限</h3><ol>\n<li>浏览器的大小不统一，并且在 IE8 以上的 IE 版本才支持 localStorage 这个属性</li>\n<li>目前所有的浏览器中都会把 localStorage 的值类型限定为 string 类型，这个在对我们日常比较常见的 JSON 对象类型需要一些转换</li>\n</ol>\n<h3 id=\"localStorage-的写入\"><a href=\"#localStorage-的写入\" class=\"headerlink\" title=\"localStorage 的写入\"></a>localStorage 的写入</h3><p>localStorage 的写入有三种方法。 localStorage 只支持 string 类型的存储</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> storage = <span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"><span class=\"comment\">//写入a字段</span></span><br><span class=\"line\">storage[<span class=\"string\">&quot;a&quot;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//写入b字段</span></span><br><span class=\"line\">storage.a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//写入c字段</span></span><br><span class=\"line\">storage.setItem(<span class=\"string\">&quot;c&quot;</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三种对-localStorage-的读取\"><a href=\"#三种对-localStorage-的读取\" class=\"headerlink\" title=\"三种对 localStorage 的读取\"></a>三种对 localStorage 的读取</h3><p>其中官方推荐的是 getItem\\setItem 这两种方法对其进行存取</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种方法读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = storage.a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"comment\">//第二种方法读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = storage[<span class=\"string\">&quot;b&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">//第三种方法读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = storage.getItem(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c);</span><br></pre></td></tr></table></figure>\n<h3 id=\"localStorage-的修改\"><a href=\"#localStorage-的修改\" class=\"headerlink\" title=\"localStorage 的修改\"></a>localStorage 的修改</h3><p>改这个步骤比较好理解，思路跟重新更改全局变量的值一样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> storage = <span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"><span class=\"comment\">//写入a字段</span></span><br><span class=\"line\">storage[<span class=\"string\">&quot;a&quot;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">storage.a = <span class=\"number\">4</span>; <span class=\"comment\">//修改</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage.a);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage-的删除\"><a href=\"#localStorage-的删除\" class=\"headerlink\" title=\"localStorage 的删除\"></a>localStorage 的删除</h3><p>将 localStorage 中的某个键值对删除</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage.setItem(<span class=\"string\">&quot;c&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage);</span><br><span class=\"line\">storage.removeItem(<span class=\"string\">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"将-localStorage-的所有内容清除\"><a href=\"#将-localStorage-的所有内容清除\" class=\"headerlink\" title=\"将 localStorage 的所有内容清除\"></a>将 localStorage 的所有内容清除</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage.clear();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage-其他注意事项\"><a href=\"#localStorage-其他注意事项\" class=\"headerlink\" title=\"localStorage 其他注意事项\"></a>localStorage 其他注意事项</h3><p>一般我们会将 JSON(js 中的对象)存入 localStorage 中，但是在 localStorage 会自动将 localStorage 转换成为字符串形式<br>这个时候我们可以使用 JSON.stringify()这个方法，来将 JSON 转换成为 JSON 字符串</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;zhangsan&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">sex</span>: <span class=\"string\">&quot;man&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">JSON</span>.stringify(data);</span><br><span class=\"line\">storage.setItem(<span class=\"string\">&quot;data&quot;</span>, d);</span><br><span class=\"line\"><span class=\"comment\">//将JSON字符串转换成为JSON对象输出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = storage.getItem(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonObj = <span class=\"built_in\">JSON</span>.parse(json);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"vue开发中需要注意的一些内容","date":"2020-06-12T16:00:00.000Z","_content":"\n### 主要用于记录在 Vue 项目开发中踩过的坑，或者没有了解过的东西(持续更新)\n\n前端学无止境 ヾ(ﾟ ∀ ﾟゞ)\n秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)\n\n<!--more-->\n\n### v-if 和 v-show 要学会区分开使用\n\n### 区别\n\n1. 手段：v-if 是通过控制 dom 节点的存在与否来控制元素的显隐;v-show 是通过设置 DOM 元素的 display 样式，block 为显示，none 为隐藏;\n2. 编译过程：v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件;v-show 只是简单的基于 css 切换;\n3. 编译条件：v-if 是惰性的，如果初始条件为假，则什么也不做;只有在条件第一次变为真时才开始局部编译（编译被缓存?编译被缓存后，然后再切换的时候进行局部卸载); v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留;\n4. 性能消耗：v-if 有更高的切换消耗;v-show 有更高的初始渲染消耗;\n\n### 使用场景\n\n基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好;如果在运行时条件很少改变，则使用 v-if 较好。\n\n### 总结\n\nv-if 判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show 调整 DOM 元素的 CSS 的 dispaly 属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n\n### 页面内监听 scroll 事件的方法\n\n如果是整个网页可以滑动，可以使用以下事件监听\n\n```js\nwindow.addEventListener(\"scroll\", function () {\n  console.log(\"scrolling\");\n});\n```\n\n但是大部分的场景是在一个元素内发生页面滚动\n\n举例：在页面内的一个div需要监听的\n\n* 滑动的组件外层的div加 ref=\"viewBox\" 为了通过$refs获取dom元素\n\n```html\n<!--设备列表-->\n<div class=\"deviceWrapper\" ref=\"viewBox\">\n <mu-refresh-control :refreshing=\"refreshing\" :trigger=\"trigger\" @refresh=\"refresh\"/>\n <div class=\"demo-grid\">\n <!--设备列表 手机一行两列 pad一行4列-->\n <mu-row>\n  <mu-col v-for=\"device in devicesList\" width=\"50\" tablet=\"25\" desktop=\"25\">\n  <deviceCardView :device-data=\"device\"\"></devicelightCardView>\n  </mu-col>\n </mu-row>\n </div>\n <p class=\"bottomLine\" v-bind:class=\"{bottomLineVisible:isScroll}\">---------------------我是有底线的---------------------</p>\n</div>\n```\n\n* 获取元素，监听事件\n\n```js\nmounted() {\n// 通过$refs获取dom元素\n this.box = this.$refs.viewBox\n // 监听这个dom的scroll事件\n this.box.addEventListener('scroll', () => {\n console.log(\" scroll \" + this.$refs.viewBox.scrollTop)\n //以下是我自己的需求，向下滚动的时候显示“我是有底线的（类似支付宝）”\n this.isScroll=this.$refs.viewBox.scrollTop>0\n }, false)\n}\n``` \n\n这样能正常打印出来.scrollTop\n\n### 封装一个组件，用于段落文字点击展开和收起功能\n\n### 组件调用方法\n\n```html\n<Unfold\n  data=\"这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。\"\n  maxLength=\"100\"\n/>\n``` \n\n属性说明\n\n```data```：文字数据\n```maxLen```：最大长度，超过这个数，被截取，默认 80，不改长度无需传值\n\n### 封装好组件的完整代码\n\n需要此功能的地方直接调用这个组件\n\n```html\n<template>\n  <span>\n    <span v-if=\"data.length < maxLen\">\n      <span class=\"tj\">{{ data }}</span>\n    </span>\n    <span v-else>\n      <span class=\"tj\"\n        >{{ showBtn ? sliceStr : data }}\n        <span class=\"btnWord\" @click=\"showBtn = !showBtn\">{{\n          showBtn ? \"全文\" : \"收起\"\n        }}</span>\n      </span>\n    </span>\n  </span>\n</template>\n\n<script>\nexport default {\n  name: \"unfold\",\n  data() {\n    return {\n      showBtn: true,\n    };\n  },\n  props: {\n    // 数据\n    data: {\n      type: String,\n      default: \"\",\n    },\n    // 最大长度\n    maxLen: {\n      type: Number,\n      default: 80,\n    },\n  },\n  computed: {\n    sliceStr() {\n      if (this.data != null) {\n        return this.data.substring(0, this.maxLen) + \"...\";\n      }\n      return \"\";\n    },\n  },\n};\n</script>\n\n<style lang=\"less\" scoped>\n.tj {\n  text-align: justify;\n}\n\n.btnWord {\n  color: cornflowerblue;\n  cursor: pointer;\n  word-break: keep-all;\n}\n</style>\n``` \n\n---\n\n本文作者： 一只野生东子","source":"_posts/vue随笔.md","raw":"---\ntitle: vue开发中需要注意的一些内容\ndate: 2020-06-13\ntags: vue\n---\n\n### 主要用于记录在 Vue 项目开发中踩过的坑，或者没有了解过的东西(持续更新)\n\n前端学无止境 ヾ(ﾟ ∀ ﾟゞ)\n秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)\n\n<!--more-->\n\n### v-if 和 v-show 要学会区分开使用\n\n### 区别\n\n1. 手段：v-if 是通过控制 dom 节点的存在与否来控制元素的显隐;v-show 是通过设置 DOM 元素的 display 样式，block 为显示，none 为隐藏;\n2. 编译过程：v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件;v-show 只是简单的基于 css 切换;\n3. 编译条件：v-if 是惰性的，如果初始条件为假，则什么也不做;只有在条件第一次变为真时才开始局部编译（编译被缓存?编译被缓存后，然后再切换的时候进行局部卸载); v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留;\n4. 性能消耗：v-if 有更高的切换消耗;v-show 有更高的初始渲染消耗;\n\n### 使用场景\n\n基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好;如果在运行时条件很少改变，则使用 v-if 较好。\n\n### 总结\n\nv-if 判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show 调整 DOM 元素的 CSS 的 dispaly 属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n\n### 页面内监听 scroll 事件的方法\n\n如果是整个网页可以滑动，可以使用以下事件监听\n\n```js\nwindow.addEventListener(\"scroll\", function () {\n  console.log(\"scrolling\");\n});\n```\n\n但是大部分的场景是在一个元素内发生页面滚动\n\n举例：在页面内的一个div需要监听的\n\n* 滑动的组件外层的div加 ref=\"viewBox\" 为了通过$refs获取dom元素\n\n```html\n<!--设备列表-->\n<div class=\"deviceWrapper\" ref=\"viewBox\">\n <mu-refresh-control :refreshing=\"refreshing\" :trigger=\"trigger\" @refresh=\"refresh\"/>\n <div class=\"demo-grid\">\n <!--设备列表 手机一行两列 pad一行4列-->\n <mu-row>\n  <mu-col v-for=\"device in devicesList\" width=\"50\" tablet=\"25\" desktop=\"25\">\n  <deviceCardView :device-data=\"device\"\"></devicelightCardView>\n  </mu-col>\n </mu-row>\n </div>\n <p class=\"bottomLine\" v-bind:class=\"{bottomLineVisible:isScroll}\">---------------------我是有底线的---------------------</p>\n</div>\n```\n\n* 获取元素，监听事件\n\n```js\nmounted() {\n// 通过$refs获取dom元素\n this.box = this.$refs.viewBox\n // 监听这个dom的scroll事件\n this.box.addEventListener('scroll', () => {\n console.log(\" scroll \" + this.$refs.viewBox.scrollTop)\n //以下是我自己的需求，向下滚动的时候显示“我是有底线的（类似支付宝）”\n this.isScroll=this.$refs.viewBox.scrollTop>0\n }, false)\n}\n``` \n\n这样能正常打印出来.scrollTop\n\n### 封装一个组件，用于段落文字点击展开和收起功能\n\n### 组件调用方法\n\n```html\n<Unfold\n  data=\"这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。\"\n  maxLength=\"100\"\n/>\n``` \n\n属性说明\n\n```data```：文字数据\n```maxLen```：最大长度，超过这个数，被截取，默认 80，不改长度无需传值\n\n### 封装好组件的完整代码\n\n需要此功能的地方直接调用这个组件\n\n```html\n<template>\n  <span>\n    <span v-if=\"data.length < maxLen\">\n      <span class=\"tj\">{{ data }}</span>\n    </span>\n    <span v-else>\n      <span class=\"tj\"\n        >{{ showBtn ? sliceStr : data }}\n        <span class=\"btnWord\" @click=\"showBtn = !showBtn\">{{\n          showBtn ? \"全文\" : \"收起\"\n        }}</span>\n      </span>\n    </span>\n  </span>\n</template>\n\n<script>\nexport default {\n  name: \"unfold\",\n  data() {\n    return {\n      showBtn: true,\n    };\n  },\n  props: {\n    // 数据\n    data: {\n      type: String,\n      default: \"\",\n    },\n    // 最大长度\n    maxLen: {\n      type: Number,\n      default: 80,\n    },\n  },\n  computed: {\n    sliceStr() {\n      if (this.data != null) {\n        return this.data.substring(0, this.maxLen) + \"...\";\n      }\n      return \"\";\n    },\n  },\n};\n</script>\n\n<style lang=\"less\" scoped>\n.tj {\n  text-align: justify;\n}\n\n.btnWord {\n  color: cornflowerblue;\n  cursor: pointer;\n  word-break: keep-all;\n}\n</style>\n``` \n\n---\n\n本文作者： 一只野生东子","slug":"vue随笔","published":1,"updated":"2021-11-29T03:09:35.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2e000b9co32cqy0hqf","content":"<h3 id=\"主要用于记录在-Vue-项目开发中踩过的坑，或者没有了解过的东西-持续更新\"><a href=\"#主要用于记录在-Vue-项目开发中踩过的坑，或者没有了解过的东西-持续更新\" class=\"headerlink\" title=\"主要用于记录在 Vue 项目开发中踩过的坑，或者没有了解过的东西(持续更新)\"></a>主要用于记录在 Vue 项目开发中踩过的坑，或者没有了解过的东西(持续更新)</h3><p>前端学无止境 ヾ(ﾟ ∀ ﾟゞ)<br>秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)</p>\n<span id=\"more\"></span>\n\n<h3 id=\"v-if-和-v-show-要学会区分开使用\"><a href=\"#v-if-和-v-show-要学会区分开使用\" class=\"headerlink\" title=\"v-if 和 v-show 要学会区分开使用\"></a>v-if 和 v-show 要学会区分开使用</h3><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ol>\n<li>手段：v-if 是通过控制 dom 节点的存在与否来控制元素的显隐;v-show 是通过设置 DOM 元素的 display 样式，block 为显示，none 为隐藏;</li>\n<li>编译过程：v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件;v-show 只是简单的基于 css 切换;</li>\n<li>编译条件：v-if 是惰性的，如果初始条件为假，则什么也不做;只有在条件第一次变为真时才开始局部编译（编译被缓存?编译被缓存后，然后再切换的时候进行局部卸载); v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留;</li>\n<li>性能消耗：v-if 有更高的切换消耗;v-show 有更高的初始渲染消耗;</li>\n</ol>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好;如果在运行时条件很少改变，则使用 v-if 较好。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>v-if 判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show 调整 DOM 元素的 CSS 的 dispaly 属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>\n<h3 id=\"页面内监听-scroll-事件的方法\"><a href=\"#页面内监听-scroll-事件的方法\" class=\"headerlink\" title=\"页面内监听 scroll 事件的方法\"></a>页面内监听 scroll 事件的方法</h3><p>如果是整个网页可以滑动，可以使用以下事件监听</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;scrolling&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p>但是大部分的场景是在一个元素内发生页面滚动</p>\n<p>举例：在页面内的一个div需要监听的</p>\n<ul>\n<li>滑动的组件外层的div加 ref=”viewBox” 为了通过$refs获取dom元素</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--设备列表--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;deviceWrapper&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;viewBox&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">mu-refresh-control</span> <span class=\"attr\">:refreshing</span>=<span class=\"string\">&quot;refreshing&quot;</span> <span class=\"attr\">:trigger</span>=<span class=\"string\">&quot;trigger&quot;</span> @<span class=\"attr\">refresh</span>=<span class=\"string\">&quot;refresh&quot;</span>/&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;demo-grid&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!--设备列表 手机一行两列 pad一行4列--&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">mu-row</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mu-col</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;device in devicesList&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;50&quot;</span> <span class=\"attr\">tablet</span>=<span class=\"string\">&quot;25&quot;</span> <span class=\"attr\">desktop</span>=<span class=\"string\">&quot;25&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">deviceCardView</span> <span class=\"attr\">:device-data</span>=<span class=\"string\">&quot;device&quot;</span>&quot;&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">devicelightCardView</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mu-col</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">mu-row</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bottomLine&quot;</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;&#123;bottomLineVisible:isScroll&#125;&quot;</span>&gt;</span>---------------------我是有底线的---------------------<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>获取元素，监听事件</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">mounted</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 通过$refs获取dom元素</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.box = <span class=\"built_in\">this</span>.$refs.viewBox</span><br><span class=\"line\"> <span class=\"comment\">// 监听这个dom的scroll事件</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.box.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot; scroll &quot;</span> + <span class=\"built_in\">this</span>.$refs.viewBox.scrollTop)</span><br><span class=\"line\"> <span class=\"comment\">//以下是我自己的需求，向下滚动的时候显示“我是有底线的（类似支付宝）”</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.isScroll=<span class=\"built_in\">this</span>.$refs.viewBox.scrollTop&gt;<span class=\"number\">0</span></span><br><span class=\"line\"> &#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这样能正常打印出来.scrollTop</p>\n<h3 id=\"封装一个组件，用于段落文字点击展开和收起功能\"><a href=\"#封装一个组件，用于段落文字点击展开和收起功能\" class=\"headerlink\" title=\"封装一个组件，用于段落文字点击展开和收起功能\"></a>封装一个组件，用于段落文字点击展开和收起功能</h3><h3 id=\"组件调用方法\"><a href=\"#组件调用方法\" class=\"headerlink\" title=\"组件调用方法\"></a>组件调用方法</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Unfold</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">data</span>=<span class=\"string\">&quot;这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">maxLength</span>=<span class=\"string\">&quot;100&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>属性说明</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```maxLen```：最大长度，超过这个数，被截取，默认 80，不改长度无需传值</span><br><span class=\"line\"></span><br><span class=\"line\">### 封装好组件的完整代码</span><br><span class=\"line\"></span><br><span class=\"line\">需要此功能的地方直接调用这个组件</span><br><span class=\"line\"></span><br><span class=\"line\">```html</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;span&gt;</span><br><span class=\"line\">    &lt;span v-if=&quot;data.length &lt; maxLen&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;tj&quot;&gt;&#123;&#123; data &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">    &lt;span v-else&gt;</span><br><span class=\"line\">      &lt;span class=&quot;tj&quot;</span><br><span class=\"line\">        &gt;&#123;&#123; showBtn ? sliceStr : data &#125;&#125;</span><br><span class=\"line\">        &lt;span class=&quot;btnWord&quot; @click=&quot;showBtn = !showBtn&quot;&gt;&#123;&#123;</span><br><span class=\"line\">          showBtn ? &quot;全文&quot; : &quot;收起&quot;</span><br><span class=\"line\">        &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">  &lt;/span&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;unfold&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      showBtn: true,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    // 数据</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &quot;&quot;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 最大长度</span><br><span class=\"line\">    maxLen: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 80,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    sliceStr() &#123;</span><br><span class=\"line\">      if (this.data != null) &#123;</span><br><span class=\"line\">        return this.data.substring(0, this.maxLen) + &quot;...&quot;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return &quot;&quot;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class=\"line\">.tj &#123;</span><br><span class=\"line\">  text-align: justify;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.btnWord &#123;</span><br><span class=\"line\">  color: cornflowerblue;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">  word-break: keep-all;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"主要用于记录在-Vue-项目开发中踩过的坑，或者没有了解过的东西-持续更新\"><a href=\"#主要用于记录在-Vue-项目开发中踩过的坑，或者没有了解过的东西-持续更新\" class=\"headerlink\" title=\"主要用于记录在 Vue 项目开发中踩过的坑，或者没有了解过的东西(持续更新)\"></a>主要用于记录在 Vue 项目开发中踩过的坑，或者没有了解过的东西(持续更新)</h3><p>前端学无止境 ヾ(ﾟ ∀ ﾟゞ)<br>秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)</p>","more":"<h3 id=\"v-if-和-v-show-要学会区分开使用\"><a href=\"#v-if-和-v-show-要学会区分开使用\" class=\"headerlink\" title=\"v-if 和 v-show 要学会区分开使用\"></a>v-if 和 v-show 要学会区分开使用</h3><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ol>\n<li>手段：v-if 是通过控制 dom 节点的存在与否来控制元素的显隐;v-show 是通过设置 DOM 元素的 display 样式，block 为显示，none 为隐藏;</li>\n<li>编译过程：v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件;v-show 只是简单的基于 css 切换;</li>\n<li>编译条件：v-if 是惰性的，如果初始条件为假，则什么也不做;只有在条件第一次变为真时才开始局部编译（编译被缓存?编译被缓存后，然后再切换的时候进行局部卸载); v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留;</li>\n<li>性能消耗：v-if 有更高的切换消耗;v-show 有更高的初始渲染消耗;</li>\n</ol>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好;如果在运行时条件很少改变，则使用 v-if 较好。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>v-if 判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show 调整 DOM 元素的 CSS 的 dispaly 属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>\n<h3 id=\"页面内监听-scroll-事件的方法\"><a href=\"#页面内监听-scroll-事件的方法\" class=\"headerlink\" title=\"页面内监听 scroll 事件的方法\"></a>页面内监听 scroll 事件的方法</h3><p>如果是整个网页可以滑动，可以使用以下事件监听</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;scrolling&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>但是大部分的场景是在一个元素内发生页面滚动</p>\n<p>举例：在页面内的一个div需要监听的</p>\n<ul>\n<li>滑动的组件外层的div加 ref=”viewBox” 为了通过$refs获取dom元素</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--设备列表--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;deviceWrapper&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;viewBox&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">mu-refresh-control</span> <span class=\"attr\">:refreshing</span>=<span class=\"string\">&quot;refreshing&quot;</span> <span class=\"attr\">:trigger</span>=<span class=\"string\">&quot;trigger&quot;</span> @<span class=\"attr\">refresh</span>=<span class=\"string\">&quot;refresh&quot;</span>/&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;demo-grid&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!--设备列表 手机一行两列 pad一行4列--&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">mu-row</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mu-col</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;device in devicesList&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;50&quot;</span> <span class=\"attr\">tablet</span>=<span class=\"string\">&quot;25&quot;</span> <span class=\"attr\">desktop</span>=<span class=\"string\">&quot;25&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">deviceCardView</span> <span class=\"attr\">:device-data</span>=<span class=\"string\">&quot;device&quot;</span>&quot;&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">devicelightCardView</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mu-col</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">mu-row</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bottomLine&quot;</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;&#123;bottomLineVisible:isScroll&#125;&quot;</span>&gt;</span>---------------------我是有底线的---------------------<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获取元素，监听事件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">mounted</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 通过$refs获取dom元素</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.box = <span class=\"built_in\">this</span>.$refs.viewBox</span><br><span class=\"line\"> <span class=\"comment\">// 监听这个dom的scroll事件</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.box.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot; scroll &quot;</span> + <span class=\"built_in\">this</span>.$refs.viewBox.scrollTop)</span><br><span class=\"line\"> <span class=\"comment\">//以下是我自己的需求，向下滚动的时候显示“我是有底线的（类似支付宝）”</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.isScroll=<span class=\"built_in\">this</span>.$refs.viewBox.scrollTop&gt;<span class=\"number\">0</span></span><br><span class=\"line\"> &#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样能正常打印出来.scrollTop</p>\n<h3 id=\"封装一个组件，用于段落文字点击展开和收起功能\"><a href=\"#封装一个组件，用于段落文字点击展开和收起功能\" class=\"headerlink\" title=\"封装一个组件，用于段落文字点击展开和收起功能\"></a>封装一个组件，用于段落文字点击展开和收起功能</h3><h3 id=\"组件调用方法\"><a href=\"#组件调用方法\" class=\"headerlink\" title=\"组件调用方法\"></a>组件调用方法</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Unfold</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">data</span>=<span class=\"string\">&quot;这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">maxLength</span>=<span class=\"string\">&quot;100&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性说明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```maxLen```：最大长度，超过这个数，被截取，默认 80，不改长度无需传值</span><br><span class=\"line\"></span><br><span class=\"line\">### 封装好组件的完整代码</span><br><span class=\"line\"></span><br><span class=\"line\">需要此功能的地方直接调用这个组件</span><br><span class=\"line\"></span><br><span class=\"line\">```html</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;span&gt;</span><br><span class=\"line\">    &lt;span v-if=&quot;data.length &lt; maxLen&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;tj&quot;&gt;&#123;&#123; data &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">    &lt;span v-else&gt;</span><br><span class=\"line\">      &lt;span class=&quot;tj&quot;</span><br><span class=\"line\">        &gt;&#123;&#123; showBtn ? sliceStr : data &#125;&#125;</span><br><span class=\"line\">        &lt;span class=&quot;btnWord&quot; @click=&quot;showBtn = !showBtn&quot;&gt;&#123;&#123;</span><br><span class=\"line\">          showBtn ? &quot;全文&quot; : &quot;收起&quot;</span><br><span class=\"line\">        &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">  &lt;/span&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;unfold&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      showBtn: true,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    // 数据</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &quot;&quot;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 最大长度</span><br><span class=\"line\">    maxLen: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 80,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    sliceStr() &#123;</span><br><span class=\"line\">      if (this.data != null) &#123;</span><br><span class=\"line\">        return this.data.substring(0, this.maxLen) + &quot;...&quot;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return &quot;&quot;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class=\"line\">.tj &#123;</span><br><span class=\"line\">  text-align: justify;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.btnWord &#123;</span><br><span class=\"line\">  color: cornflowerblue;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">  word-break: keep-all;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"事件Event","date":"2019-12-10T16:00:00.000Z","_content":"\n### 事件基础\n\nJavaScript 事件是由访问 Web 页面的用户引起的一系列操作。\n当用户执行某些操作的时候，再去执行一系列代码。或者用来获取事件详细信息，如鼠标位置、键盘按键等。\n\n### 事件处理函数\n\njavaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件\n所有的事件处理函数都会都有两个部分组成，on + 事件名称\n\n<!--more--> \n\n### 鼠标事件\n#\nonclick:用户单击鼠标按钮\nondblclick:当用户双击主鼠标按钮时触发\nonmousedown:当用户按下鼠标还未弹起时触发\nonmouseup：当用户释放鼠标按钮时触发\nonmouseover：当鼠标移到某个元素上方时触发\nonmouseout：当鼠标移出某个元素上方时触发\nonmousemove：当鼠标指针在元素上移动时触发\n\n### HTML 事件\n\nonload：当页面或者资源完全加载后在 window 上面触发\nonselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发\nonchange：当文本框(input 或 textarea)内容改变且失去焦点后触发\nonfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发\nonblur：当页面或元素失去焦点时在 window 及相关元素上触发\nonresize：当窗口或框架的大小变化时在 window 或框架上触发\nonscroll：当用户滚动带滚动条的元素时触发\n\n### 事件对象\n\n当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。\n\n通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。\n\nEvent 对象获取方式 （兼容性）\n\n```js\nel.onclick = function (evt) {\n  let e = evt || window.event;\n};\n```\n\nevent.button 属性\n当前事件触发时哪个鼠标按键被点击\nclientX、clientY 属性\n鼠标在可视区 X 坐标和 Y 坐标，即距离左边框和上边框的距离\nscreenX、screenY 属性\n鼠标在屏幕区 X 坐标和 Y 坐标，即距离左屏幕和上屏幕的距离\noffsetX、offsetY 属性\n鼠标相对于事件源的 X 坐标和 Y 坐标\npageX、pageY\n鼠标相对于文档的 X 坐标和 Y 坐标\n\n### 键盘事件\n\nonkeydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发\nonkeypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发\nonkeyup：当用户释放键盘上的键触发\n组合键 ctrkey、altkey、shiftkey\naltKey 属性，bool 类型，表示发生事件的时候 alt 键是否被按下\nctrlKey 属性，bool 类型，表示发生事件的时候 ctrl 键是否被按下\nshiftKey 属性，bool 类型，表示发生事件的时候 shift 键是否被按下  \nkeyCode/which 兼容\n事件源（事件在哪个元素上产生）\n\n### 冒泡\n\n1. 事件的冒泡\n   事件按照从最特定的事件目标到最不特定的事件目标(document 对象)的顺序触发。\n2. 阻止事件冒泡\n\n```js\n//阻止事件冒泡\ne.stopPropagation();\n//低版本ie\ne.cancelBubble = true;\n```\n\n### 事件默认行为及阻止方式\n\n1. 浏览器的默认行为\n   JavaScript 事件本身所具有的属性，例如 a 标签的跳转，Submit 按钮的提交，右键菜单，文本框的输入等。\n2. 阻止默认行为的方式\n   w3c 的方法是e.preventDefault()，\n\nIE 则是使用\ne.returnValue = false;\n\nreturn false;\n\n自定义右键菜单 oncontextmenu\n\n### DOM2 级事件处理程序\n\n添加事件监听器：ele.addEventListener(事件名,处理函数,布尔值)\n现代浏览器（IE9、10、11 | ff, chorme, safari, opera）\n注意：事件名不带 on，处理函数为函数引用，布尔值代表冒泡(内到外)或捕获（外到内）\n\n```js\nelement.addEventListener(\"click\", function () {}, false); //false 事件冒泡\nelement.addEventListener(\"click\", function () {}, true); //true事件捕获\n```\n\n移除事件监听器：```removeEventListener(事件名,处理函数)```\n\nIE8 及以下的事件监听器：```attachEvent(事件名,处理函数)，detachEvent(事件名,处理函数)```\n注意：事件名带 on\n\n### 事件委托\n\n利用事件冒泡的原理，把本应添加给某元素上的事件委托给他的父级（外层）。\n\n使用案例\n如果一个 ul 中有很多 li，循环遍历所有的 li，给 li 添加事件效率比较低，我们可以监听 ul 的点击事件，利用子元素的点击事件都会冒泡到父元素的特点，就可以知道什么时候点击了 li。\n\n好处：效率高，可以给未来元素添加事件\n\n### 事件对象中的拖拽效果\n\n拖拽原理\n三个事件：onmousedown、onmousemove、onmouseup\n\n实现思路：\n\n1. 给目标元素添加 onmousedown 事件，拖拽的前提是在目标元素按下鼠标左键。\n2. 当 onmousedown 发生以后，此刻给 document 添加 onmousemove 事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置。\n3. 在 onmousemove 事件中，设定目标元素的 left 和 top，\n   公式：\n   目标元素的 left = 鼠标的 clientX - (鼠标和元素的横坐标差，即 offsetX)\n   目标元素的 top = 鼠标的 clientY - (鼠标和元素的纵坐标差，即 offsetY)\n4. 当 onmousedown 发生以后，此刻给 document 添加 onmouseup 事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果。\n5. 在 onmouseup 事件中，取消 document 的 onmousemove 事件即可。\n\n--- \n\n本文作者： 一只野生东子","source":"_posts/事件Event.md","raw":"---\ntitle: 事件Event\ndate: 2019-12-11\ntags: javaScript\n---\n\n### 事件基础\n\nJavaScript 事件是由访问 Web 页面的用户引起的一系列操作。\n当用户执行某些操作的时候，再去执行一系列代码。或者用来获取事件详细信息，如鼠标位置、键盘按键等。\n\n### 事件处理函数\n\njavaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件\n所有的事件处理函数都会都有两个部分组成，on + 事件名称\n\n<!--more--> \n\n### 鼠标事件\n#\nonclick:用户单击鼠标按钮\nondblclick:当用户双击主鼠标按钮时触发\nonmousedown:当用户按下鼠标还未弹起时触发\nonmouseup：当用户释放鼠标按钮时触发\nonmouseover：当鼠标移到某个元素上方时触发\nonmouseout：当鼠标移出某个元素上方时触发\nonmousemove：当鼠标指针在元素上移动时触发\n\n### HTML 事件\n\nonload：当页面或者资源完全加载后在 window 上面触发\nonselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发\nonchange：当文本框(input 或 textarea)内容改变且失去焦点后触发\nonfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发\nonblur：当页面或元素失去焦点时在 window 及相关元素上触发\nonresize：当窗口或框架的大小变化时在 window 或框架上触发\nonscroll：当用户滚动带滚动条的元素时触发\n\n### 事件对象\n\n当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。\n\n通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。\n\nEvent 对象获取方式 （兼容性）\n\n```js\nel.onclick = function (evt) {\n  let e = evt || window.event;\n};\n```\n\nevent.button 属性\n当前事件触发时哪个鼠标按键被点击\nclientX、clientY 属性\n鼠标在可视区 X 坐标和 Y 坐标，即距离左边框和上边框的距离\nscreenX、screenY 属性\n鼠标在屏幕区 X 坐标和 Y 坐标，即距离左屏幕和上屏幕的距离\noffsetX、offsetY 属性\n鼠标相对于事件源的 X 坐标和 Y 坐标\npageX、pageY\n鼠标相对于文档的 X 坐标和 Y 坐标\n\n### 键盘事件\n\nonkeydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发\nonkeypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发\nonkeyup：当用户释放键盘上的键触发\n组合键 ctrkey、altkey、shiftkey\naltKey 属性，bool 类型，表示发生事件的时候 alt 键是否被按下\nctrlKey 属性，bool 类型，表示发生事件的时候 ctrl 键是否被按下\nshiftKey 属性，bool 类型，表示发生事件的时候 shift 键是否被按下  \nkeyCode/which 兼容\n事件源（事件在哪个元素上产生）\n\n### 冒泡\n\n1. 事件的冒泡\n   事件按照从最特定的事件目标到最不特定的事件目标(document 对象)的顺序触发。\n2. 阻止事件冒泡\n\n```js\n//阻止事件冒泡\ne.stopPropagation();\n//低版本ie\ne.cancelBubble = true;\n```\n\n### 事件默认行为及阻止方式\n\n1. 浏览器的默认行为\n   JavaScript 事件本身所具有的属性，例如 a 标签的跳转，Submit 按钮的提交，右键菜单，文本框的输入等。\n2. 阻止默认行为的方式\n   w3c 的方法是e.preventDefault()，\n\nIE 则是使用\ne.returnValue = false;\n\nreturn false;\n\n自定义右键菜单 oncontextmenu\n\n### DOM2 级事件处理程序\n\n添加事件监听器：ele.addEventListener(事件名,处理函数,布尔值)\n现代浏览器（IE9、10、11 | ff, chorme, safari, opera）\n注意：事件名不带 on，处理函数为函数引用，布尔值代表冒泡(内到外)或捕获（外到内）\n\n```js\nelement.addEventListener(\"click\", function () {}, false); //false 事件冒泡\nelement.addEventListener(\"click\", function () {}, true); //true事件捕获\n```\n\n移除事件监听器：```removeEventListener(事件名,处理函数)```\n\nIE8 及以下的事件监听器：```attachEvent(事件名,处理函数)，detachEvent(事件名,处理函数)```\n注意：事件名带 on\n\n### 事件委托\n\n利用事件冒泡的原理，把本应添加给某元素上的事件委托给他的父级（外层）。\n\n使用案例\n如果一个 ul 中有很多 li，循环遍历所有的 li，给 li 添加事件效率比较低，我们可以监听 ul 的点击事件，利用子元素的点击事件都会冒泡到父元素的特点，就可以知道什么时候点击了 li。\n\n好处：效率高，可以给未来元素添加事件\n\n### 事件对象中的拖拽效果\n\n拖拽原理\n三个事件：onmousedown、onmousemove、onmouseup\n\n实现思路：\n\n1. 给目标元素添加 onmousedown 事件，拖拽的前提是在目标元素按下鼠标左键。\n2. 当 onmousedown 发生以后，此刻给 document 添加 onmousemove 事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置。\n3. 在 onmousemove 事件中，设定目标元素的 left 和 top，\n   公式：\n   目标元素的 left = 鼠标的 clientX - (鼠标和元素的横坐标差，即 offsetX)\n   目标元素的 top = 鼠标的 clientY - (鼠标和元素的纵坐标差，即 offsetY)\n4. 当 onmousedown 发生以后，此刻给 document 添加 onmouseup 事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果。\n5. 在 onmouseup 事件中，取消 document 的 onmousemove 事件即可。\n\n--- \n\n本文作者： 一只野生东子","slug":"事件Event","published":1,"updated":"2021-11-26T07:17:26.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2f000d9co36lzifoic","content":"<h3 id=\"事件基础\"><a href=\"#事件基础\" class=\"headerlink\" title=\"事件基础\"></a>事件基础</h3><p>JavaScript 事件是由访问 Web 页面的用户引起的一系列操作。<br>当用户执行某些操作的时候，再去执行一系列代码。或者用来获取事件详细信息，如鼠标位置、键盘按键等。</p>\n<h3 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h3><p>javaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件<br>所有的事件处理函数都会都有两个部分组成，on + 事件名称</p>\n<span id=\"more\"></span> \n\n<h3 id=\"鼠标事件\"><a href=\"#鼠标事件\" class=\"headerlink\" title=\"鼠标事件\"></a>鼠标事件</h3><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>onclick:用户单击鼠标按钮<br>ondblclick:当用户双击主鼠标按钮时触发<br>onmousedown:当用户按下鼠标还未弹起时触发<br>onmouseup：当用户释放鼠标按钮时触发<br>onmouseover：当鼠标移到某个元素上方时触发<br>onmouseout：当鼠标移出某个元素上方时触发<br>onmousemove：当鼠标指针在元素上移动时触发</p>\n<h3 id=\"HTML-事件\"><a href=\"#HTML-事件\" class=\"headerlink\" title=\"HTML 事件\"></a>HTML 事件</h3><p>onload：当页面或者资源完全加载后在 window 上面触发<br>onselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发<br>onchange：当文本框(input 或 textarea)内容改变且失去焦点后触发<br>onfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发<br>onblur：当页面或元素失去焦点时在 window 及相关元素上触发<br>onresize：当窗口或框架的大小变化时在 window 或框架上触发<br>onscroll：当用户滚动带滚动条的元素时触发</p>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><p>当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。</p>\n<p>通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。</p>\n<p>Event 对象获取方式 （兼容性）</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">el.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> e = evt || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>event.button 属性<br>当前事件触发时哪个鼠标按键被点击<br>clientX、clientY 属性<br>鼠标在可视区 X 坐标和 Y 坐标，即距离左边框和上边框的距离<br>screenX、screenY 属性<br>鼠标在屏幕区 X 坐标和 Y 坐标，即距离左屏幕和上屏幕的距离<br>offsetX、offsetY 属性<br>鼠标相对于事件源的 X 坐标和 Y 坐标<br>pageX、pageY<br>鼠标相对于文档的 X 坐标和 Y 坐标</p>\n<h3 id=\"键盘事件\"><a href=\"#键盘事件\" class=\"headerlink\" title=\"键盘事件\"></a>键盘事件</h3><p>onkeydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发<br>onkeypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发<br>onkeyup：当用户释放键盘上的键触发<br>组合键 ctrkey、altkey、shiftkey<br>altKey 属性，bool 类型，表示发生事件的时候 alt 键是否被按下<br>ctrlKey 属性，bool 类型，表示发生事件的时候 ctrl 键是否被按下<br>shiftKey 属性，bool 类型，表示发生事件的时候 shift 键是否被按下<br>keyCode/which 兼容<br>事件源（事件在哪个元素上产生）</p>\n<h3 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h3><ol>\n<li>事件的冒泡<br>事件按照从最特定的事件目标到最不特定的事件目标(document 对象)的顺序触发。</li>\n<li>阻止事件冒泡</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阻止事件冒泡</span></span><br><span class=\"line\">e.stopPropagation();</span><br><span class=\"line\"><span class=\"comment\">//低版本ie</span></span><br><span class=\"line\">e.cancelBubble = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"事件默认行为及阻止方式\"><a href=\"#事件默认行为及阻止方式\" class=\"headerlink\" title=\"事件默认行为及阻止方式\"></a>事件默认行为及阻止方式</h3><ol>\n<li>浏览器的默认行为<br>JavaScript 事件本身所具有的属性，例如 a 标签的跳转，Submit 按钮的提交，右键菜单，文本框的输入等。</li>\n<li>阻止默认行为的方式<br>w3c 的方法是e.preventDefault()，</li>\n</ol>\n<p>IE 则是使用<br>e.returnValue = false;</p>\n<p>return false;</p>\n<p>自定义右键菜单 oncontextmenu</p>\n<h3 id=\"DOM2-级事件处理程序\"><a href=\"#DOM2-级事件处理程序\" class=\"headerlink\" title=\"DOM2 级事件处理程序\"></a>DOM2 级事件处理程序</h3><p>添加事件监听器：ele.addEventListener(事件名,处理函数,布尔值)<br>现代浏览器（IE9、10、11 | ff, chorme, safari, opera）<br>注意：事件名不带 on，处理函数为函数引用，布尔值代表冒泡(内到外)或捕获（外到内）</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;, <span class=\"literal\">false</span>); <span class=\"comment\">//false 事件冒泡</span></span><br><span class=\"line\">element.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;, <span class=\"literal\">true</span>); <span class=\"comment\">//true事件捕获</span></span><br></pre></td></tr></table></figure></div>\n\n<p>移除事件监听器：<code>removeEventListener(事件名,处理函数)</code></p>\n<p>IE8 及以下的事件监听器：<code>attachEvent(事件名,处理函数)，detachEvent(事件名,处理函数)</code><br>注意：事件名带 on</p>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><p>利用事件冒泡的原理，把本应添加给某元素上的事件委托给他的父级（外层）。</p>\n<p>使用案例<br>如果一个 ul 中有很多 li，循环遍历所有的 li，给 li 添加事件效率比较低，我们可以监听 ul 的点击事件，利用子元素的点击事件都会冒泡到父元素的特点，就可以知道什么时候点击了 li。</p>\n<p>好处：效率高，可以给未来元素添加事件</p>\n<h3 id=\"事件对象中的拖拽效果\"><a href=\"#事件对象中的拖拽效果\" class=\"headerlink\" title=\"事件对象中的拖拽效果\"></a>事件对象中的拖拽效果</h3><p>拖拽原理<br>三个事件：onmousedown、onmousemove、onmouseup</p>\n<p>实现思路：</p>\n<ol>\n<li>给目标元素添加 onmousedown 事件，拖拽的前提是在目标元素按下鼠标左键。</li>\n<li>当 onmousedown 发生以后，此刻给 document 添加 onmousemove 事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置。</li>\n<li>在 onmousemove 事件中，设定目标元素的 left 和 top，<br>公式：<br>目标元素的 left = 鼠标的 clientX - (鼠标和元素的横坐标差，即 offsetX)<br>目标元素的 top = 鼠标的 clientY - (鼠标和元素的纵坐标差，即 offsetY)</li>\n<li>当 onmousedown 发生以后，此刻给 document 添加 onmouseup 事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果。</li>\n<li>在 onmouseup 事件中，取消 document 的 onmousemove 事件即可。</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"事件基础\"><a href=\"#事件基础\" class=\"headerlink\" title=\"事件基础\"></a>事件基础</h3><p>JavaScript 事件是由访问 Web 页面的用户引起的一系列操作。<br>当用户执行某些操作的时候，再去执行一系列代码。或者用来获取事件详细信息，如鼠标位置、键盘按键等。</p>\n<h3 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h3><p>javaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件<br>所有的事件处理函数都会都有两个部分组成，on + 事件名称</p>","more":"<h3 id=\"鼠标事件\"><a href=\"#鼠标事件\" class=\"headerlink\" title=\"鼠标事件\"></a>鼠标事件</h3><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>onclick:用户单击鼠标按钮<br>ondblclick:当用户双击主鼠标按钮时触发<br>onmousedown:当用户按下鼠标还未弹起时触发<br>onmouseup：当用户释放鼠标按钮时触发<br>onmouseover：当鼠标移到某个元素上方时触发<br>onmouseout：当鼠标移出某个元素上方时触发<br>onmousemove：当鼠标指针在元素上移动时触发</p>\n<h3 id=\"HTML-事件\"><a href=\"#HTML-事件\" class=\"headerlink\" title=\"HTML 事件\"></a>HTML 事件</h3><p>onload：当页面或者资源完全加载后在 window 上面触发<br>onselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发<br>onchange：当文本框(input 或 textarea)内容改变且失去焦点后触发<br>onfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发<br>onblur：当页面或元素失去焦点时在 window 及相关元素上触发<br>onresize：当窗口或框架的大小变化时在 window 或框架上触发<br>onscroll：当用户滚动带滚动条的元素时触发</p>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><p>当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。</p>\n<p>通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。</p>\n<p>Event 对象获取方式 （兼容性）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">el.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> e = evt || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>event.button 属性<br>当前事件触发时哪个鼠标按键被点击<br>clientX、clientY 属性<br>鼠标在可视区 X 坐标和 Y 坐标，即距离左边框和上边框的距离<br>screenX、screenY 属性<br>鼠标在屏幕区 X 坐标和 Y 坐标，即距离左屏幕和上屏幕的距离<br>offsetX、offsetY 属性<br>鼠标相对于事件源的 X 坐标和 Y 坐标<br>pageX、pageY<br>鼠标相对于文档的 X 坐标和 Y 坐标</p>\n<h3 id=\"键盘事件\"><a href=\"#键盘事件\" class=\"headerlink\" title=\"键盘事件\"></a>键盘事件</h3><p>onkeydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发<br>onkeypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发<br>onkeyup：当用户释放键盘上的键触发<br>组合键 ctrkey、altkey、shiftkey<br>altKey 属性，bool 类型，表示发生事件的时候 alt 键是否被按下<br>ctrlKey 属性，bool 类型，表示发生事件的时候 ctrl 键是否被按下<br>shiftKey 属性，bool 类型，表示发生事件的时候 shift 键是否被按下<br>keyCode/which 兼容<br>事件源（事件在哪个元素上产生）</p>\n<h3 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h3><ol>\n<li>事件的冒泡<br>事件按照从最特定的事件目标到最不特定的事件目标(document 对象)的顺序触发。</li>\n<li>阻止事件冒泡</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阻止事件冒泡</span></span><br><span class=\"line\">e.stopPropagation();</span><br><span class=\"line\"><span class=\"comment\">//低版本ie</span></span><br><span class=\"line\">e.cancelBubble = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事件默认行为及阻止方式\"><a href=\"#事件默认行为及阻止方式\" class=\"headerlink\" title=\"事件默认行为及阻止方式\"></a>事件默认行为及阻止方式</h3><ol>\n<li>浏览器的默认行为<br>JavaScript 事件本身所具有的属性，例如 a 标签的跳转，Submit 按钮的提交，右键菜单，文本框的输入等。</li>\n<li>阻止默认行为的方式<br>w3c 的方法是e.preventDefault()，</li>\n</ol>\n<p>IE 则是使用<br>e.returnValue = false;</p>\n<p>return false;</p>\n<p>自定义右键菜单 oncontextmenu</p>\n<h3 id=\"DOM2-级事件处理程序\"><a href=\"#DOM2-级事件处理程序\" class=\"headerlink\" title=\"DOM2 级事件处理程序\"></a>DOM2 级事件处理程序</h3><p>添加事件监听器：ele.addEventListener(事件名,处理函数,布尔值)<br>现代浏览器（IE9、10、11 | ff, chorme, safari, opera）<br>注意：事件名不带 on，处理函数为函数引用，布尔值代表冒泡(内到外)或捕获（外到内）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;, <span class=\"literal\">false</span>); <span class=\"comment\">//false 事件冒泡</span></span><br><span class=\"line\">element.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;, <span class=\"literal\">true</span>); <span class=\"comment\">//true事件捕获</span></span><br></pre></td></tr></table></figure>\n\n<p>移除事件监听器：<code>removeEventListener(事件名,处理函数)</code></p>\n<p>IE8 及以下的事件监听器：<code>attachEvent(事件名,处理函数)，detachEvent(事件名,处理函数)</code><br>注意：事件名带 on</p>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><p>利用事件冒泡的原理，把本应添加给某元素上的事件委托给他的父级（外层）。</p>\n<p>使用案例<br>如果一个 ul 中有很多 li，循环遍历所有的 li，给 li 添加事件效率比较低，我们可以监听 ul 的点击事件，利用子元素的点击事件都会冒泡到父元素的特点，就可以知道什么时候点击了 li。</p>\n<p>好处：效率高，可以给未来元素添加事件</p>\n<h3 id=\"事件对象中的拖拽效果\"><a href=\"#事件对象中的拖拽效果\" class=\"headerlink\" title=\"事件对象中的拖拽效果\"></a>事件对象中的拖拽效果</h3><p>拖拽原理<br>三个事件：onmousedown、onmousemove、onmouseup</p>\n<p>实现思路：</p>\n<ol>\n<li>给目标元素添加 onmousedown 事件，拖拽的前提是在目标元素按下鼠标左键。</li>\n<li>当 onmousedown 发生以后，此刻给 document 添加 onmousemove 事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置。</li>\n<li>在 onmousemove 事件中，设定目标元素的 left 和 top，<br>公式：<br>目标元素的 left = 鼠标的 clientX - (鼠标和元素的横坐标差，即 offsetX)<br>目标元素的 top = 鼠标的 clientY - (鼠标和元素的纵坐标差，即 offsetY)</li>\n<li>当 onmousedown 发生以后，此刻给 document 添加 onmouseup 事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果。</li>\n<li>在 onmouseup 事件中，取消 document 的 onmousemove 事件即可。</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"元素类型","date":"2019-10-21T07:04:35.000Z","_content":"\n### 块元素\n\n1. 块状元素在网页中就是以块的形式显示，所谓块状就是元素显示为矩形区域\n   常用的块状元素包块 div,dl,dt,dd,ol,ul,fieldset,(h1-h6),p,form,hr,colgroup,col,table,tr,td,等;\n2. 块元素的特点： \n   1)默认情况下，块状元素都会独占一行，块状元素会按顺序自上而下排列。 \n   2)块状元素都可以直接定义自己的宽度和高度。  \n   3)块状元素遵循盒模型的所有规则，一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。（p 标签除外）\n<!--more--> \n\n### 内联元素(inline) 或是行内元素\n\n1. 常见的内联元素如：a,span,i,em,strong,b 等\n2. 内联元素的特点： \n   1)内联元素其后如果是内联元素则会在一行内逐个进行显示； \n   2)内联元素显示的宽度、高度只能根据所包含内容的高度和宽度来确定，不能直接定义它的宽和高，它的最小内容单元也会呈现矩形形状； \n   3)内联元素也会遵循盒模型基本规则，但个别属性不能正确显示;（上下间距显示不正确，左右正常显示）\n\n### 可变元素\n\n   需要根据上下文关系确定该元素是块元素或者内联元素。\n\n### 元素类型转换\n\n1. display 的作用：设置或检索元素的类型。\n   属性值 19 个：block/inline/inline-block/none/list-item/table-header-group/table-footer-group….\n2. 属性值中有 5 个最常用的属性值\n   1)Block\n   块元素的 display 默认属性值，当给元素加 display：block 后元素变为块元素\n   （注：当元素设置了 float 属性后，就相当于给该元素加了 display:block;属性；）\n   2)inline\n   内联元素的 display 默认属性值，当给元素加 display：inline 元素变为内联元素\n   3)inline-block\n   内联块元素默认属性值：行内的其他元素显示在同一行，但可以直接设置宽高，\n   如：img,input（注：只有这一个元素类型支持 vertical-align 属性）\n   4)none\n   元素被隐藏不显示\n   5)list-item\n   将元素转换成列表。li 的 display 默认属性值；\n\n### 总结\n\n1. 大部分块元素 display 属性值默认为 block，其中 li 默认值为 list-item。\n2. 大部分内联元素(行内元素、行间元素)的 display 属性值默认为 inline,其中 img,input，默认\n   为inline-block。\n\n### 扩展\n\n置换元素：\n一个内容 不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。HTML 中的 img、input、textarea、select、object 都是置换元素。这些元素往往没有实际的内容，即是一个空元素\n\n非置换元素：\nHTML 的大多数元素是不可替换元素，即其内容直接表现给用户端\n\n---\n本文作者： 一只野生东子","source":"_posts/元素类型.md","raw":"---\ntitle: 元素类型\ndate: 2019-10-21 15:04:35\ntags: css\n---\n\n### 块元素\n\n1. 块状元素在网页中就是以块的形式显示，所谓块状就是元素显示为矩形区域\n   常用的块状元素包块 div,dl,dt,dd,ol,ul,fieldset,(h1-h6),p,form,hr,colgroup,col,table,tr,td,等;\n2. 块元素的特点： \n   1)默认情况下，块状元素都会独占一行，块状元素会按顺序自上而下排列。 \n   2)块状元素都可以直接定义自己的宽度和高度。  \n   3)块状元素遵循盒模型的所有规则，一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。（p 标签除外）\n<!--more--> \n\n### 内联元素(inline) 或是行内元素\n\n1. 常见的内联元素如：a,span,i,em,strong,b 等\n2. 内联元素的特点： \n   1)内联元素其后如果是内联元素则会在一行内逐个进行显示； \n   2)内联元素显示的宽度、高度只能根据所包含内容的高度和宽度来确定，不能直接定义它的宽和高，它的最小内容单元也会呈现矩形形状； \n   3)内联元素也会遵循盒模型基本规则，但个别属性不能正确显示;（上下间距显示不正确，左右正常显示）\n\n### 可变元素\n\n   需要根据上下文关系确定该元素是块元素或者内联元素。\n\n### 元素类型转换\n\n1. display 的作用：设置或检索元素的类型。\n   属性值 19 个：block/inline/inline-block/none/list-item/table-header-group/table-footer-group….\n2. 属性值中有 5 个最常用的属性值\n   1)Block\n   块元素的 display 默认属性值，当给元素加 display：block 后元素变为块元素\n   （注：当元素设置了 float 属性后，就相当于给该元素加了 display:block;属性；）\n   2)inline\n   内联元素的 display 默认属性值，当给元素加 display：inline 元素变为内联元素\n   3)inline-block\n   内联块元素默认属性值：行内的其他元素显示在同一行，但可以直接设置宽高，\n   如：img,input（注：只有这一个元素类型支持 vertical-align 属性）\n   4)none\n   元素被隐藏不显示\n   5)list-item\n   将元素转换成列表。li 的 display 默认属性值；\n\n### 总结\n\n1. 大部分块元素 display 属性值默认为 block，其中 li 默认值为 list-item。\n2. 大部分内联元素(行内元素、行间元素)的 display 属性值默认为 inline,其中 img,input，默认\n   为inline-block。\n\n### 扩展\n\n置换元素：\n一个内容 不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。HTML 中的 img、input、textarea、select、object 都是置换元素。这些元素往往没有实际的内容，即是一个空元素\n\n非置换元素：\nHTML 的大多数元素是不可替换元素，即其内容直接表现给用户端\n\n---\n本文作者： 一只野生东子","slug":"元素类型","published":1,"updated":"2021-11-26T06:02:26.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2h000f9co34z5g7yu6","content":"<h3 id=\"块元素\"><a href=\"#块元素\" class=\"headerlink\" title=\"块元素\"></a>块元素</h3><ol>\n<li>块状元素在网页中就是以块的形式显示，所谓块状就是元素显示为矩形区域<br>常用的块状元素包块 div,dl,dt,dd,ol,ul,fieldset,(h1-h6),p,form,hr,colgroup,col,table,tr,td,等;</li>\n<li>块元素的特点：<br>1)默认情况下，块状元素都会独占一行，块状元素会按顺序自上而下排列。<br>2)块状元素都可以直接定义自己的宽度和高度。<br>3)块状元素遵循盒模型的所有规则，一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。（p 标签除外）<span id=\"more\"></span> </li>\n</ol>\n<h3 id=\"内联元素-inline-或是行内元素\"><a href=\"#内联元素-inline-或是行内元素\" class=\"headerlink\" title=\"内联元素(inline) 或是行内元素\"></a>内联元素(inline) 或是行内元素</h3><ol>\n<li>常见的内联元素如：a,span,i,em,strong,b 等</li>\n<li>内联元素的特点：<br>1)内联元素其后如果是内联元素则会在一行内逐个进行显示；<br>2)内联元素显示的宽度、高度只能根据所包含内容的高度和宽度来确定，不能直接定义它的宽和高，它的最小内容单元也会呈现矩形形状；<br>3)内联元素也会遵循盒模型基本规则，但个别属性不能正确显示;（上下间距显示不正确，左右正常显示）</li>\n</ol>\n<h3 id=\"可变元素\"><a href=\"#可变元素\" class=\"headerlink\" title=\"可变元素\"></a>可变元素</h3><p>   需要根据上下文关系确定该元素是块元素或者内联元素。</p>\n<h3 id=\"元素类型转换\"><a href=\"#元素类型转换\" class=\"headerlink\" title=\"元素类型转换\"></a>元素类型转换</h3><ol>\n<li>display 的作用：设置或检索元素的类型。<br>属性值 19 个：block/inline/inline-block/none/list-item/table-header-group/table-footer-group….</li>\n<li>属性值中有 5 个最常用的属性值<br>1)Block<br>块元素的 display 默认属性值，当给元素加 display：block 后元素变为块元素<br>（注：当元素设置了 float 属性后，就相当于给该元素加了 display:block;属性；）<br>2)inline<br>内联元素的 display 默认属性值，当给元素加 display：inline 元素变为内联元素<br>3)inline-block<br>内联块元素默认属性值：行内的其他元素显示在同一行，但可以直接设置宽高，<br>如：img,input（注：只有这一个元素类型支持 vertical-align 属性）<br>4)none<br>元素被隐藏不显示<br>5)list-item<br>将元素转换成列表。li 的 display 默认属性值；</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>大部分块元素 display 属性值默认为 block，其中 li 默认值为 list-item。</li>\n<li>大部分内联元素(行内元素、行间元素)的 display 属性值默认为 inline,其中 img,input，默认<br>为inline-block。</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>置换元素：<br>一个内容 不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。HTML 中的 img、input、textarea、select、object 都是置换元素。这些元素往往没有实际的内容，即是一个空元素</p>\n<p>非置换元素：<br>HTML 的大多数元素是不可替换元素，即其内容直接表现给用户端</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"块元素\"><a href=\"#块元素\" class=\"headerlink\" title=\"块元素\"></a>块元素</h3><ol>\n<li>块状元素在网页中就是以块的形式显示，所谓块状就是元素显示为矩形区域<br>常用的块状元素包块 div,dl,dt,dd,ol,ul,fieldset,(h1-h6),p,form,hr,colgroup,col,table,tr,td,等;</li>\n<li>块元素的特点：<br>1)默认情况下，块状元素都会独占一行，块状元素会按顺序自上而下排列。<br>2)块状元素都可以直接定义自己的宽度和高度。<br>3)块状元素遵循盒模型的所有规则，一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。（p 标签除外）","more":"</li>\n</ol>\n<h3 id=\"内联元素-inline-或是行内元素\"><a href=\"#内联元素-inline-或是行内元素\" class=\"headerlink\" title=\"内联元素(inline) 或是行内元素\"></a>内联元素(inline) 或是行内元素</h3><ol>\n<li>常见的内联元素如：a,span,i,em,strong,b 等</li>\n<li>内联元素的特点：<br>1)内联元素其后如果是内联元素则会在一行内逐个进行显示；<br>2)内联元素显示的宽度、高度只能根据所包含内容的高度和宽度来确定，不能直接定义它的宽和高，它的最小内容单元也会呈现矩形形状；<br>3)内联元素也会遵循盒模型基本规则，但个别属性不能正确显示;（上下间距显示不正确，左右正常显示）</li>\n</ol>\n<h3 id=\"可变元素\"><a href=\"#可变元素\" class=\"headerlink\" title=\"可变元素\"></a>可变元素</h3><p>   需要根据上下文关系确定该元素是块元素或者内联元素。</p>\n<h3 id=\"元素类型转换\"><a href=\"#元素类型转换\" class=\"headerlink\" title=\"元素类型转换\"></a>元素类型转换</h3><ol>\n<li>display 的作用：设置或检索元素的类型。<br>属性值 19 个：block/inline/inline-block/none/list-item/table-header-group/table-footer-group….</li>\n<li>属性值中有 5 个最常用的属性值<br>1)Block<br>块元素的 display 默认属性值，当给元素加 display：block 后元素变为块元素<br>（注：当元素设置了 float 属性后，就相当于给该元素加了 display:block;属性；）<br>2)inline<br>内联元素的 display 默认属性值，当给元素加 display：inline 元素变为内联元素<br>3)inline-block<br>内联块元素默认属性值：行内的其他元素显示在同一行，但可以直接设置宽高，<br>如：img,input（注：只有这一个元素类型支持 vertical-align 属性）<br>4)none<br>元素被隐藏不显示<br>5)list-item<br>将元素转换成列表。li 的 display 默认属性值；</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>大部分块元素 display 属性值默认为 block，其中 li 默认值为 list-item。</li>\n<li>大部分内联元素(行内元素、行间元素)的 display 属性值默认为 inline,其中 img,input，默认<br>为inline-block。</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>置换元素：<br>一个内容 不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。HTML 中的 img、input、textarea、select、object 都是置换元素。这些元素往往没有实际的内容，即是一个空元素</p>\n<p>非置换元素：<br>HTML 的大多数元素是不可替换元素，即其内容直接表现给用户端</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"关于ES5和字符串string","date":"2019-11-14T16:00:00.000Z","_content":"\n### ECMAScript 发展史\n\nECMAScript 是一种由 ECMA 国际（前身为欧洲计算机制造商协会,英文名称是 European Computer Manufacturers Association）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，所以它可以理解为是 javascript 的一个标准,但实际上后两者是 ECMA-262 标准的实现和扩展。\n\n<!--more--> \n\n1998 年 6 月，ECMAScript 2.0 版发布。\n1999 年 12 月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。\n2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，预计次年 8 月发布正式版本。草案发布后，由于 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。\n2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。\n2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。\n2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。\n2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。\n2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。\n2015 年 6 月 17 日，ECMAScript 6 发布正式版本，即 ECMAScript 2015。\n\n### ES5 严格模式\n\n### 严格模式\n\n除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。\n同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。\n\n### 设计目的\n\n早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。\n严格模式是从 ES5 进入标准的，主要目的有以下几个。\n\n1. 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。\n2. 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。\n3. 提高编译器效率，增加运行速度。\n4. 为未来新版本的 JavaScript 语法做好铺垫。\n总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向\n\n### 启用方法\n\n进入严格模式的标志，是一行字符串 use strict。\n‘use strict’;\n老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。\n严格模式可以用于整个脚本，也可以只用于单个函数\n\n1. 整个脚本文件\nuse strict 放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict 可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)\n\n```js\n<script>'use strict'; console.log('这是严格模式');</script>\n```\n\n```js\n<script>console.log('这是正常模式');</script>\n```\n\n上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个 script 标签是严格模式，后一个不是。\n如果 use strict 写成下面这样，则不起作用，严格模式必须从代码一开始就生效。\n\n```js\n<script>console.log('这是正常模式'); 'use strict';</script>\n```\n\n2. 单个函数\nuse strict 放在函数体的第一行，则整个函数以严格模式运行。\n\n```js\nfunction strict() {\n  \"use strict\";\n  return \"这是严格模式\";\n}\nfunction notStrict() {\n  return \"这是正常模式\";\n}\n```\n\n### 严格模式下的要求\n\n变量声明（必须要使用 var）\n函数不能有重名的参数\n正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。\n\n```js\nfunction f(a, a, b) {\n  \"use strict\";\n  return a + b;\n}\n```\n\n禁止八进制的前缀 0 表示法\n正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。\n\n```js\n\"use strict\";\nvar n = 0100;\n```\n\n禁止 this 关键字指向全局对象\n正常模式下，函数内部的 this 可能会指向全局对象（window），严格模式禁止这种用法，避免无意间创造全局变量。\n\n```js\nfunction f() {\n  // 正常模式\n  console.log(this === window);\n}\nf(); // true\nfunction f() {\n  // 严格模式\n  \"use strict\";\n  console.log(this === undefined);\n}\nf(); // true\n上面代码中，严格模式的函数体内部 this 是 undefined。这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 new，这时 this 不再指向全局对象，而是报错。\n```\n\n```js\nfunction f() {\n  \"use strict\";\n  this.a = 1;\n}\nf(); // 报错，this 未定义\n```\n\n严格模式下，使用 with 语句将报错。\n\n```js\n\"use strict\";\nvar obj = { v: 1 };\nwith (obj) {\n  v = 2; //obj.v = 2;\n}\n```\n\n### 创设 eval 作用域\n\n正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。\n\n正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval 所生成的变量只能用于 eval 内部。\n\n```js\n(function () {\n  \"use strict\";\n  var x = 2;\n  console.log(eval(\"var x = 5; x\")); // 5\n  console.log(x); // 2\n})();\n```\n\n上面代码中，由于 eval 语句内部是一个独立作用域，所以内部的变量 x 不会泄露到外部\n\n### ES5 新增的数组方法\n\n### 静态方法\n\nArray.isArray()\nArray.isArray 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。\n\n```js\nvar arr = [1, 2, 3];\ntypeof arr; // \"object\"\nArray.isArray(arr); // true\n```\n\n上面代码中，typeof 运算符只能显示数组的类型是 Object，而 Array.isArray 方法可以识别数组。\n\n### 实例（对象）方法\n\n1. map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。\n\n```js\nvar numbers = [1, 2, 3];\nvar res = numbers.map(function (n) {\n  return n + 1;\n});\nres; // [2, 3, 4]\nnumbers;\n// [1, 2, 3]\n```\n\n上面代码中，numbers 数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。\nmap 方法接受一个函数作为参数。该函数调用时，map 方法向它传入三个参数：当前成员、当前位置和数组本身。\n\n```js\n[1, 2, 3].map(function (elem, index, arr) {\n  return elem * index;\n});\n// [0, 2, 6]\n```\n\n上面代码中，map 方法的回调函数有三个参数，elem 为当前成员的值，index 为当前成员的位置，arr 为原数组（[1, 2, 3]）\n\n2. forEach方法与 map 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map 方法，否则使用 forEach 方法。\nforEach 的用法与 map 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。\n\n```js\nfunction log(element, index, array) {\n  console.log(\"[\" + index + \"] = \" + element);\n}\n[2, 5, 9].forEach(log);\n// [0] = 2\n// [1] = 5\n// [2] = 9\n```\n\n注意，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。\n\n```js\nvar arr = [1, 2, 3];\nfor (var i = 0; i < arr.length; i++) {\n  if (arr[i] === 2) break;\n  console.log(arr[i]);\n}\n```\n\n3. filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。\n   它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。\n   filter 方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。\n\n```js\nvar res = [1, 2, 3, 4, 5].filter(function (elem, index, arr) {\n  return index % 2 === 0;\n});\nres; // [1, 3, 5]\n```\n\n上面代码返回偶数位置的成员组成的新数组。\n\n4. reduce方法依次处理数组的每个成员，最终累计为一个值。reduce 是从左到右处理（从第一个成员到最后一个成员）\nreduce 方法参数是一个函数,该函数接受以下两个参数。\n   1. 累积变量，默认为数组的第一个成员\n   2. 当前变量，默认为数组的第二个成员\n\n```js\nvar res = [1, 2, 3, 4, 5].reduce(function (a, b) {\n  console.log(a, b);\n  return a + b;\n});\n// 1 2\n// 3 3\n// 6 4\n// 10 5\nres; //最后结果：15\n```\n\n上面代码中，reduce 方法求出数组所有成员的和。第一次执行，a 是数组的第一个成员 1，b 是数组的第二个成员 2。第二次执行，a 为上一轮的返回值 3，b 为第三个成员 3。第三次执行，a 为上一轮的返回值 6，b 为第四个成员 4。第四次执行，a 为上一轮返回值 10，b 为第五个成员 5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值 15。\n\n5. indexOf(),lastIndexOf()\n   indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.indexOf(\"b\"); // 1\na.indexOf(\"y\") // -1\n  [\n    //indexOf方法还可以接受第二个参数，表示搜索的开始位置。\n    (\"a\", \"b\", \"c\")\n  ].indexOf(\"a\", 1); // -1\n//上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。\n```\n\nlastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。\n\n```js\nvar a = [2, 5, 9, 2];\na.lastIndexOf(2); // 3\na.lastIndexOf(7); // -1\n```\n\n注意，这两个方法不能用来搜索 NaN 的位置，即它们无法确定数组成员是否包含 NaN。\n\n```js\n[NaN]\n  .indexOf(NaN) // -1\n  [NaN].lastIndexOf(NaN); // -1\n```\n\n这是因为这两个方法内部，使用严格相等运算符（===）进行比较，\n而 NaN 是唯一一个不等于自身的值\n\n### 字符串 string\n\n### 字符串的创建方式\n\n```js\nvar s1 = \"abc\";\nvar s2 = new String(\"abc\");\ntypeof s1; // \"string\"\ntypeof s2; // \"object\"\n```\n\n上面代码中，变量 s1 是字符串，s2 是对象。\n所以,String 对象也叫包装对象\n除了用作构造函数，String 对象还可以当作工具方法使用，将任意类型的值转为字符串。\n\n```js\nString(true); // \"true\"\nString(5); // \"5\"\n```\n\n上面代码将布尔值 ture 和数值 5，分别转换为字符串\n\n字符串实例的 length 属性返回字符串的长度。\n\n```js\n\"abc\".length; // 3\n```\n\n字符串对象是一个类似数组的对象（很像数组，但不是数组）。\n\n```js\nnew String(\"abc\")(\n  // String {0: \"a\", 1: \"b\", 2: \"c\", length: 3}\n  new String(\"abc\")\n)[1]; // \"b\"\n```\n\n上面代码中，字符串 abc 对应的字符串对象，有数值键（0、1、2）和 length 属性，所以可以像数组那样取值。\n\n### charAt 方法\ncharAt 方法返回指定位置的字符，参数是从 0 开始编号的位置。\n\n```js\nvar s = new String(\"abc\");\ns.charAt(1); // \"b\"\ns.charAt(s.length - 1); // \"c\"\n//这个方法完全可以用数组下标替代。\n\"abc\".charAt(1); // \"b\"\n\"abc\"[1]; // \"b\"\n```\n\n### slice 方法\nslice 方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。\n\n```js\n\"JavaScript\".slice(0, 4); // \"Java\"\n//如果省略第二个参数，则表示子字符串一直到原字符串结束。\n\"JavaScript\".slice(4); // \"Script\"\n//如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。\n\"JavaScript\".slice(-6); // \"Script\"\n\"JavaScript\".slice(0, -6); // \"Java\"\n\"JavaScript\".slice(-2, -1); // \"p\"\n//如果第一个参数大于第二个参数，slice方法返回一个空字符串。\n\"JavaScript\".slice(2, 1); //\n```\n\n### substring 方法\nsubstring 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。\n\n```js\n\"JavaScript\".substring(0, 4); // \"Java\"\n//如果省略第二个参数，则表示子字符串一直到原字符串的结束。\n\"JavaScript\".substring(4); // \"Script\"\n//如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。\n\"JavaScript\".substring(10, 4); // \"Script\"\n// 等同于\n\"JavaScript\".substring(4, 10); // \"Script\"\n```\n\n### substr 方法\nsubstr 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同。\nsubstr 方法的第一个参数是子字符串的开始位置（从 0 开始计算），第二个参数是子字符串的长度。\n\n```js\n\"JavaScript\".substr(4, 6); // \"Script\"\n//如果省略第二个参数，则表示子字符串一直到原字符串的结束。\n\"JavaScript\".substr(4); // \"Script\"\n//如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。\n\"JavaScript\".substr(-6); // \"Script\"\n\"JavaScript\".substr(4, -1); // \"\"\n```\n\n//上面代码中，第二个例子的参数-1自动转为0，表示子字符串长度为0，所以返回空字符串\n\n### indexOf 方法\nindexOf 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。\n\n```js\n\"hello world\".indexOf(\"o\"); // 4\n\"JavaScript\".indexOf(\"script\"); // -1\n//indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。\n\"hello world\".indexOf(\"o\", 6); // 7\n//lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。\n\"hello world\".lastIndexOf(\"o\"); // 7\n//另外，lastIndexOf的第二个参数表示从该位置起向前匹配。\n\"hello world\".lastIndexOf(\"o\", 6); // 4\n```\n\n### trim 方法\n\ntrim 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。\n\n```js\n\"hello world\".trim();\n// \"hello world\"\n//该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。\n\"\\r\\nabc \\t\".trim(); // 'abc'\n```\n\n### toLowerCase 方法\n\ntoLowerCase 方法用于将一个字符串全部转为小写，toUpperCase 则是全部转为大写。它们都返回一个新字符串，不改变原字符串。\n\n```js\n\"Hello World\".toLowerCase();\n// \"hello world\"\n\"Hello World\".toUpperCase();\n// \"HELLO WORLD\"\n```\n\n### replace 方法\n\nreplace 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有 g 修饰符的正则表达式）。\n\n```js\n\"aaa\".replace(\"a\", \"b\"); // \"baa\"\n\"aaa\".replace(/a/g, \"b\"); // \"bbb\"\n```\n\n### split 方法\n\nsplit 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。\n\n```js\n\"a|b|c\".split(\"|\"); // [\"a\", \"b\", \"c\"]\n//如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。\n\"a|b|c\".split(\"\"); // [\"a\", \"|\", \"b\", \"|\", \"c\"]\n```\n\n### ASCII 码和字符集\n\n字符串常见 API(charCodeAt\\fromCharCode)\ncharCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。\n'abc'.charCodeAt(1) // 98\n上面代码中，abc 的 1 号位置的字符是 b，它的 Unicode 码点是 98。\nString.fromCharCode()\nString 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。\n\n```js\nString.fromCharCode(); // \"\"\nString.fromCharCode(97); // \"a\"\nString.fromCharCode(104, 101, 108, 108, 111);\n// \"hello\"\n```\n\n统计字符串中每个字符的个数\n\n---\n\n本文作者： 一只野生东子\n","source":"_posts/关于ES5和字符串string.md","raw":"---\ntitle: 关于ES5和字符串string\ndate: 2019-11-15\ntags: js\n---\n\n### ECMAScript 发展史\n\nECMAScript 是一种由 ECMA 国际（前身为欧洲计算机制造商协会,英文名称是 European Computer Manufacturers Association）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，所以它可以理解为是 javascript 的一个标准,但实际上后两者是 ECMA-262 标准的实现和扩展。\n\n<!--more--> \n\n1998 年 6 月，ECMAScript 2.0 版发布。\n1999 年 12 月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。\n2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，预计次年 8 月发布正式版本。草案发布后，由于 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。\n2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。\n2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。\n2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。\n2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。\n2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。\n2015 年 6 月 17 日，ECMAScript 6 发布正式版本，即 ECMAScript 2015。\n\n### ES5 严格模式\n\n### 严格模式\n\n除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。\n同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。\n\n### 设计目的\n\n早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。\n严格模式是从 ES5 进入标准的，主要目的有以下几个。\n\n1. 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。\n2. 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。\n3. 提高编译器效率，增加运行速度。\n4. 为未来新版本的 JavaScript 语法做好铺垫。\n总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向\n\n### 启用方法\n\n进入严格模式的标志，是一行字符串 use strict。\n‘use strict’;\n老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。\n严格模式可以用于整个脚本，也可以只用于单个函数\n\n1. 整个脚本文件\nuse strict 放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict 可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)\n\n```js\n<script>'use strict'; console.log('这是严格模式');</script>\n```\n\n```js\n<script>console.log('这是正常模式');</script>\n```\n\n上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个 script 标签是严格模式，后一个不是。\n如果 use strict 写成下面这样，则不起作用，严格模式必须从代码一开始就生效。\n\n```js\n<script>console.log('这是正常模式'); 'use strict';</script>\n```\n\n2. 单个函数\nuse strict 放在函数体的第一行，则整个函数以严格模式运行。\n\n```js\nfunction strict() {\n  \"use strict\";\n  return \"这是严格模式\";\n}\nfunction notStrict() {\n  return \"这是正常模式\";\n}\n```\n\n### 严格模式下的要求\n\n变量声明（必须要使用 var）\n函数不能有重名的参数\n正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。\n\n```js\nfunction f(a, a, b) {\n  \"use strict\";\n  return a + b;\n}\n```\n\n禁止八进制的前缀 0 表示法\n正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。\n\n```js\n\"use strict\";\nvar n = 0100;\n```\n\n禁止 this 关键字指向全局对象\n正常模式下，函数内部的 this 可能会指向全局对象（window），严格模式禁止这种用法，避免无意间创造全局变量。\n\n```js\nfunction f() {\n  // 正常模式\n  console.log(this === window);\n}\nf(); // true\nfunction f() {\n  // 严格模式\n  \"use strict\";\n  console.log(this === undefined);\n}\nf(); // true\n上面代码中，严格模式的函数体内部 this 是 undefined。这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 new，这时 this 不再指向全局对象，而是报错。\n```\n\n```js\nfunction f() {\n  \"use strict\";\n  this.a = 1;\n}\nf(); // 报错，this 未定义\n```\n\n严格模式下，使用 with 语句将报错。\n\n```js\n\"use strict\";\nvar obj = { v: 1 };\nwith (obj) {\n  v = 2; //obj.v = 2;\n}\n```\n\n### 创设 eval 作用域\n\n正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。\n\n正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval 所生成的变量只能用于 eval 内部。\n\n```js\n(function () {\n  \"use strict\";\n  var x = 2;\n  console.log(eval(\"var x = 5; x\")); // 5\n  console.log(x); // 2\n})();\n```\n\n上面代码中，由于 eval 语句内部是一个独立作用域，所以内部的变量 x 不会泄露到外部\n\n### ES5 新增的数组方法\n\n### 静态方法\n\nArray.isArray()\nArray.isArray 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。\n\n```js\nvar arr = [1, 2, 3];\ntypeof arr; // \"object\"\nArray.isArray(arr); // true\n```\n\n上面代码中，typeof 运算符只能显示数组的类型是 Object，而 Array.isArray 方法可以识别数组。\n\n### 实例（对象）方法\n\n1. map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。\n\n```js\nvar numbers = [1, 2, 3];\nvar res = numbers.map(function (n) {\n  return n + 1;\n});\nres; // [2, 3, 4]\nnumbers;\n// [1, 2, 3]\n```\n\n上面代码中，numbers 数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。\nmap 方法接受一个函数作为参数。该函数调用时，map 方法向它传入三个参数：当前成员、当前位置和数组本身。\n\n```js\n[1, 2, 3].map(function (elem, index, arr) {\n  return elem * index;\n});\n// [0, 2, 6]\n```\n\n上面代码中，map 方法的回调函数有三个参数，elem 为当前成员的值，index 为当前成员的位置，arr 为原数组（[1, 2, 3]）\n\n2. forEach方法与 map 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map 方法，否则使用 forEach 方法。\nforEach 的用法与 map 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。\n\n```js\nfunction log(element, index, array) {\n  console.log(\"[\" + index + \"] = \" + element);\n}\n[2, 5, 9].forEach(log);\n// [0] = 2\n// [1] = 5\n// [2] = 9\n```\n\n注意，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。\n\n```js\nvar arr = [1, 2, 3];\nfor (var i = 0; i < arr.length; i++) {\n  if (arr[i] === 2) break;\n  console.log(arr[i]);\n}\n```\n\n3. filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。\n   它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。\n   filter 方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。\n\n```js\nvar res = [1, 2, 3, 4, 5].filter(function (elem, index, arr) {\n  return index % 2 === 0;\n});\nres; // [1, 3, 5]\n```\n\n上面代码返回偶数位置的成员组成的新数组。\n\n4. reduce方法依次处理数组的每个成员，最终累计为一个值。reduce 是从左到右处理（从第一个成员到最后一个成员）\nreduce 方法参数是一个函数,该函数接受以下两个参数。\n   1. 累积变量，默认为数组的第一个成员\n   2. 当前变量，默认为数组的第二个成员\n\n```js\nvar res = [1, 2, 3, 4, 5].reduce(function (a, b) {\n  console.log(a, b);\n  return a + b;\n});\n// 1 2\n// 3 3\n// 6 4\n// 10 5\nres; //最后结果：15\n```\n\n上面代码中，reduce 方法求出数组所有成员的和。第一次执行，a 是数组的第一个成员 1，b 是数组的第二个成员 2。第二次执行，a 为上一轮的返回值 3，b 为第三个成员 3。第三次执行，a 为上一轮的返回值 6，b 为第四个成员 4。第四次执行，a 为上一轮返回值 10，b 为第五个成员 5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值 15。\n\n5. indexOf(),lastIndexOf()\n   indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.indexOf(\"b\"); // 1\na.indexOf(\"y\") // -1\n  [\n    //indexOf方法还可以接受第二个参数，表示搜索的开始位置。\n    (\"a\", \"b\", \"c\")\n  ].indexOf(\"a\", 1); // -1\n//上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。\n```\n\nlastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。\n\n```js\nvar a = [2, 5, 9, 2];\na.lastIndexOf(2); // 3\na.lastIndexOf(7); // -1\n```\n\n注意，这两个方法不能用来搜索 NaN 的位置，即它们无法确定数组成员是否包含 NaN。\n\n```js\n[NaN]\n  .indexOf(NaN) // -1\n  [NaN].lastIndexOf(NaN); // -1\n```\n\n这是因为这两个方法内部，使用严格相等运算符（===）进行比较，\n而 NaN 是唯一一个不等于自身的值\n\n### 字符串 string\n\n### 字符串的创建方式\n\n```js\nvar s1 = \"abc\";\nvar s2 = new String(\"abc\");\ntypeof s1; // \"string\"\ntypeof s2; // \"object\"\n```\n\n上面代码中，变量 s1 是字符串，s2 是对象。\n所以,String 对象也叫包装对象\n除了用作构造函数，String 对象还可以当作工具方法使用，将任意类型的值转为字符串。\n\n```js\nString(true); // \"true\"\nString(5); // \"5\"\n```\n\n上面代码将布尔值 ture 和数值 5，分别转换为字符串\n\n字符串实例的 length 属性返回字符串的长度。\n\n```js\n\"abc\".length; // 3\n```\n\n字符串对象是一个类似数组的对象（很像数组，但不是数组）。\n\n```js\nnew String(\"abc\")(\n  // String {0: \"a\", 1: \"b\", 2: \"c\", length: 3}\n  new String(\"abc\")\n)[1]; // \"b\"\n```\n\n上面代码中，字符串 abc 对应的字符串对象，有数值键（0、1、2）和 length 属性，所以可以像数组那样取值。\n\n### charAt 方法\ncharAt 方法返回指定位置的字符，参数是从 0 开始编号的位置。\n\n```js\nvar s = new String(\"abc\");\ns.charAt(1); // \"b\"\ns.charAt(s.length - 1); // \"c\"\n//这个方法完全可以用数组下标替代。\n\"abc\".charAt(1); // \"b\"\n\"abc\"[1]; // \"b\"\n```\n\n### slice 方法\nslice 方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。\n\n```js\n\"JavaScript\".slice(0, 4); // \"Java\"\n//如果省略第二个参数，则表示子字符串一直到原字符串结束。\n\"JavaScript\".slice(4); // \"Script\"\n//如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。\n\"JavaScript\".slice(-6); // \"Script\"\n\"JavaScript\".slice(0, -6); // \"Java\"\n\"JavaScript\".slice(-2, -1); // \"p\"\n//如果第一个参数大于第二个参数，slice方法返回一个空字符串。\n\"JavaScript\".slice(2, 1); //\n```\n\n### substring 方法\nsubstring 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。\n\n```js\n\"JavaScript\".substring(0, 4); // \"Java\"\n//如果省略第二个参数，则表示子字符串一直到原字符串的结束。\n\"JavaScript\".substring(4); // \"Script\"\n//如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。\n\"JavaScript\".substring(10, 4); // \"Script\"\n// 等同于\n\"JavaScript\".substring(4, 10); // \"Script\"\n```\n\n### substr 方法\nsubstr 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同。\nsubstr 方法的第一个参数是子字符串的开始位置（从 0 开始计算），第二个参数是子字符串的长度。\n\n```js\n\"JavaScript\".substr(4, 6); // \"Script\"\n//如果省略第二个参数，则表示子字符串一直到原字符串的结束。\n\"JavaScript\".substr(4); // \"Script\"\n//如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。\n\"JavaScript\".substr(-6); // \"Script\"\n\"JavaScript\".substr(4, -1); // \"\"\n```\n\n//上面代码中，第二个例子的参数-1自动转为0，表示子字符串长度为0，所以返回空字符串\n\n### indexOf 方法\nindexOf 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。\n\n```js\n\"hello world\".indexOf(\"o\"); // 4\n\"JavaScript\".indexOf(\"script\"); // -1\n//indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。\n\"hello world\".indexOf(\"o\", 6); // 7\n//lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。\n\"hello world\".lastIndexOf(\"o\"); // 7\n//另外，lastIndexOf的第二个参数表示从该位置起向前匹配。\n\"hello world\".lastIndexOf(\"o\", 6); // 4\n```\n\n### trim 方法\n\ntrim 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。\n\n```js\n\"hello world\".trim();\n// \"hello world\"\n//该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。\n\"\\r\\nabc \\t\".trim(); // 'abc'\n```\n\n### toLowerCase 方法\n\ntoLowerCase 方法用于将一个字符串全部转为小写，toUpperCase 则是全部转为大写。它们都返回一个新字符串，不改变原字符串。\n\n```js\n\"Hello World\".toLowerCase();\n// \"hello world\"\n\"Hello World\".toUpperCase();\n// \"HELLO WORLD\"\n```\n\n### replace 方法\n\nreplace 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有 g 修饰符的正则表达式）。\n\n```js\n\"aaa\".replace(\"a\", \"b\"); // \"baa\"\n\"aaa\".replace(/a/g, \"b\"); // \"bbb\"\n```\n\n### split 方法\n\nsplit 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。\n\n```js\n\"a|b|c\".split(\"|\"); // [\"a\", \"b\", \"c\"]\n//如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。\n\"a|b|c\".split(\"\"); // [\"a\", \"|\", \"b\", \"|\", \"c\"]\n```\n\n### ASCII 码和字符集\n\n字符串常见 API(charCodeAt\\fromCharCode)\ncharCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。\n'abc'.charCodeAt(1) // 98\n上面代码中，abc 的 1 号位置的字符是 b，它的 Unicode 码点是 98。\nString.fromCharCode()\nString 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。\n\n```js\nString.fromCharCode(); // \"\"\nString.fromCharCode(97); // \"a\"\nString.fromCharCode(104, 101, 108, 108, 111);\n// \"hello\"\n```\n\n统计字符串中每个字符的个数\n\n---\n\n本文作者： 一只野生东子\n","slug":"关于ES5和字符串string","published":1,"updated":"2021-11-26T06:54:45.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2h000h9co37r5z9y4v","content":"<h3 id=\"ECMAScript-发展史\"><a href=\"#ECMAScript-发展史\" class=\"headerlink\" title=\"ECMAScript 发展史\"></a>ECMAScript 发展史</h3><p>ECMAScript 是一种由 ECMA 国际（前身为欧洲计算机制造商协会,英文名称是 European Computer Manufacturers Association）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，所以它可以理解为是 javascript 的一个标准,但实际上后两者是 ECMA-262 标准的实现和扩展。</p>\n<span id=\"more\"></span> \n\n<p>1998 年 6 月，ECMAScript 2.0 版发布。<br>1999 年 12 月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。<br>2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，预计次年 8 月发布正式版本。草案发布后，由于 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。<br>2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。<br>2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。<br>2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。<br>2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。<br>2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。<br>2015 年 6 月 17 日，ECMAScript 6 发布正式版本，即 ECMAScript 2015。</p>\n<h3 id=\"ES5-严格模式\"><a href=\"#ES5-严格模式\" class=\"headerlink\" title=\"ES5 严格模式\"></a>ES5 严格模式</h3><h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。<br>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p>\n<h3 id=\"设计目的\"><a href=\"#设计目的\" class=\"headerlink\" title=\"设计目的\"></a>设计目的</h3><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。<br>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>\n<ol>\n<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>\n<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>\n<li>提高编译器效率，增加运行速度。</li>\n<li>为未来新版本的 JavaScript 语法做好铺垫。<br>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向</li>\n</ol>\n<h3 id=\"启用方法\"><a href=\"#启用方法\" class=\"headerlink\" title=\"启用方法\"></a>启用方法</h3><p>进入严格模式的标志，是一行字符串 use strict。<br>‘use strict’;<br>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。<br>严格模式可以用于整个脚本，也可以只用于单个函数</p>\n<ol>\n<li>整个脚本文件<br>use strict 放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict 可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"string\">&#x27;use strict&#x27;</span>; <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这是严格模式&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这是正常模式&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个 script 标签是严格模式，后一个不是。<br>如果 use strict 写成下面这样，则不起作用，严格模式必须从代码一开始就生效。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这是正常模式&#x27;</span>); <span class=\"string\">&#x27;use strict&#x27;</span>;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>单个函数<br>use strict 放在函数体的第一行，则整个函数以严格模式运行。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strict</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;这是严格模式&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">notStrict</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;这是正常模式&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"严格模式下的要求\"><a href=\"#严格模式下的要求\" class=\"headerlink\" title=\"严格模式下的要求\"></a>严格模式下的要求</h3><p>变量声明（必须要使用 var）<br>函数不能有重名的参数<br>正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, a, b</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>禁止八进制的前缀 0 表示法<br>正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">0100</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>禁止 this 关键字指向全局对象<br>正常模式下，函数内部的 this 可能会指向全局对象（window），严格模式禁止这种用法，避免无意间创造全局变量。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正常模式</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 严格模式</span></span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// true</span></span><br><span class=\"line\">上面代码中，严格模式的函数体内部 <span class=\"built_in\">this</span> 是 <span class=\"literal\">undefined</span>。这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 <span class=\"keyword\">new</span>，这时 <span class=\"built_in\">this</span> 不再指向全局对象，而是报错。</span><br></pre></td></tr></table></figure></div>\n\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 报错，this 未定义</span></span><br></pre></td></tr></table></figure></div>\n\n<p>严格模式下，使用 with 语句将报错。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">v</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">  v = <span class=\"number\">2</span>; <span class=\"comment\">//obj.v = 2;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"创设-eval-作用域\"><a href=\"#创设-eval-作用域\" class=\"headerlink\" title=\"创设 eval 作用域\"></a>创设 eval 作用域</h3><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。</p>\n<p>正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval 所生成的变量只能用于 eval 内部。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>(<span class=\"string\">&quot;var x = 5; x&quot;</span>)); <span class=\"comment\">// 5</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，由于 eval 语句内部是一个独立作用域，所以内部的变量 x 不会泄露到外部</p>\n<h3 id=\"ES5-新增的数组方法\"><a href=\"#ES5-新增的数组方法\" class=\"headerlink\" title=\"ES5 新增的数组方法\"></a>ES5 新增的数组方法</h3><h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>Array.isArray()<br>Array.isArray 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> arr; <span class=\"comment\">// &quot;object&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(arr); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，typeof 运算符只能显示数组的类型是 Object，而 Array.isArray 方法可以识别数组。</p>\n<h3 id=\"实例（对象）方法\"><a href=\"#实例（对象）方法\" class=\"headerlink\" title=\"实例（对象）方法\"></a>实例（对象）方法</h3><ol>\n<li>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = numbers.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">res; <span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\">numbers;</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，numbers 数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。<br>map 方法接受一个函数作为参数。该函数调用时，map 方法向它传入三个参数：当前成员、当前位置和数组本身。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">elem, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> elem * index;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// [0, 2, 6]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，map 方法的回调函数有三个参数，elem 为当前成员的值，index 为当前成员的位置，arr 为原数组（[1, 2, 3]）</p>\n<ol start=\"2\">\n<li>forEach方法与 map 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map 方法，否则使用 forEach 方法。<br>forEach 的用法与 map 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">element, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;[&quot;</span> + index + <span class=\"string\">&quot;] = &quot;</span> + element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>].forEach(log);</span><br><span class=\"line\"><span class=\"comment\">// [0] = 2</span></span><br><span class=\"line\"><span class=\"comment\">// [1] = 5</span></span><br><span class=\"line\"><span class=\"comment\">// [2] = 9</span></span><br></pre></td></tr></table></figure></div>\n\n<p>注意，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr[i] === <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。<br>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。<br>filter 方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">elem, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> index % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">res; <span class=\"comment\">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码返回偶数位置的成员组成的新数组。</p>\n<ol start=\"4\">\n<li>reduce方法依次处理数组的每个成员，最终累计为一个值。reduce 是从左到右处理（从第一个成员到最后一个成员）<br>reduce 方法参数是一个函数,该函数接受以下两个参数。<ol>\n<li>累积变量，默认为数组的第一个成员</li>\n<li>当前变量，默认为数组的第二个成员</li>\n</ol>\n</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3 3</span></span><br><span class=\"line\"><span class=\"comment\">// 6 4</span></span><br><span class=\"line\"><span class=\"comment\">// 10 5</span></span><br><span class=\"line\">res; <span class=\"comment\">//最后结果：15</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，reduce 方法求出数组所有成员的和。第一次执行，a 是数组的第一个成员 1，b 是数组的第二个成员 2。第二次执行，a 为上一轮的返回值 3，b 为第三个成员 3。第三次执行，a 为上一轮的返回值 6，b 为第四个成员 4。第四次执行，a 为上一轮返回值 10，b 为第五个成员 5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值 15。</p>\n<ol start=\"5\">\n<li>indexOf(),lastIndexOf()<br>indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.indexOf(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">a.indexOf(<span class=\"string\">&quot;y&quot;</span>) <span class=\"comment\">// -1</span></span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">//indexOf方法还可以接受第二个参数，表示搜索的开始位置。</span></span><br><span class=\"line\">    (<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br><span class=\"line\">  ].indexOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">1</span>); <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"comment\">//上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。</span></span><br></pre></td></tr></table></figure></div>\n\n<p>lastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">a.lastIndexOf(<span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\">a.lastIndexOf(<span class=\"number\">7</span>); <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure></div>\n\n<p>注意，这两个方法不能用来搜索 NaN 的位置，即它们无法确定数组成员是否包含 NaN。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"literal\">NaN</span>]</span><br><span class=\"line\">  .indexOf(<span class=\"literal\">NaN</span>) <span class=\"comment\">// -1</span></span><br><span class=\"line\">  [<span class=\"literal\">NaN</span>].lastIndexOf(<span class=\"literal\">NaN</span>); <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure></div>\n\n<p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，<br>而 NaN 是唯一一个不等于自身的值</p>\n<h3 id=\"字符串-string\"><a href=\"#字符串-string\" class=\"headerlink\" title=\"字符串 string\"></a>字符串 string</h3><h3 id=\"字符串的创建方式\"><a href=\"#字符串的创建方式\" class=\"headerlink\" title=\"字符串的创建方式\"></a>字符串的创建方式</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s1; <span class=\"comment\">// &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s2; <span class=\"comment\">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，变量 s1 是字符串，s2 是对象。<br>所以,String 对象也叫包装对象<br>除了用作构造函数，String 对象还可以当作工具方法使用，将任意类型的值转为字符串。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>(<span class=\"number\">5</span>); <span class=\"comment\">// &quot;5&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码将布尔值 ture 和数值 5，分别转换为字符串</p>\n<p>字符串实例的 length 属性返回字符串的长度。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;abc&quot;</span>.length; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></div>\n\n<p>字符串对象是一个类似数组的对象（很像数组，但不是数组）。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>)(</span><br><span class=\"line\">  <span class=\"comment\">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>)</span><br><span class=\"line\">)[<span class=\"number\">1</span>]; <span class=\"comment\">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，字符串 abc 对应的字符串对象，有数值键（0、1、2）和 length 属性，所以可以像数组那样取值。</p>\n<h3 id=\"charAt-方法\"><a href=\"#charAt-方法\" class=\"headerlink\" title=\"charAt 方法\"></a>charAt 方法</h3><p>charAt 方法返回指定位置的字符，参数是从 0 开始编号的位置。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">s.charAt(<span class=\"number\">1</span>); <span class=\"comment\">// &quot;b&quot;</span></span><br><span class=\"line\">s.charAt(s.length - <span class=\"number\">1</span>); <span class=\"comment\">// &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法完全可以用数组下标替代。</span></span><br><span class=\"line\"><span class=\"string\">&quot;abc&quot;</span>.charAt(<span class=\"number\">1</span>); <span class=\"comment\">// &quot;b&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;abc&quot;</span>[<span class=\"number\">1</span>]; <span class=\"comment\">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"slice-方法\"><a href=\"#slice-方法\" class=\"headerlink\" title=\"slice 方法\"></a>slice 方法</h3><p>slice 方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">0</span>, <span class=\"number\">4</span>); <span class=\"comment\">// &quot;Java&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果省略第二个参数，则表示子字符串一直到原字符串结束。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(-<span class=\"number\">6</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">0</span>, -<span class=\"number\">6</span>); <span class=\"comment\">// &quot;Java&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(-<span class=\"number\">2</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// &quot;p&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果第一个参数大于第二个参数，slice方法返回一个空字符串。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">2</span>, <span class=\"number\">1</span>); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"substring-方法\"><a href=\"#substring-方法\" class=\"headerlink\" title=\"substring 方法\"></a>substring 方法</h3><p>substring 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">0</span>, <span class=\"number\">4</span>); <span class=\"comment\">// &quot;Java&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果省略第二个参数，则表示子字符串一直到原字符串的结束。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">10</span>, <span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">4</span>, <span class=\"number\">10</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"substr-方法\"><a href=\"#substr-方法\" class=\"headerlink\" title=\"substr 方法\"></a>substr 方法</h3><p>substr 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同。<br>substr 方法的第一个参数是子字符串的开始位置（从 0 开始计算），第二个参数是子字符串的长度。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(<span class=\"number\">4</span>, <span class=\"number\">6</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果省略第二个参数，则表示子字符串一直到原字符串的结束。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(<span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(-<span class=\"number\">6</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(<span class=\"number\">4</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// &quot;&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>//上面代码中，第二个例子的参数-1自动转为0，表示子字符串长度为0，所以返回空字符串</p>\n<h3 id=\"indexOf-方法\"><a href=\"#indexOf-方法\" class=\"headerlink\" title=\"indexOf 方法\"></a>indexOf 方法</h3><p>indexOf 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.indexOf(<span class=\"string\">&quot;o&quot;</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.indexOf(<span class=\"string\">&quot;script&quot;</span>); <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"comment\">//indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.indexOf(<span class=\"string\">&quot;o&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">//lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.lastIndexOf(<span class=\"string\">&quot;o&quot;</span>); <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">//另外，lastIndexOf的第二个参数表示从该位置起向前匹配。</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.lastIndexOf(<span class=\"string\">&quot;o&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"trim-方法\"><a href=\"#trim-方法\" class=\"headerlink\" title=\"trim 方法\"></a>trim 方法</h3><p>trim 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.trim();</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\r\\nabc \\t&quot;</span>.trim(); <span class=\"comment\">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"toLowerCase-方法\"><a href=\"#toLowerCase-方法\" class=\"headerlink\" title=\"toLowerCase 方法\"></a>toLowerCase 方法</h3><p>toLowerCase 方法用于将一个字符串全部转为小写，toUpperCase 则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello World&quot;</span>.toLowerCase();</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello World&quot;</span>.toUpperCase();</span><br><span class=\"line\"><span class=\"comment\">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"replace-方法\"><a href=\"#replace-方法\" class=\"headerlink\" title=\"replace 方法\"></a>replace 方法</h3><p>replace 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有 g 修饰符的正则表达式）。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;aaa&quot;</span>.replace(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// &quot;baa&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;aaa&quot;</span>.replace(<span class=\"regexp\">/a/g</span>, <span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"split-方法\"><a href=\"#split-方法\" class=\"headerlink\" title=\"split 方法\"></a>split 方法</h3><p>split 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;a|b|c&quot;</span>.split(<span class=\"string\">&quot;|&quot;</span>); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">//如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</span></span><br><span class=\"line\"><span class=\"string\">&quot;a|b|c&quot;</span>.split(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"ASCII-码和字符集\"><a href=\"#ASCII-码和字符集\" class=\"headerlink\" title=\"ASCII 码和字符集\"></a>ASCII 码和字符集</h3><p>字符串常见 API(charCodeAt\\fromCharCode)<br>charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。<br>‘abc’.charCodeAt(1) // 98<br>上面代码中，abc 的 1 号位置的字符是 b，它的 Unicode 码点是 98。<br>String.fromCharCode()<br>String 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(); <span class=\"comment\">// &quot;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">97</span>); <span class=\"comment\">// &quot;a&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>);</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>统计字符串中每个字符的个数</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"ECMAScript-发展史\"><a href=\"#ECMAScript-发展史\" class=\"headerlink\" title=\"ECMAScript 发展史\"></a>ECMAScript 发展史</h3><p>ECMAScript 是一种由 ECMA 国际（前身为欧洲计算机制造商协会,英文名称是 European Computer Manufacturers Association）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，所以它可以理解为是 javascript 的一个标准,但实际上后两者是 ECMA-262 标准的实现和扩展。</p>","more":"<p>1998 年 6 月，ECMAScript 2.0 版发布。<br>1999 年 12 月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。<br>2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，预计次年 8 月发布正式版本。草案发布后，由于 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。<br>2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。<br>2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。<br>2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。<br>2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。<br>2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。<br>2015 年 6 月 17 日，ECMAScript 6 发布正式版本，即 ECMAScript 2015。</p>\n<h3 id=\"ES5-严格模式\"><a href=\"#ES5-严格模式\" class=\"headerlink\" title=\"ES5 严格模式\"></a>ES5 严格模式</h3><h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。<br>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p>\n<h3 id=\"设计目的\"><a href=\"#设计目的\" class=\"headerlink\" title=\"设计目的\"></a>设计目的</h3><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。<br>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>\n<ol>\n<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>\n<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>\n<li>提高编译器效率，增加运行速度。</li>\n<li>为未来新版本的 JavaScript 语法做好铺垫。<br>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向</li>\n</ol>\n<h3 id=\"启用方法\"><a href=\"#启用方法\" class=\"headerlink\" title=\"启用方法\"></a>启用方法</h3><p>进入严格模式的标志，是一行字符串 use strict。<br>‘use strict’;<br>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。<br>严格模式可以用于整个脚本，也可以只用于单个函数</p>\n<ol>\n<li>整个脚本文件<br>use strict 放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict 可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"string\">&#x27;use strict&#x27;</span>; <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这是严格模式&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这是正常模式&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个 script 标签是严格模式，后一个不是。<br>如果 use strict 写成下面这样，则不起作用，严格模式必须从代码一开始就生效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这是正常模式&#x27;</span>); <span class=\"string\">&#x27;use strict&#x27;</span>;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>单个函数<br>use strict 放在函数体的第一行，则整个函数以严格模式运行。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strict</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;这是严格模式&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">notStrict</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;这是正常模式&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"严格模式下的要求\"><a href=\"#严格模式下的要求\" class=\"headerlink\" title=\"严格模式下的要求\"></a>严格模式下的要求</h3><p>变量声明（必须要使用 var）<br>函数不能有重名的参数<br>正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, a, b</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>禁止八进制的前缀 0 表示法<br>正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">0100</span>;</span><br></pre></td></tr></table></figure>\n\n<p>禁止 this 关键字指向全局对象<br>正常模式下，函数内部的 this 可能会指向全局对象（window），严格模式禁止这种用法，避免无意间创造全局变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正常模式</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 严格模式</span></span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// true</span></span><br><span class=\"line\">上面代码中，严格模式的函数体内部 <span class=\"built_in\">this</span> 是 <span class=\"literal\">undefined</span>。这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 <span class=\"keyword\">new</span>，这时 <span class=\"built_in\">this</span> 不再指向全局对象，而是报错。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 报错，this 未定义</span></span><br></pre></td></tr></table></figure>\n\n<p>严格模式下，使用 with 语句将报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">v</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">  v = <span class=\"number\">2</span>; <span class=\"comment\">//obj.v = 2;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创设-eval-作用域\"><a href=\"#创设-eval-作用域\" class=\"headerlink\" title=\"创设 eval 作用域\"></a>创设 eval 作用域</h3><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。</p>\n<p>正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval 所生成的变量只能用于 eval 内部。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  &quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">eval</span>(<span class=\"string\">&quot;var x = 5; x&quot;</span>)); <span class=\"comment\">// 5</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，由于 eval 语句内部是一个独立作用域，所以内部的变量 x 不会泄露到外部</p>\n<h3 id=\"ES5-新增的数组方法\"><a href=\"#ES5-新增的数组方法\" class=\"headerlink\" title=\"ES5 新增的数组方法\"></a>ES5 新增的数组方法</h3><h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>Array.isArray()<br>Array.isArray 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> arr; <span class=\"comment\">// &quot;object&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(arr); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，typeof 运算符只能显示数组的类型是 Object，而 Array.isArray 方法可以识别数组。</p>\n<h3 id=\"实例（对象）方法\"><a href=\"#实例（对象）方法\" class=\"headerlink\" title=\"实例（对象）方法\"></a>实例（对象）方法</h3><ol>\n<li>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = numbers.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">res; <span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\">numbers;</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，numbers 数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。<br>map 方法接受一个函数作为参数。该函数调用时，map 方法向它传入三个参数：当前成员、当前位置和数组本身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">elem, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> elem * index;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// [0, 2, 6]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，map 方法的回调函数有三个参数，elem 为当前成员的值，index 为当前成员的位置，arr 为原数组（[1, 2, 3]）</p>\n<ol start=\"2\">\n<li>forEach方法与 map 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map 方法，否则使用 forEach 方法。<br>forEach 的用法与 map 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">element, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;[&quot;</span> + index + <span class=\"string\">&quot;] = &quot;</span> + element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>].forEach(log);</span><br><span class=\"line\"><span class=\"comment\">// [0] = 2</span></span><br><span class=\"line\"><span class=\"comment\">// [1] = 5</span></span><br><span class=\"line\"><span class=\"comment\">// [2] = 9</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr[i] === <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。<br>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。<br>filter 方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">elem, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> index % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">res; <span class=\"comment\">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码返回偶数位置的成员组成的新数组。</p>\n<ol start=\"4\">\n<li>reduce方法依次处理数组的每个成员，最终累计为一个值。reduce 是从左到右处理（从第一个成员到最后一个成员）<br>reduce 方法参数是一个函数,该函数接受以下两个参数。<ol>\n<li>累积变量，默认为数组的第一个成员</li>\n<li>当前变量，默认为数组的第二个成员</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3 3</span></span><br><span class=\"line\"><span class=\"comment\">// 6 4</span></span><br><span class=\"line\"><span class=\"comment\">// 10 5</span></span><br><span class=\"line\">res; <span class=\"comment\">//最后结果：15</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，reduce 方法求出数组所有成员的和。第一次执行，a 是数组的第一个成员 1，b 是数组的第二个成员 2。第二次执行，a 为上一轮的返回值 3，b 为第三个成员 3。第三次执行，a 为上一轮的返回值 6，b 为第四个成员 4。第四次执行，a 为上一轮返回值 10，b 为第五个成员 5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值 15。</p>\n<ol start=\"5\">\n<li>indexOf(),lastIndexOf()<br>indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.indexOf(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">a.indexOf(<span class=\"string\">&quot;y&quot;</span>) <span class=\"comment\">// -1</span></span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">//indexOf方法还可以接受第二个参数，表示搜索的开始位置。</span></span><br><span class=\"line\">    (<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span><br><span class=\"line\">  ].indexOf(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">1</span>); <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"comment\">//上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。</span></span><br></pre></td></tr></table></figure>\n\n<p>lastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">a.lastIndexOf(<span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\">a.lastIndexOf(<span class=\"number\">7</span>); <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，这两个方法不能用来搜索 NaN 的位置，即它们无法确定数组成员是否包含 NaN。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"literal\">NaN</span>]</span><br><span class=\"line\">  .indexOf(<span class=\"literal\">NaN</span>) <span class=\"comment\">// -1</span></span><br><span class=\"line\">  [<span class=\"literal\">NaN</span>].lastIndexOf(<span class=\"literal\">NaN</span>); <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，<br>而 NaN 是唯一一个不等于自身的值</p>\n<h3 id=\"字符串-string\"><a href=\"#字符串-string\" class=\"headerlink\" title=\"字符串 string\"></a>字符串 string</h3><h3 id=\"字符串的创建方式\"><a href=\"#字符串的创建方式\" class=\"headerlink\" title=\"字符串的创建方式\"></a>字符串的创建方式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s1; <span class=\"comment\">// &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s2; <span class=\"comment\">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 s1 是字符串，s2 是对象。<br>所以,String 对象也叫包装对象<br>除了用作构造函数，String 对象还可以当作工具方法使用，将任意类型的值转为字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>(<span class=\"number\">5</span>); <span class=\"comment\">// &quot;5&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码将布尔值 ture 和数值 5，分别转换为字符串</p>\n<p>字符串实例的 length 属性返回字符串的长度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;abc&quot;</span>.length; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>字符串对象是一个类似数组的对象（很像数组，但不是数组）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>)(</span><br><span class=\"line\">  <span class=\"comment\">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>)</span><br><span class=\"line\">)[<span class=\"number\">1</span>]; <span class=\"comment\">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，字符串 abc 对应的字符串对象，有数值键（0、1、2）和 length 属性，所以可以像数组那样取值。</p>\n<h3 id=\"charAt-方法\"><a href=\"#charAt-方法\" class=\"headerlink\" title=\"charAt 方法\"></a>charAt 方法</h3><p>charAt 方法返回指定位置的字符，参数是从 0 开始编号的位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">s.charAt(<span class=\"number\">1</span>); <span class=\"comment\">// &quot;b&quot;</span></span><br><span class=\"line\">s.charAt(s.length - <span class=\"number\">1</span>); <span class=\"comment\">// &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法完全可以用数组下标替代。</span></span><br><span class=\"line\"><span class=\"string\">&quot;abc&quot;</span>.charAt(<span class=\"number\">1</span>); <span class=\"comment\">// &quot;b&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;abc&quot;</span>[<span class=\"number\">1</span>]; <span class=\"comment\">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"slice-方法\"><a href=\"#slice-方法\" class=\"headerlink\" title=\"slice 方法\"></a>slice 方法</h3><p>slice 方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">0</span>, <span class=\"number\">4</span>); <span class=\"comment\">// &quot;Java&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果省略第二个参数，则表示子字符串一直到原字符串结束。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(-<span class=\"number\">6</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">0</span>, -<span class=\"number\">6</span>); <span class=\"comment\">// &quot;Java&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(-<span class=\"number\">2</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// &quot;p&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果第一个参数大于第二个参数，slice方法返回一个空字符串。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.slice(<span class=\"number\">2</span>, <span class=\"number\">1</span>); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"substring-方法\"><a href=\"#substring-方法\" class=\"headerlink\" title=\"substring 方法\"></a>substring 方法</h3><p>substring 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">0</span>, <span class=\"number\">4</span>); <span class=\"comment\">// &quot;Java&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果省略第二个参数，则表示子字符串一直到原字符串的结束。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">10</span>, <span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substring(<span class=\"number\">4</span>, <span class=\"number\">10</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"substr-方法\"><a href=\"#substr-方法\" class=\"headerlink\" title=\"substr 方法\"></a>substr 方法</h3><p>substr 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同。<br>substr 方法的第一个参数是子字符串的开始位置（从 0 开始计算），第二个参数是子字符串的长度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(<span class=\"number\">4</span>, <span class=\"number\">6</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果省略第二个参数，则表示子字符串一直到原字符串的结束。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(<span class=\"number\">4</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(-<span class=\"number\">6</span>); <span class=\"comment\">// &quot;Script&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.substr(<span class=\"number\">4</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>//上面代码中，第二个例子的参数-1自动转为0，表示子字符串长度为0，所以返回空字符串</p>\n<h3 id=\"indexOf-方法\"><a href=\"#indexOf-方法\" class=\"headerlink\" title=\"indexOf 方法\"></a>indexOf 方法</h3><p>indexOf 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.indexOf(<span class=\"string\">&quot;o&quot;</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"string\">&quot;JavaScript&quot;</span>.indexOf(<span class=\"string\">&quot;script&quot;</span>); <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"comment\">//indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.indexOf(<span class=\"string\">&quot;o&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">//lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.lastIndexOf(<span class=\"string\">&quot;o&quot;</span>); <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">//另外，lastIndexOf的第二个参数表示从该位置起向前匹配。</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.lastIndexOf(<span class=\"string\">&quot;o&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"trim-方法\"><a href=\"#trim-方法\" class=\"headerlink\" title=\"trim 方法\"></a>trim 方法</h3><p>trim 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span>.trim();</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\r\\nabc \\t&quot;</span>.trim(); <span class=\"comment\">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"toLowerCase-方法\"><a href=\"#toLowerCase-方法\" class=\"headerlink\" title=\"toLowerCase 方法\"></a>toLowerCase 方法</h3><p>toLowerCase 方法用于将一个字符串全部转为小写，toUpperCase 则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello World&quot;</span>.toLowerCase();</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello World&quot;</span>.toUpperCase();</span><br><span class=\"line\"><span class=\"comment\">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"replace-方法\"><a href=\"#replace-方法\" class=\"headerlink\" title=\"replace 方法\"></a>replace 方法</h3><p>replace 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有 g 修饰符的正则表达式）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;aaa&quot;</span>.replace(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// &quot;baa&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;aaa&quot;</span>.replace(<span class=\"regexp\">/a/g</span>, <span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"split-方法\"><a href=\"#split-方法\" class=\"headerlink\" title=\"split 方法\"></a>split 方法</h3><p>split 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;a|b|c&quot;</span>.split(<span class=\"string\">&quot;|&quot;</span>); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">//如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</span></span><br><span class=\"line\"><span class=\"string\">&quot;a|b|c&quot;</span>.split(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ASCII-码和字符集\"><a href=\"#ASCII-码和字符集\" class=\"headerlink\" title=\"ASCII 码和字符集\"></a>ASCII 码和字符集</h3><p>字符串常见 API(charCodeAt\\fromCharCode)<br>charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。<br>‘abc’.charCodeAt(1) // 98<br>上面代码中，abc 的 1 号位置的字符是 b，它的 Unicode 码点是 98。<br>String.fromCharCode()<br>String 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(); <span class=\"comment\">// &quot;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">97</span>); <span class=\"comment\">// &quot;a&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>);</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>统计字符串中每个字符的个数</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"关于VUE","date":"2020-06-17T16:00:00.000Z","_content":"\n## Vue 是什么？\n\n先放一下 Vue 的官网，多读一读官方文档总是有好处的 ~\n\n[Vue 官网 >>](https://cn.vuejs.org/v2/guide/)\n\n### 简单点来说 Vue 是一套用于构建用户界面的前端渐进式的 MVVM 开发框架。\n\n前端学无止境 ヾ(ﾟ ∀ ﾟゞ)\n\n秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)\n\n<font color=\"red\">特别耐斯的小前端</font>\n\n<!--more-->\n\n### Vue 的生命周期是什么？\n\nVue实例从开始创建、初始化数据、编译模板、挂载dom和渲染、更新和渲染、卸载等一系列过程，这就是Vue的生命周期\n\n### Vue 的钩子函数有哪些？\n\n```\nBeforeCreate()  组件实例被创建之初，组件的属性生效之前\ncreated()  组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用\nBeforeMount()  在挂载开始之前被调用：相关的 render 函数首次被调用\nmounted()  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子\nBeforeUpdate()  组件数据更新之前调用，发生在虚拟 DOM 打补丁之前\nupdated()  组件数据更新之后\nBeforeDestroy()  组件销毁前\ndestroyed()  组件销毁成功\n```\n\n### Vue 在哪个生命周期内调用异步请求？为什么？\n\n可以在created、beforeMount、mounted中调用，因为这三个钩子函数中，data已经创建，可以将服务器返回的数据进行赋值。\n\n```\n在created中用异步请求的优点\n    能更快的获取服务器的数据，减少页面加载时间。\n    ssr不支持beforeMount、mounted，所以放在created中有助于一致性。\n```\n\n### Vue 组件间通信方式有哪些？\n\n1. 父传子 使用 props 属性进行\n2. 字传父 使用事件派发 ($emit)\n3. 非相关组件 使用时间总线(EventBus)\n\n### 路由的传参方式有哪些？\n\n1. 使用进行路由导航，传递参数。\n2. 使用 this.$router.push,通过配置路由属性中的 path 来确定匹配的路由，携带参数进行传参。\n3. 使用 this.$router.push,通过配置路由属性中的 name 来确定匹配的路由，携带参数进行传参。\n4. 使用 path 匹配路由通过 query 传参，query 传参的参数会显示在 url 地址的后面 ?id=……\n\n---\n\n本文作者： 一只野生东子","source":"_posts/关于vue.md","raw":"---\ntitle: 关于VUE\ndate: 2020-06-18\ntags: vue\n---\n\n## Vue 是什么？\n\n先放一下 Vue 的官网，多读一读官方文档总是有好处的 ~\n\n[Vue 官网 >>](https://cn.vuejs.org/v2/guide/)\n\n### 简单点来说 Vue 是一套用于构建用户界面的前端渐进式的 MVVM 开发框架。\n\n前端学无止境 ヾ(ﾟ ∀ ﾟゞ)\n\n秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)\n\n<font color=\"red\">特别耐斯的小前端</font>\n\n<!--more-->\n\n### Vue 的生命周期是什么？\n\nVue实例从开始创建、初始化数据、编译模板、挂载dom和渲染、更新和渲染、卸载等一系列过程，这就是Vue的生命周期\n\n### Vue 的钩子函数有哪些？\n\n```\nBeforeCreate()  组件实例被创建之初，组件的属性生效之前\ncreated()  组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用\nBeforeMount()  在挂载开始之前被调用：相关的 render 函数首次被调用\nmounted()  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子\nBeforeUpdate()  组件数据更新之前调用，发生在虚拟 DOM 打补丁之前\nupdated()  组件数据更新之后\nBeforeDestroy()  组件销毁前\ndestroyed()  组件销毁成功\n```\n\n### Vue 在哪个生命周期内调用异步请求？为什么？\n\n可以在created、beforeMount、mounted中调用，因为这三个钩子函数中，data已经创建，可以将服务器返回的数据进行赋值。\n\n```\n在created中用异步请求的优点\n    能更快的获取服务器的数据，减少页面加载时间。\n    ssr不支持beforeMount、mounted，所以放在created中有助于一致性。\n```\n\n### Vue 组件间通信方式有哪些？\n\n1. 父传子 使用 props 属性进行\n2. 字传父 使用事件派发 ($emit)\n3. 非相关组件 使用时间总线(EventBus)\n\n### 路由的传参方式有哪些？\n\n1. 使用进行路由导航，传递参数。\n2. 使用 this.$router.push,通过配置路由属性中的 path 来确定匹配的路由，携带参数进行传参。\n3. 使用 this.$router.push,通过配置路由属性中的 name 来确定匹配的路由，携带参数进行传参。\n4. 使用 path 匹配路由通过 query 传参，query 传参的参数会显示在 url 地址的后面 ?id=……\n\n---\n\n本文作者： 一只野生东子","slug":"关于vue","published":1,"updated":"2021-11-26T09:15:30.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2i000j9co30qfygqel","content":"<h2 id=\"Vue-是什么？\"><a href=\"#Vue-是什么？\" class=\"headerlink\" title=\"Vue 是什么？\"></a>Vue 是什么？</h2><p>先放一下 Vue 的官网，多读一读官方文档总是有好处的 ~</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\">Vue 官网 &gt;&gt;</a></p>\n<h3 id=\"简单点来说-Vue-是一套用于构建用户界面的前端渐进式的-MVVM-开发框架。\"><a href=\"#简单点来说-Vue-是一套用于构建用户界面的前端渐进式的-MVVM-开发框架。\" class=\"headerlink\" title=\"简单点来说 Vue 是一套用于构建用户界面的前端渐进式的 MVVM 开发框架。\"></a>简单点来说 Vue 是一套用于构建用户界面的前端渐进式的 MVVM 开发框架。</h3><p>前端学无止境 ヾ(ﾟ ∀ ﾟゞ)</p>\n<p>秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)</p>\n<p><font color=\"red\">特别耐斯的小前端</font></p>\n<span id=\"more\"></span>\n\n<h3 id=\"Vue-的生命周期是什么？\"><a href=\"#Vue-的生命周期是什么？\" class=\"headerlink\" title=\"Vue 的生命周期是什么？\"></a>Vue 的生命周期是什么？</h3><p>Vue实例从开始创建、初始化数据、编译模板、挂载dom和渲染、更新和渲染、卸载等一系列过程，这就是Vue的生命周期</p>\n<h3 id=\"Vue-的钩子函数有哪些？\"><a href=\"#Vue-的钩子函数有哪些？\" class=\"headerlink\" title=\"Vue 的钩子函数有哪些？\"></a>Vue 的钩子函数有哪些？</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeforeCreate()  组件实例被创建之初，组件的属性生效之前</span><br><span class=\"line\">created()  组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</span><br><span class=\"line\">BeforeMount()  在挂载开始之前被调用：相关的 render 函数首次被调用</span><br><span class=\"line\">mounted()  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</span><br><span class=\"line\">BeforeUpdate()  组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</span><br><span class=\"line\">updated()  组件数据更新之后</span><br><span class=\"line\">BeforeDestroy()  组件销毁前</span><br><span class=\"line\">destroyed()  组件销毁成功</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Vue-在哪个生命周期内调用异步请求？为什么？\"><a href=\"#Vue-在哪个生命周期内调用异步请求？为什么？\" class=\"headerlink\" title=\"Vue 在哪个生命周期内调用异步请求？为什么？\"></a>Vue 在哪个生命周期内调用异步请求？为什么？</h3><p>可以在created、beforeMount、mounted中调用，因为这三个钩子函数中，data已经创建，可以将服务器返回的数据进行赋值。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在created中用异步请求的优点</span><br><span class=\"line\">    能更快的获取服务器的数据，减少页面加载时间。</span><br><span class=\"line\">    ssr不支持beforeMount、mounted，所以放在created中有助于一致性。</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Vue-组件间通信方式有哪些？\"><a href=\"#Vue-组件间通信方式有哪些？\" class=\"headerlink\" title=\"Vue 组件间通信方式有哪些？\"></a>Vue 组件间通信方式有哪些？</h3><ol>\n<li>父传子 使用 props 属性进行</li>\n<li>字传父 使用事件派发 ($emit)</li>\n<li>非相关组件 使用时间总线(EventBus)</li>\n</ol>\n<h3 id=\"路由的传参方式有哪些？\"><a href=\"#路由的传参方式有哪些？\" class=\"headerlink\" title=\"路由的传参方式有哪些？\"></a>路由的传参方式有哪些？</h3><ol>\n<li>使用进行路由导航，传递参数。</li>\n<li>使用 this.$router.push,通过配置路由属性中的 path 来确定匹配的路由，携带参数进行传参。</li>\n<li>使用 this.$router.push,通过配置路由属性中的 name 来确定匹配的路由，携带参数进行传参。</li>\n<li>使用 path 匹配路由通过 query 传参，query 传参的参数会显示在 url 地址的后面 ?id=……</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Vue-是什么？\"><a href=\"#Vue-是什么？\" class=\"headerlink\" title=\"Vue 是什么？\"></a>Vue 是什么？</h2><p>先放一下 Vue 的官网，多读一读官方文档总是有好处的 ~</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\">Vue 官网 &gt;&gt;</a></p>\n<h3 id=\"简单点来说-Vue-是一套用于构建用户界面的前端渐进式的-MVVM-开发框架。\"><a href=\"#简单点来说-Vue-是一套用于构建用户界面的前端渐进式的-MVVM-开发框架。\" class=\"headerlink\" title=\"简单点来说 Vue 是一套用于构建用户界面的前端渐进式的 MVVM 开发框架。\"></a>简单点来说 Vue 是一套用于构建用户界面的前端渐进式的 MVVM 开发框架。</h3><p>前端学无止境 ヾ(ﾟ ∀ ﾟゞ)</p>\n<p>秃头从未停止 ヾ(ﾟ ∀ ﾟゞ)</p>\n<p><font color=\"red\">特别耐斯的小前端</font></p>","more":"<h3 id=\"Vue-的生命周期是什么？\"><a href=\"#Vue-的生命周期是什么？\" class=\"headerlink\" title=\"Vue 的生命周期是什么？\"></a>Vue 的生命周期是什么？</h3><p>Vue实例从开始创建、初始化数据、编译模板、挂载dom和渲染、更新和渲染、卸载等一系列过程，这就是Vue的生命周期</p>\n<h3 id=\"Vue-的钩子函数有哪些？\"><a href=\"#Vue-的钩子函数有哪些？\" class=\"headerlink\" title=\"Vue 的钩子函数有哪些？\"></a>Vue 的钩子函数有哪些？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeforeCreate()  组件实例被创建之初，组件的属性生效之前</span><br><span class=\"line\">created()  组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</span><br><span class=\"line\">BeforeMount()  在挂载开始之前被调用：相关的 render 函数首次被调用</span><br><span class=\"line\">mounted()  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</span><br><span class=\"line\">BeforeUpdate()  组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</span><br><span class=\"line\">updated()  组件数据更新之后</span><br><span class=\"line\">BeforeDestroy()  组件销毁前</span><br><span class=\"line\">destroyed()  组件销毁成功</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Vue-在哪个生命周期内调用异步请求？为什么？\"><a href=\"#Vue-在哪个生命周期内调用异步请求？为什么？\" class=\"headerlink\" title=\"Vue 在哪个生命周期内调用异步请求？为什么？\"></a>Vue 在哪个生命周期内调用异步请求？为什么？</h3><p>可以在created、beforeMount、mounted中调用，因为这三个钩子函数中，data已经创建，可以将服务器返回的数据进行赋值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在created中用异步请求的优点</span><br><span class=\"line\">    能更快的获取服务器的数据，减少页面加载时间。</span><br><span class=\"line\">    ssr不支持beforeMount、mounted，所以放在created中有助于一致性。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Vue-组件间通信方式有哪些？\"><a href=\"#Vue-组件间通信方式有哪些？\" class=\"headerlink\" title=\"Vue 组件间通信方式有哪些？\"></a>Vue 组件间通信方式有哪些？</h3><ol>\n<li>父传子 使用 props 属性进行</li>\n<li>字传父 使用事件派发 ($emit)</li>\n<li>非相关组件 使用时间总线(EventBus)</li>\n</ol>\n<h3 id=\"路由的传参方式有哪些？\"><a href=\"#路由的传参方式有哪些？\" class=\"headerlink\" title=\"路由的传参方式有哪些？\"></a>路由的传参方式有哪些？</h3><ol>\n<li>使用进行路由导航，传递参数。</li>\n<li>使用 this.$router.push,通过配置路由属性中的 path 来确定匹配的路由，携带参数进行传参。</li>\n<li>使用 this.$router.push,通过配置路由属性中的 name 来确定匹配的路由，携带参数进行传参。</li>\n<li>使用 path 匹配路由通过 query 传参，query 传参的参数会显示在 url 地址的后面 ?id=……</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"关于HTTP","date":"2020-05-20T16:00:00.000Z","_content":"\n### HTTP 概念\n\nHTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求 和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。\n\n<!--more--> \n\n### HTTPS 概念\n\nHTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下层加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。\n\nHTTPS 协议的主要作用可以分为俩种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。\n\n### HTTP 与 HTTPS 有什么区别？\n\nHTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。\n\n```\nHTTP和HTTPS的主要区别如下：\n\n1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。\n\n2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\n\n3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n\n4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n```\n\n---\n\n本文作者： 一只野生东子","source":"_posts/关于HTTP.md","raw":"---\ntitle: 关于HTTP\ndate: 2020-05-21\ntags: HTTP\n---\n\n### HTTP 概念\n\nHTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求 和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。\n\n<!--more--> \n\n### HTTPS 概念\n\nHTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下层加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。\n\nHTTPS 协议的主要作用可以分为俩种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。\n\n### HTTP 与 HTTPS 有什么区别？\n\nHTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。\n\n```\nHTTP和HTTPS的主要区别如下：\n\n1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。\n\n2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\n\n3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n\n4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n```\n\n---\n\n本文作者： 一只野生东子","slug":"关于HTTP","published":1,"updated":"2021-11-26T09:03:13.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2j000l9co36zvf2epj","content":"<h3 id=\"HTTP-概念\"><a href=\"#HTTP-概念\" class=\"headerlink\" title=\"HTTP 概念\"></a>HTTP 概念</h3><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求 和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>\n<span id=\"more\"></span> \n\n<h3 id=\"HTTPS-概念\"><a href=\"#HTTPS-概念\" class=\"headerlink\" title=\"HTTPS 概念\"></a>HTTPS 概念</h3><p>HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下层加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p>\n<p>HTTPS 协议的主要作用可以分为俩种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>\n<h3 id=\"HTTP-与-HTTPS-有什么区别？\"><a href=\"#HTTP-与-HTTPS-有什么区别？\" class=\"headerlink\" title=\"HTTP 与 HTTPS 有什么区别？\"></a>HTTP 与 HTTPS 有什么区别？</h3><p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP和HTTPS的主要区别如下：</span><br><span class=\"line\"></span><br><span class=\"line\">1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</span><br><span class=\"line\"></span><br><span class=\"line\">2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</span><br><span class=\"line\"></span><br><span class=\"line\">3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</span><br><span class=\"line\"></span><br><span class=\"line\">4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"HTTP-概念\"><a href=\"#HTTP-概念\" class=\"headerlink\" title=\"HTTP 概念\"></a>HTTP 概念</h3><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求 和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>","more":"<h3 id=\"HTTPS-概念\"><a href=\"#HTTPS-概念\" class=\"headerlink\" title=\"HTTPS 概念\"></a>HTTPS 概念</h3><p>HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下层加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p>\n<p>HTTPS 协议的主要作用可以分为俩种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>\n<h3 id=\"HTTP-与-HTTPS-有什么区别？\"><a href=\"#HTTP-与-HTTPS-有什么区别？\" class=\"headerlink\" title=\"HTTP 与 HTTPS 有什么区别？\"></a>HTTP 与 HTTPS 有什么区别？</h3><p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP和HTTPS的主要区别如下：</span><br><span class=\"line\"></span><br><span class=\"line\">1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</span><br><span class=\"line\"></span><br><span class=\"line\">2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</span><br><span class=\"line\"></span><br><span class=\"line\">3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</span><br><span class=\"line\"></span><br><span class=\"line\">4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"关于VUEX","date":"2020-07-10T16:00:00.000Z","_content":"\n### 初识 Vuex\n\n### 关于 Vuex\n\n[VUEX官网 > >](https://vuex.vuejs.org/zh/)\n\nVuex 是适用于在 Vue 项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步 data 中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue 为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有 Vuex 的 Vue 项目中，我们只需要把这些值定义在 Vuex 中，即可在整个 Vue 项目的组件中使用。\n\n<!--more--> \n\n### 安装\n\n由于 Vuex 是在学习 VueCli 后进行的，所以在下文出现的项目的目录请参照 VueCli 2.x 构建的目录。\n\n以下步骤的前提是你已经完成了 Vue 项目构建，并且已转至该项目的文件目录下。\n\n* npm 安装 Vuex\n\n```BASH\nnpm i vuex -s\n```\n\n* 在项目的根目录下新增一个store文件夹，在该文件夹内创建 index.js\n  此时你的项目的src文件夹应当是这样的\n\n```\n│  App.vue\n│  main.js\n│\n├─assets\n│      logo.png\n│\n├─components\n│      HelloWorld.vue\n│\n├─router\n│      index.js\n│\n└─store\n       index.js\n```\n\n### 使用\n\n* 初始化 store 下 index.js 中的内容\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\n//挂载Vuex\nVue.use(Vuex)\n\n//创建VueX对象\nconst store = new Vuex.Store({\n    state:{\n        //存放的键值对就是所要管理的状态\n        name:'helloVueX'\n    }\n})\n\nexport default store\n```\n\n* 将 store 挂载到当前项目的 Vue 实例当中去\n  打开 main.js\n\n```vue\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\nimport store from './store'\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  store,  //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中\n  render: h => h(App)\n})\n```\n\n* 在组件中使用Vuex\n  例如在 App.vue 中，我们要将 state 中定义的 name 拿来在 h1 标签中显示\n\n```html\n<template>\n  <div id=\"app\">\n    name:\n    <h1>{{ $store.state.name }}</h1>\n  </div>\n</template>\n```\n\n### 注意，请不要在此处更改state中的状态的值，后文中将会说明\n\n### 安装 Vue 开发工具 VueDevtools\n\n在 Vue 项目开发中，需要监控项目中得各种值，为了提高效率，Vue 提供了一款浏览器扩展——VueDevtools。\n\n在学习 VueX 时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。\n\n### Vuex 中的核心内容\n\n在 Vuex 对象中，其实不止有 state,还有用来操作 state 中数据的方法集，以及当我们需要对 state 中的数据需要加工的方法集等等成员。\n\n成员列表：\n\n* state 存放状态\n* mutations state 成员操作\n* getters 加工 state 成员给外界\n* actions 异步操作\n* modules 模块化状态管理\n\n### Vuex 的工作流程\n\n![Alt text](/images/vuex.jpg)\n\n首先，Vue 组件如果调用某个 Vuex 的方法过程中需要向后端请求时或者说出现异步操作时，需要 dispatch Vuex 中 actions 的方法，以保证数据的同步。可以说，action 的存在就是为了让 mutations 中的方法能在异步操作中起作用。\n\n如果没有异步操作，那么我们就可以直接在组件内提交状态中的Mutations中自己编写的方法来达成对state成员的操作。注意，上文中有提到，不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = 'hello')的话不能被VueDevtools所监控到。\n\n最后被修改后的 state 成员会被渲染到组件的原位置当中去。\n\n### Mutations\n\nmutations是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。\n\n* Mutations 使用方法\n\nMutations 方法都有默认的形参:\n\n```js\n([state], [payload]);\n```\n\n1. state 方法时当前 Vuex 对象中的 state\n2. payload 是该方法在被调用传递参数时使用\n\n例如，我们编写一个方法，当被执行时，能把下例中的 name 值修改为”jack”,我们只需要这样做\n\n```index.js```\n\n```js\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\n\nVue.use(Vuex);\n\nconst store = new Vuex.store({\n  state: {\n    name: \"helloVueX\",\n  },\n  mutations: {\n    //es6语法，等同edit:funcion(){...}\n    edit(state) {\n      state.name = \"jack\";\n    },\n  },\n});\n\nexport default store;\n```\n\n而在组件中，我们需要这样去调用这个mutation——例如在 App.vue 的某个method中:\n\n```js\nthis.$store.commit(\"edit\");\n```\n\n* Mutation 传值\n\n在实际生产过程中，会遇到需要在提交某个 mutation 时需要携带一些参数给方法使用。\n\n单个值提交时:\n\n```js\nthis.$store.commit(\"edit\", 15);\n```\n\n当需要多参提交时，推荐把他们放在一个对象中来提交:\n\n```js\nthis.$store.commit(\"edit\", { age: 15, sex: \"男\" });\n```\n\n接收挂载的参数：\n\n```js\nedit(state,payload){\n    state.name = 'jack'\n    console.log(payload) // 15或{age:15,sex:'男'}\n}\n```\n\n另一种提交方式\n\n```js\nthis.$store.commit({\n  type: \"edit\",\n  payload: {\n    age: 15,\n    sex: \"男\",\n  },\n});\n```\n\n> 增删 state 中的成员\n\n为了配合 Vue 的响应式数据，我们在 Mutations 的方法中，应当使用 Vue 提供的方法来进行操作。如果使用 delete 或者 xx.xx = xx 的形式去删或增，则 Vue 不能对数据进行实时响应。\n\n* Vue.set 为某个对象设置成员的值，若不存在则新增\n\n  例如对 state 对象中添加一个 age 成员\n\n```js\nVue.set(state, \"age\", 15);\n```\n\n> Vue.delete 删除成员\n\n将刚刚添加的 age 成员删除\n\n```js\nVue.delete(state, \"age\");\n```\n\n### Getters\n\n可以对 state 中的成员加工后传递给外界\n\nGetters 中的方法有两个默认参数\n\n* state 当前 Vuex 对象中的状态对象\n* getters当前 getters 对象，用于将 getters 下的其他 getter 拿来用\n\n例如\n\n```js\ngetters:{\n    nameInfo(state){\n        return \"姓名:\"+state.name\n    },\n    fullInfo(state,getters){\n        return getters.nameInfo+'年龄:'+state.age\n    }\n}\n```\n\n组件中调用\n\n```js\nthis.$store.getters.fullInfo;\n```\n\n### Actions\n\n由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。\n\nActions中的方法有两个默认参数\n\n* context 上下文(相当于箭头函数中的 this)对象\n* payload 挂载参数\n\n例如，我们在两秒中后执行mutations传值中的 edit 方法\n\n由于 setTimeout 是异步操作，所以需要使用 actions\n\n```js\nactions:{\n    aEdit(context,payload){\n        setTimeout(()=>{\n            context.commit('edit',payload)\n        },2000)\n    }\n}\n```\n\n在组件中调用:\n\n```\nthis.$store.dispatch(\"aEdit\", { age: 15 });\n```\n\n改进:\n\n由于是异步操作，所以我们可以为我们的异步操作封装为一个Promise对象\n\n```js\n aEdit(context,payload){\n  return new Promise((resolve,reject)=>{\n      setTimeout(()=>{\n          context.commit('edit',payload)\n          resolve()\n      },2000)\n  })\n}\n```\n\n### Models\n\n当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成**模块(module)**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。\n\n```js\nmodels:{\n    a:{\n        state:{},\n        getters:{},\n        ....\n    }\n}\n```\n\n组件内调用模块 a 的状态：\n\n```js\nthis.$store.state.a;\n```\n\n而提交或者dispatch某个方法和以前一样,会自动执行所有模块内的对应type的方法：\n\n```js\nthis.$store.commit(\"editKey\");\nthis.$store.dispatch(\"aEditKey\");\n```\n\n* 模块的细节\n\n> 模块中mutations和getters中的方法接受的第一个参数是自身局部模块内部的state\n\n```js \nmodels:{\n    a:{\n        state:{key:5},\n        mutations:{\n            editKey(state){\n                state.key = 9\n            }\n        },\n        ....\n    }\n}\n``` \n\n> getters中方法的第三个参数是根节点状态\n\n```js\nmodels:{\n    a:{\n        state:{key:5},\n        getters:{\n            getKeyCount(state,getter,rootState){\n                return  rootState.key + state.key\n            }\n        },\n        ....\n    }\n}\n``` \n\n> actions 中方法获取局部模块状态是 context.state,根节点状态是 context.rootState\n\n```js\nmodels:{\n    a:{\n        state:{key:5},\n        actions:{\n            aEidtKey(context){\n                if(context.state.key === context.rootState.key){\n                    context.commit('editKey')\n                }\n            }\n        },\n        ....\n    }\n}\n```\n\n### 规范目录结构\n\n如果把整个store都放在index.js中是不合理的，所以需要拆分。比较合适的目录格式如下：\n\n```\nstore:.\n│  actions.js\n│  getters.js\n│  index.js\n│  mutations.js\n│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入\n│\n└─modules\n        Astore.js\n```\n\n对应的内容存放在对应的文件中，和以前一样，在 index.js 中存放并导出 store。state 中的数据尽量放在 index.js 中。而 modules 中的 Astore 局部模块状态如果多的话也可以进行细分。\n\n---\n\n本文作者： 一只野生东子","source":"_posts/关于vuex.md","raw":"---\ntitle: 关于VUEX\ndate: 2020-07-11\ntags: vuex\n---\n\n### 初识 Vuex\n\n### 关于 Vuex\n\n[VUEX官网 > >](https://vuex.vuejs.org/zh/)\n\nVuex 是适用于在 Vue 项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步 data 中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue 为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有 Vuex 的 Vue 项目中，我们只需要把这些值定义在 Vuex 中，即可在整个 Vue 项目的组件中使用。\n\n<!--more--> \n\n### 安装\n\n由于 Vuex 是在学习 VueCli 后进行的，所以在下文出现的项目的目录请参照 VueCli 2.x 构建的目录。\n\n以下步骤的前提是你已经完成了 Vue 项目构建，并且已转至该项目的文件目录下。\n\n* npm 安装 Vuex\n\n```BASH\nnpm i vuex -s\n```\n\n* 在项目的根目录下新增一个store文件夹，在该文件夹内创建 index.js\n  此时你的项目的src文件夹应当是这样的\n\n```\n│  App.vue\n│  main.js\n│\n├─assets\n│      logo.png\n│\n├─components\n│      HelloWorld.vue\n│\n├─router\n│      index.js\n│\n└─store\n       index.js\n```\n\n### 使用\n\n* 初始化 store 下 index.js 中的内容\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\n//挂载Vuex\nVue.use(Vuex)\n\n//创建VueX对象\nconst store = new Vuex.Store({\n    state:{\n        //存放的键值对就是所要管理的状态\n        name:'helloVueX'\n    }\n})\n\nexport default store\n```\n\n* 将 store 挂载到当前项目的 Vue 实例当中去\n  打开 main.js\n\n```vue\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\nimport store from './store'\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  store,  //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中\n  render: h => h(App)\n})\n```\n\n* 在组件中使用Vuex\n  例如在 App.vue 中，我们要将 state 中定义的 name 拿来在 h1 标签中显示\n\n```html\n<template>\n  <div id=\"app\">\n    name:\n    <h1>{{ $store.state.name }}</h1>\n  </div>\n</template>\n```\n\n### 注意，请不要在此处更改state中的状态的值，后文中将会说明\n\n### 安装 Vue 开发工具 VueDevtools\n\n在 Vue 项目开发中，需要监控项目中得各种值，为了提高效率，Vue 提供了一款浏览器扩展——VueDevtools。\n\n在学习 VueX 时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。\n\n### Vuex 中的核心内容\n\n在 Vuex 对象中，其实不止有 state,还有用来操作 state 中数据的方法集，以及当我们需要对 state 中的数据需要加工的方法集等等成员。\n\n成员列表：\n\n* state 存放状态\n* mutations state 成员操作\n* getters 加工 state 成员给外界\n* actions 异步操作\n* modules 模块化状态管理\n\n### Vuex 的工作流程\n\n![Alt text](/images/vuex.jpg)\n\n首先，Vue 组件如果调用某个 Vuex 的方法过程中需要向后端请求时或者说出现异步操作时，需要 dispatch Vuex 中 actions 的方法，以保证数据的同步。可以说，action 的存在就是为了让 mutations 中的方法能在异步操作中起作用。\n\n如果没有异步操作，那么我们就可以直接在组件内提交状态中的Mutations中自己编写的方法来达成对state成员的操作。注意，上文中有提到，不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = 'hello')的话不能被VueDevtools所监控到。\n\n最后被修改后的 state 成员会被渲染到组件的原位置当中去。\n\n### Mutations\n\nmutations是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。\n\n* Mutations 使用方法\n\nMutations 方法都有默认的形参:\n\n```js\n([state], [payload]);\n```\n\n1. state 方法时当前 Vuex 对象中的 state\n2. payload 是该方法在被调用传递参数时使用\n\n例如，我们编写一个方法，当被执行时，能把下例中的 name 值修改为”jack”,我们只需要这样做\n\n```index.js```\n\n```js\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\n\nVue.use(Vuex);\n\nconst store = new Vuex.store({\n  state: {\n    name: \"helloVueX\",\n  },\n  mutations: {\n    //es6语法，等同edit:funcion(){...}\n    edit(state) {\n      state.name = \"jack\";\n    },\n  },\n});\n\nexport default store;\n```\n\n而在组件中，我们需要这样去调用这个mutation——例如在 App.vue 的某个method中:\n\n```js\nthis.$store.commit(\"edit\");\n```\n\n* Mutation 传值\n\n在实际生产过程中，会遇到需要在提交某个 mutation 时需要携带一些参数给方法使用。\n\n单个值提交时:\n\n```js\nthis.$store.commit(\"edit\", 15);\n```\n\n当需要多参提交时，推荐把他们放在一个对象中来提交:\n\n```js\nthis.$store.commit(\"edit\", { age: 15, sex: \"男\" });\n```\n\n接收挂载的参数：\n\n```js\nedit(state,payload){\n    state.name = 'jack'\n    console.log(payload) // 15或{age:15,sex:'男'}\n}\n```\n\n另一种提交方式\n\n```js\nthis.$store.commit({\n  type: \"edit\",\n  payload: {\n    age: 15,\n    sex: \"男\",\n  },\n});\n```\n\n> 增删 state 中的成员\n\n为了配合 Vue 的响应式数据，我们在 Mutations 的方法中，应当使用 Vue 提供的方法来进行操作。如果使用 delete 或者 xx.xx = xx 的形式去删或增，则 Vue 不能对数据进行实时响应。\n\n* Vue.set 为某个对象设置成员的值，若不存在则新增\n\n  例如对 state 对象中添加一个 age 成员\n\n```js\nVue.set(state, \"age\", 15);\n```\n\n> Vue.delete 删除成员\n\n将刚刚添加的 age 成员删除\n\n```js\nVue.delete(state, \"age\");\n```\n\n### Getters\n\n可以对 state 中的成员加工后传递给外界\n\nGetters 中的方法有两个默认参数\n\n* state 当前 Vuex 对象中的状态对象\n* getters当前 getters 对象，用于将 getters 下的其他 getter 拿来用\n\n例如\n\n```js\ngetters:{\n    nameInfo(state){\n        return \"姓名:\"+state.name\n    },\n    fullInfo(state,getters){\n        return getters.nameInfo+'年龄:'+state.age\n    }\n}\n```\n\n组件中调用\n\n```js\nthis.$store.getters.fullInfo;\n```\n\n### Actions\n\n由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。\n\nActions中的方法有两个默认参数\n\n* context 上下文(相当于箭头函数中的 this)对象\n* payload 挂载参数\n\n例如，我们在两秒中后执行mutations传值中的 edit 方法\n\n由于 setTimeout 是异步操作，所以需要使用 actions\n\n```js\nactions:{\n    aEdit(context,payload){\n        setTimeout(()=>{\n            context.commit('edit',payload)\n        },2000)\n    }\n}\n```\n\n在组件中调用:\n\n```\nthis.$store.dispatch(\"aEdit\", { age: 15 });\n```\n\n改进:\n\n由于是异步操作，所以我们可以为我们的异步操作封装为一个Promise对象\n\n```js\n aEdit(context,payload){\n  return new Promise((resolve,reject)=>{\n      setTimeout(()=>{\n          context.commit('edit',payload)\n          resolve()\n      },2000)\n  })\n}\n```\n\n### Models\n\n当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成**模块(module)**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。\n\n```js\nmodels:{\n    a:{\n        state:{},\n        getters:{},\n        ....\n    }\n}\n```\n\n组件内调用模块 a 的状态：\n\n```js\nthis.$store.state.a;\n```\n\n而提交或者dispatch某个方法和以前一样,会自动执行所有模块内的对应type的方法：\n\n```js\nthis.$store.commit(\"editKey\");\nthis.$store.dispatch(\"aEditKey\");\n```\n\n* 模块的细节\n\n> 模块中mutations和getters中的方法接受的第一个参数是自身局部模块内部的state\n\n```js \nmodels:{\n    a:{\n        state:{key:5},\n        mutations:{\n            editKey(state){\n                state.key = 9\n            }\n        },\n        ....\n    }\n}\n``` \n\n> getters中方法的第三个参数是根节点状态\n\n```js\nmodels:{\n    a:{\n        state:{key:5},\n        getters:{\n            getKeyCount(state,getter,rootState){\n                return  rootState.key + state.key\n            }\n        },\n        ....\n    }\n}\n``` \n\n> actions 中方法获取局部模块状态是 context.state,根节点状态是 context.rootState\n\n```js\nmodels:{\n    a:{\n        state:{key:5},\n        actions:{\n            aEidtKey(context){\n                if(context.state.key === context.rootState.key){\n                    context.commit('editKey')\n                }\n            }\n        },\n        ....\n    }\n}\n```\n\n### 规范目录结构\n\n如果把整个store都放在index.js中是不合理的，所以需要拆分。比较合适的目录格式如下：\n\n```\nstore:.\n│  actions.js\n│  getters.js\n│  index.js\n│  mutations.js\n│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入\n│\n└─modules\n        Astore.js\n```\n\n对应的内容存放在对应的文件中，和以前一样，在 index.js 中存放并导出 store。state 中的数据尽量放在 index.js 中。而 modules 中的 Astore 局部模块状态如果多的话也可以进行细分。\n\n---\n\n本文作者： 一只野生东子","slug":"关于vuex","published":1,"updated":"2021-11-26T09:30:06.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2k000m9co326pj7omv","content":"<h3 id=\"初识-Vuex\"><a href=\"#初识-Vuex\" class=\"headerlink\" title=\"初识 Vuex\"></a>初识 Vuex</h3><h3 id=\"关于-Vuex\"><a href=\"#关于-Vuex\" class=\"headerlink\" title=\"关于 Vuex\"></a>关于 Vuex</h3><p><a href=\"https://vuex.vuejs.org/zh/\">VUEX官网 &gt; &gt;</a></p>\n<p>Vuex 是适用于在 Vue 项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步 data 中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue 为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有 Vuex 的 Vue 项目中，我们只需要把这些值定义在 Vuex 中，即可在整个 Vue 项目的组件中使用。</p>\n<span id=\"more\"></span> \n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>由于 Vuex 是在学习 VueCli 后进行的，所以在下文出现的项目的目录请参照 VueCli 2.x 构建的目录。</p>\n<p>以下步骤的前提是你已经完成了 Vue 项目构建，并且已转至该项目的文件目录下。</p>\n<ul>\n<li>npm 安装 Vuex</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight /bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i vuex -s</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>在项目的根目录下新增一个store文件夹，在该文件夹内创建 index.js<br>此时你的项目的src文件夹应当是这样的</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│  App.vue</span><br><span class=\"line\">│  main.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─assets</span><br><span class=\"line\">│      logo.png</span><br><span class=\"line\">│</span><br><span class=\"line\">├─components</span><br><span class=\"line\">│      HelloWorld.vue</span><br><span class=\"line\">│</span><br><span class=\"line\">├─router</span><br><span class=\"line\">│      index.js</span><br><span class=\"line\">│</span><br><span class=\"line\">└─store</span><br><span class=\"line\">       index.js</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>初始化 store 下 index.js 中的内容</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import Vuex from &#x27;vuex&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">//挂载Vuex</span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\">//创建VueX对象</span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">    state:&#123;</span><br><span class=\"line\">        //存放的键值对就是所要管理的状态</span><br><span class=\"line\">        name:&#x27;helloVueX&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default store</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>将 store 挂载到当前项目的 Vue 实例当中去<br>打开 main.js</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">import store from &#x27;./store&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = false</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store,  //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span><br><span class=\"line\">  render: h =&gt; h(App)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>在组件中使用Vuex<br>例如在 App.vue 中，我们要将 state 中定义的 name 拿来在 h1 标签中显示</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    name:</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"注意，请不要在此处更改state中的状态的值，后文中将会说明\"><a href=\"#注意，请不要在此处更改state中的状态的值，后文中将会说明\" class=\"headerlink\" title=\"注意，请不要在此处更改state中的状态的值，后文中将会说明\"></a>注意，请不要在此处更改state中的状态的值，后文中将会说明</h3><h3 id=\"安装-Vue-开发工具-VueDevtools\"><a href=\"#安装-Vue-开发工具-VueDevtools\" class=\"headerlink\" title=\"安装 Vue 开发工具 VueDevtools\"></a>安装 Vue 开发工具 VueDevtools</h3><p>在 Vue 项目开发中，需要监控项目中得各种值，为了提高效率，Vue 提供了一款浏览器扩展——VueDevtools。</p>\n<p>在学习 VueX 时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。</p>\n<h3 id=\"Vuex-中的核心内容\"><a href=\"#Vuex-中的核心内容\" class=\"headerlink\" title=\"Vuex 中的核心内容\"></a>Vuex 中的核心内容</h3><p>在 Vuex 对象中，其实不止有 state,还有用来操作 state 中数据的方法集，以及当我们需要对 state 中的数据需要加工的方法集等等成员。</p>\n<p>成员列表：</p>\n<ul>\n<li>state 存放状态</li>\n<li>mutations state 成员操作</li>\n<li>getters 加工 state 成员给外界</li>\n<li>actions 异步操作</li>\n<li>modules 模块化状态管理</li>\n</ul>\n<h3 id=\"Vuex-的工作流程\"><a href=\"#Vuex-的工作流程\" class=\"headerlink\" title=\"Vuex 的工作流程\"></a>Vuex 的工作流程</h3><p><img src=\"/images/vuex.jpg\" alt=\"Alt text\"></p>\n<p>首先，Vue 组件如果调用某个 Vuex 的方法过程中需要向后端请求时或者说出现异步操作时，需要 dispatch Vuex 中 actions 的方法，以保证数据的同步。可以说，action 的存在就是为了让 mutations 中的方法能在异步操作中起作用。</p>\n<p>如果没有异步操作，那么我们就可以直接在组件内提交状态中的Mutations中自己编写的方法来达成对state成员的操作。注意，上文中有提到，不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = ‘hello’)的话不能被VueDevtools所监控到。</p>\n<p>最后被修改后的 state 成员会被渲染到组件的原位置当中去。</p>\n<h3 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h3><p>mutations是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。</p>\n<ul>\n<li>Mutations 使用方法</li>\n</ul>\n<p>Mutations 方法都有默认的形参:</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([state], [payload]);</span><br></pre></td></tr></table></figure></div>\n\n<ol>\n<li>state 方法时当前 Vuex 对象中的 state</li>\n<li>payload 是该方法在被调用传递参数时使用</li>\n</ol>\n<p>例如，我们编写一个方法，当被执行时，能把下例中的 name 值修改为”jack”,我们只需要这样做</p>\n<p><code>index.js</code></p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">&quot;vuex&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.store(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;helloVueX&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//es6语法，等同edit:funcion()&#123;...&#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">edit</span>(<span class=\"params\">state</span>)</span> &#123;</span><br><span class=\"line\">      state.name = <span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure></div>\n\n<p>而在组件中，我们需要这样去调用这个mutation——例如在 App.vue 的某个method中:</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;edit&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>Mutation 传值</li>\n</ul>\n<p>在实际生产过程中，会遇到需要在提交某个 mutation 时需要携带一些参数给方法使用。</p>\n<p>单个值提交时:</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;edit&quot;</span>, <span class=\"number\">15</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p>当需要多参提交时，推荐把他们放在一个对象中来提交:</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;edit&quot;</span>, &#123; <span class=\"attr\">age</span>: <span class=\"number\">15</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&quot;男&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p>接收挂载的参数：</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">edit</span>(<span class=\"params\">state,payload</span>)</span>&#123;</span><br><span class=\"line\">    state.name = <span class=\"string\">&#x27;jack&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(payload) <span class=\"comment\">// 15或&#123;age:15,sex:&#x27;男&#x27;&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>另一种提交方式</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;edit&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">payload</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">15</span>,</span><br><span class=\"line\">    <span class=\"attr\">sex</span>: <span class=\"string\">&quot;男&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>增删 state 中的成员</p>\n</blockquote>\n<p>为了配合 Vue 的响应式数据，我们在 Mutations 的方法中，应当使用 Vue 提供的方法来进行操作。如果使用 delete 或者 xx.xx = xx 的形式去删或增，则 Vue 不能对数据进行实时响应。</p>\n<ul>\n<li><p>Vue.set 为某个对象设置成员的值，若不存在则新增</p>\n<p>例如对 state 对象中添加一个 age 成员</p>\n</li>\n</ul>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.set(state, <span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">15</span>);</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>Vue.delete 删除成员</p>\n</blockquote>\n<p>将刚刚添加的 age 成员删除</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.delete(state, <span class=\"string\">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>可以对 state 中的成员加工后传递给外界</p>\n<p>Getters 中的方法有两个默认参数</p>\n<ul>\n<li>state 当前 Vuex 对象中的状态对象</li>\n<li>getters当前 getters 对象，用于将 getters 下的其他 getter 拿来用</li>\n</ul>\n<p>例如</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters:&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">nameInfo</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;姓名:&quot;</span>+state.name</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">fullInfo</span>(<span class=\"params\">state,getters</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getters.nameInfo+<span class=\"string\">&#x27;年龄:&#x27;</span>+state.age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>组件中调用</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.getters.fullInfo;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。</p>\n<p>Actions中的方法有两个默认参数</p>\n<ul>\n<li>context 上下文(相当于箭头函数中的 this)对象</li>\n<li>payload 挂载参数</li>\n</ul>\n<p>例如，我们在两秒中后执行mutations传值中的 edit 方法</p>\n<p>由于 setTimeout 是异步操作，所以需要使用 actions</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions:&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">aEdit</span>(<span class=\"params\">context,payload</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            context.commit(<span class=\"string\">&#x27;edit&#x27;</span>,payload)</span><br><span class=\"line\">        &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>在组件中调用:</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.dispatch(&quot;aEdit&quot;, &#123; age: 15 &#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p>改进:</p>\n<p>由于是异步操作，所以我们可以为我们的异步操作封装为一个Promise对象</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"title\">aEdit</span>(<span class=\"params\">context,payload</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">          context.commit(<span class=\"string\">&#x27;edit&#x27;</span>,payload)</span><br><span class=\"line\">          resolve()</span><br><span class=\"line\">      &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Models\"><a href=\"#Models\" class=\"headerlink\" title=\"Models\"></a>Models</h3><p>当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成**模块(module)**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;&#125;,</span><br><span class=\"line\">        <span class=\"attr\">getters</span>:&#123;&#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>组件内调用模块 a 的状态：</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.state.a;</span><br></pre></td></tr></table></figure></div>\n\n<p>而提交或者dispatch某个方法和以前一样,会自动执行所有模块内的对应type的方法：</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;editKey&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">this</span>.$store.dispatch(<span class=\"string\">&quot;aEditKey&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>模块的细节</li>\n</ul>\n<blockquote>\n<p>模块中mutations和getters中的方法接受的第一个参数是自身局部模块内部的state</p>\n</blockquote>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;<span class=\"attr\">key</span>:<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        <span class=\"attr\">mutations</span>:&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">editKey</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">                state.key = <span class=\"number\">9</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>getters中方法的第三个参数是根节点状态</p>\n</blockquote>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;<span class=\"attr\">key</span>:<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        <span class=\"attr\">getters</span>:&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">getKeyCount</span>(<span class=\"params\">state,getter,rootState</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>  rootState.key + state.key</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>actions 中方法获取局部模块状态是 context.state,根节点状态是 context.rootState</p>\n</blockquote>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;<span class=\"attr\">key</span>:<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        <span class=\"attr\">actions</span>:&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">aEidtKey</span>(<span class=\"params\">context</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(context.state.key === context.rootState.key)&#123;</span><br><span class=\"line\">                    context.commit(<span class=\"string\">&#x27;editKey&#x27;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"规范目录结构\"><a href=\"#规范目录结构\" class=\"headerlink\" title=\"规范目录结构\"></a>规范目录结构</h3><p>如果把整个store都放在index.js中是不合理的，所以需要拆分。比较合适的目录格式如下：</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight /plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store:.</span><br><span class=\"line\">│  actions.js</span><br><span class=\"line\">│  getters.js</span><br><span class=\"line\">│  index.js</span><br><span class=\"line\">│  mutations.js</span><br><span class=\"line\">│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入</span><br><span class=\"line\">│</span><br><span class=\"line\">└─modules</span><br><span class=\"line\">        Astore.js</span><br></pre></td></tr></table></figure></div>\n\n<p>对应的内容存放在对应的文件中，和以前一样，在 index.js 中存放并导出 store。state 中的数据尽量放在 index.js 中。而 modules 中的 Astore 局部模块状态如果多的话也可以进行细分。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"初识-Vuex\"><a href=\"#初识-Vuex\" class=\"headerlink\" title=\"初识 Vuex\"></a>初识 Vuex</h3><h3 id=\"关于-Vuex\"><a href=\"#关于-Vuex\" class=\"headerlink\" title=\"关于 Vuex\"></a>关于 Vuex</h3><p><a href=\"https://vuex.vuejs.org/zh/\">VUEX官网 &gt; &gt;</a></p>\n<p>Vuex 是适用于在 Vue 项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步 data 中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue 为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有 Vuex 的 Vue 项目中，我们只需要把这些值定义在 Vuex 中，即可在整个 Vue 项目的组件中使用。</p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>由于 Vuex 是在学习 VueCli 后进行的，所以在下文出现的项目的目录请参照 VueCli 2.x 构建的目录。</p>\n<p>以下步骤的前提是你已经完成了 Vue 项目构建，并且已转至该项目的文件目录下。</p>\n<ul>\n<li>npm 安装 Vuex</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i vuex -s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在项目的根目录下新增一个store文件夹，在该文件夹内创建 index.js<br>此时你的项目的src文件夹应当是这样的</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│  App.vue</span><br><span class=\"line\">│  main.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─assets</span><br><span class=\"line\">│      logo.png</span><br><span class=\"line\">│</span><br><span class=\"line\">├─components</span><br><span class=\"line\">│      HelloWorld.vue</span><br><span class=\"line\">│</span><br><span class=\"line\">├─router</span><br><span class=\"line\">│      index.js</span><br><span class=\"line\">│</span><br><span class=\"line\">└─store</span><br><span class=\"line\">       index.js</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>初始化 store 下 index.js 中的内容</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import Vuex from &#x27;vuex&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">//挂载Vuex</span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\">//创建VueX对象</span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">    state:&#123;</span><br><span class=\"line\">        //存放的键值对就是所要管理的状态</span><br><span class=\"line\">        name:&#x27;helloVueX&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default store</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将 store 挂载到当前项目的 Vue 实例当中去<br>打开 main.js</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">import store from &#x27;./store&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = false</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store,  //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span><br><span class=\"line\">  render: h =&gt; h(App)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在组件中使用Vuex<br>例如在 App.vue 中，我们要将 state 中定义的 name 拿来在 h1 标签中显示</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    name:</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意，请不要在此处更改state中的状态的值，后文中将会说明\"><a href=\"#注意，请不要在此处更改state中的状态的值，后文中将会说明\" class=\"headerlink\" title=\"注意，请不要在此处更改state中的状态的值，后文中将会说明\"></a>注意，请不要在此处更改state中的状态的值，后文中将会说明</h3><h3 id=\"安装-Vue-开发工具-VueDevtools\"><a href=\"#安装-Vue-开发工具-VueDevtools\" class=\"headerlink\" title=\"安装 Vue 开发工具 VueDevtools\"></a>安装 Vue 开发工具 VueDevtools</h3><p>在 Vue 项目开发中，需要监控项目中得各种值，为了提高效率，Vue 提供了一款浏览器扩展——VueDevtools。</p>\n<p>在学习 VueX 时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。</p>\n<h3 id=\"Vuex-中的核心内容\"><a href=\"#Vuex-中的核心内容\" class=\"headerlink\" title=\"Vuex 中的核心内容\"></a>Vuex 中的核心内容</h3><p>在 Vuex 对象中，其实不止有 state,还有用来操作 state 中数据的方法集，以及当我们需要对 state 中的数据需要加工的方法集等等成员。</p>\n<p>成员列表：</p>\n<ul>\n<li>state 存放状态</li>\n<li>mutations state 成员操作</li>\n<li>getters 加工 state 成员给外界</li>\n<li>actions 异步操作</li>\n<li>modules 模块化状态管理</li>\n</ul>\n<h3 id=\"Vuex-的工作流程\"><a href=\"#Vuex-的工作流程\" class=\"headerlink\" title=\"Vuex 的工作流程\"></a>Vuex 的工作流程</h3><p><img src=\"/images/vuex.jpg\" alt=\"Alt text\"></p>\n<p>首先，Vue 组件如果调用某个 Vuex 的方法过程中需要向后端请求时或者说出现异步操作时，需要 dispatch Vuex 中 actions 的方法，以保证数据的同步。可以说，action 的存在就是为了让 mutations 中的方法能在异步操作中起作用。</p>\n<p>如果没有异步操作，那么我们就可以直接在组件内提交状态中的Mutations中自己编写的方法来达成对state成员的操作。注意，上文中有提到，不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = ‘hello’)的话不能被VueDevtools所监控到。</p>\n<p>最后被修改后的 state 成员会被渲染到组件的原位置当中去。</p>\n<h3 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h3><p>mutations是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。</p>\n<ul>\n<li>Mutations 使用方法</li>\n</ul>\n<p>Mutations 方法都有默认的形参:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([state], [payload]);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>state 方法时当前 Vuex 对象中的 state</li>\n<li>payload 是该方法在被调用传递参数时使用</li>\n</ol>\n<p>例如，我们编写一个方法，当被执行时，能把下例中的 name 值修改为”jack”,我们只需要这样做</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">&quot;vuex&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.store(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;helloVueX&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//es6语法，等同edit:funcion()&#123;...&#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">edit</span>(<span class=\"params\">state</span>)</span> &#123;</span><br><span class=\"line\">      state.name = <span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n\n<p>而在组件中，我们需要这样去调用这个mutation——例如在 App.vue 的某个method中:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;edit&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Mutation 传值</li>\n</ul>\n<p>在实际生产过程中，会遇到需要在提交某个 mutation 时需要携带一些参数给方法使用。</p>\n<p>单个值提交时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;edit&quot;</span>, <span class=\"number\">15</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当需要多参提交时，推荐把他们放在一个对象中来提交:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;edit&quot;</span>, &#123; <span class=\"attr\">age</span>: <span class=\"number\">15</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&quot;男&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>接收挂载的参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">edit</span>(<span class=\"params\">state,payload</span>)</span>&#123;</span><br><span class=\"line\">    state.name = <span class=\"string\">&#x27;jack&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(payload) <span class=\"comment\">// 15或&#123;age:15,sex:&#x27;男&#x27;&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一种提交方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;edit&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">payload</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">15</span>,</span><br><span class=\"line\">    <span class=\"attr\">sex</span>: <span class=\"string\">&quot;男&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>增删 state 中的成员</p>\n</blockquote>\n<p>为了配合 Vue 的响应式数据，我们在 Mutations 的方法中，应当使用 Vue 提供的方法来进行操作。如果使用 delete 或者 xx.xx = xx 的形式去删或增，则 Vue 不能对数据进行实时响应。</p>\n<ul>\n<li><p>Vue.set 为某个对象设置成员的值，若不存在则新增</p>\n<p>例如对 state 对象中添加一个 age 成员</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.set(state, <span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">15</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Vue.delete 删除成员</p>\n</blockquote>\n<p>将刚刚添加的 age 成员删除</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.delete(state, <span class=\"string\">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>可以对 state 中的成员加工后传递给外界</p>\n<p>Getters 中的方法有两个默认参数</p>\n<ul>\n<li>state 当前 Vuex 对象中的状态对象</li>\n<li>getters当前 getters 对象，用于将 getters 下的其他 getter 拿来用</li>\n</ul>\n<p>例如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters:&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">nameInfo</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;姓名:&quot;</span>+state.name</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">fullInfo</span>(<span class=\"params\">state,getters</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getters.nameInfo+<span class=\"string\">&#x27;年龄:&#x27;</span>+state.age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组件中调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.getters.fullInfo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。</p>\n<p>Actions中的方法有两个默认参数</p>\n<ul>\n<li>context 上下文(相当于箭头函数中的 this)对象</li>\n<li>payload 挂载参数</li>\n</ul>\n<p>例如，我们在两秒中后执行mutations传值中的 edit 方法</p>\n<p>由于 setTimeout 是异步操作，所以需要使用 actions</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions:&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">aEdit</span>(<span class=\"params\">context,payload</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            context.commit(<span class=\"string\">&#x27;edit&#x27;</span>,payload)</span><br><span class=\"line\">        &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在组件中调用:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.dispatch(&quot;aEdit&quot;, &#123; age: 15 &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>改进:</p>\n<p>由于是异步操作，所以我们可以为我们的异步操作封装为一个Promise对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"title\">aEdit</span>(<span class=\"params\">context,payload</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">          context.commit(<span class=\"string\">&#x27;edit&#x27;</span>,payload)</span><br><span class=\"line\">          resolve()</span><br><span class=\"line\">      &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Models\"><a href=\"#Models\" class=\"headerlink\" title=\"Models\"></a>Models</h3><p>当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成**模块(module)**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;&#125;,</span><br><span class=\"line\">        <span class=\"attr\">getters</span>:&#123;&#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组件内调用模块 a 的状态：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.state.a;</span><br></pre></td></tr></table></figure>\n\n<p>而提交或者dispatch某个方法和以前一样,会自动执行所有模块内的对应type的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&quot;editKey&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">this</span>.$store.dispatch(<span class=\"string\">&quot;aEditKey&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>模块的细节</li>\n</ul>\n<blockquote>\n<p>模块中mutations和getters中的方法接受的第一个参数是自身局部模块内部的state</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;<span class=\"attr\">key</span>:<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        <span class=\"attr\">mutations</span>:&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">editKey</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">                state.key = <span class=\"number\">9</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>getters中方法的第三个参数是根节点状态</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;<span class=\"attr\">key</span>:<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        <span class=\"attr\">getters</span>:&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">getKeyCount</span>(<span class=\"params\">state,getter,rootState</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>  rootState.key + state.key</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>actions 中方法获取局部模块状态是 context.state,根节点状态是 context.rootState</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">models:&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">state</span>:&#123;<span class=\"attr\">key</span>:<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        <span class=\"attr\">actions</span>:&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">aEidtKey</span>(<span class=\"params\">context</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(context.state.key === context.rootState.key)&#123;</span><br><span class=\"line\">                    context.commit(<span class=\"string\">&#x27;editKey&#x27;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"规范目录结构\"><a href=\"#规范目录结构\" class=\"headerlink\" title=\"规范目录结构\"></a>规范目录结构</h3><p>如果把整个store都放在index.js中是不合理的，所以需要拆分。比较合适的目录格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store:.</span><br><span class=\"line\">│  actions.js</span><br><span class=\"line\">│  getters.js</span><br><span class=\"line\">│  index.js</span><br><span class=\"line\">│  mutations.js</span><br><span class=\"line\">│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入</span><br><span class=\"line\">│</span><br><span class=\"line\">└─modules</span><br><span class=\"line\">        Astore.js</span><br></pre></td></tr></table></figure>\n\n<p>对应的内容存放在对应的文件中，和以前一样，在 index.js 中存放并导出 store。state 中的数据尽量放在 index.js 中。而 modules 中的 Astore 局部模块状态如果多的话也可以进行细分。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"关于闭包","date":"2020-04-17T16:00:00.000Z","_content":" \n\n### 什么是闭包\n\n闭包就是能够读取其他函数内部变量的函数。在 JS 中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为”定义在一个函数内部的函数”。\n\n<!--more--> \n\n```js\nfunction fn() {\n  var b = 1;\n\n  //闭包\n  function box() {\n    //\n    console.log(b);\n  }\n\n  //返回一个函数，这个函数就是一个闭包\n  return box;\n}\n\n//res 就是 box 函数\nvar res = fn();\n\n//2秒以后调用res函数，还是能打印b的值,闭包能让局部变量常驻内存\nsetTimeout(function () {\n  res();\n}, 2000);\n```\n\n### 闭包的特点\n\n1. 可以读取函数内部的变量。\n   变量的作用域无非就是两种：全局变量和局部变量。\n   JS 语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，函数外部自然无法读取函数内的局部变量。\n2. 让这些变量的值始终保存在内存中。\n\n### 闭包的应用场景\n\n1. 函数作为返回值。\n\n```js\nfunction box() {\n  var n = 1; //\n  function cox() {\n    n++;\n    return n;\n  }\n\n  return cox;\n}\n//res 就是一个闭包 ，n像是一个全局变量\nvar res = box();\n\nconsole.log(res()); //2\nconsole.log(res()); //3\n```\n\n2. 函数作为参数被传递\n   回调函数\n\n### 闭包深度解析参考\n阮一峰博客：[学习 Javascript 闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n\n---\n\n本文作者： 一只野生东子","source":"_posts/关于闭包.md","raw":"---\ntitle: 关于闭包\ndate: 2020-04-18\ntags: javaScript\n--- \n\n### 什么是闭包\n\n闭包就是能够读取其他函数内部变量的函数。在 JS 中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为”定义在一个函数内部的函数”。\n\n<!--more--> \n\n```js\nfunction fn() {\n  var b = 1;\n\n  //闭包\n  function box() {\n    //\n    console.log(b);\n  }\n\n  //返回一个函数，这个函数就是一个闭包\n  return box;\n}\n\n//res 就是 box 函数\nvar res = fn();\n\n//2秒以后调用res函数，还是能打印b的值,闭包能让局部变量常驻内存\nsetTimeout(function () {\n  res();\n}, 2000);\n```\n\n### 闭包的特点\n\n1. 可以读取函数内部的变量。\n   变量的作用域无非就是两种：全局变量和局部变量。\n   JS 语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，函数外部自然无法读取函数内的局部变量。\n2. 让这些变量的值始终保存在内存中。\n\n### 闭包的应用场景\n\n1. 函数作为返回值。\n\n```js\nfunction box() {\n  var n = 1; //\n  function cox() {\n    n++;\n    return n;\n  }\n\n  return cox;\n}\n//res 就是一个闭包 ，n像是一个全局变量\nvar res = box();\n\nconsole.log(res()); //2\nconsole.log(res()); //3\n```\n\n2. 函数作为参数被传递\n   回调函数\n\n### 闭包深度解析参考\n阮一峰博客：[学习 Javascript 闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n\n---\n\n本文作者： 一只野生东子","slug":"关于闭包","published":1,"updated":"2021-11-29T03:40:53.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2l000p9co36i3992oa","content":"<h3 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h3><p>闭包就是能够读取其他函数内部变量的函数。在 JS 中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为”定义在一个函数内部的函数”。</p>\n<span id=\"more\"></span> \n\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//闭包</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">box</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//返回一个函数，这个函数就是一个闭包</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//res 就是 box 函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = fn();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2秒以后调用res函数，还是能打印b的值,闭包能让局部变量常驻内存</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  res();</span><br><span class=\"line\">&#125;, <span class=\"number\">2000</span>);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"闭包的特点\"><a href=\"#闭包的特点\" class=\"headerlink\" title=\"闭包的特点\"></a>闭包的特点</h3><ol>\n<li>可以读取函数内部的变量。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>JS 语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，函数外部自然无法读取函数内的局部变量。</li>\n<li>让这些变量的值始终保存在内存中。</li>\n</ol>\n<h3 id=\"闭包的应用场景\"><a href=\"#闭包的应用场景\" class=\"headerlink\" title=\"闭包的应用场景\"></a>闭包的应用场景</h3><ol>\n<li>函数作为返回值。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">box</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">1</span>; <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cox</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    n++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cox;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//res 就是一个闭包 ，n像是一个全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = box();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res()); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res()); <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>函数作为参数被传递<br>回调函数</li>\n</ol>\n<h3 id=\"闭包深度解析参考\"><a href=\"#闭包深度解析参考\" class=\"headerlink\" title=\"闭包深度解析参考\"></a>闭包深度解析参考</h3><p>阮一峰博客：<a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\">学习 Javascript 闭包（Closure）</a></p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h3><p>闭包就是能够读取其他函数内部变量的函数。在 JS 中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为”定义在一个函数内部的函数”。</p>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//闭包</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">box</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//返回一个函数，这个函数就是一个闭包</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//res 就是 box 函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = fn();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2秒以后调用res函数，还是能打印b的值,闭包能让局部变量常驻内存</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  res();</span><br><span class=\"line\">&#125;, <span class=\"number\">2000</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"闭包的特点\"><a href=\"#闭包的特点\" class=\"headerlink\" title=\"闭包的特点\"></a>闭包的特点</h3><ol>\n<li>可以读取函数内部的变量。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>JS 语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，函数外部自然无法读取函数内的局部变量。</li>\n<li>让这些变量的值始终保存在内存中。</li>\n</ol>\n<h3 id=\"闭包的应用场景\"><a href=\"#闭包的应用场景\" class=\"headerlink\" title=\"闭包的应用场景\"></a>闭包的应用场景</h3><ol>\n<li>函数作为返回值。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">box</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">1</span>; <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cox</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    n++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cox;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//res 就是一个闭包 ，n像是一个全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = box();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res()); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res()); <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>函数作为参数被传递<br>回调函数</li>\n</ol>\n<h3 id=\"闭包深度解析参考\"><a href=\"#闭包深度解析参考\" class=\"headerlink\" title=\"闭包深度解析参考\"></a>闭包深度解析参考</h3><p>阮一峰博客：<a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\">学习 Javascript 闭包（Closure）</a></p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"函数","date":"2019-10-23T16:00:00.000Z","_content":"\n### 函数的概念\n\n函数是一段可以反复调用的代码块。\n\n作用\n在程序设计中，常将一些常用的功能模块编写成函数，以减少重复编写程序段的工作量。\n提高代码的复用性、可读性等\n\n<!--more--> \n\n### 函数的创建方式（函数的声明）\n\n1. function 命令\n   function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号。函数体放在大括号里面。\n   function 函数名称() {\n      函数中要执行的代码;\n   }\n\n```js\nfunction print() {\n  console.log(1);\n}\n```\n\n上面的代码命名了一个 print 函数，以后使用 print()这种形式，就可以调用相应的代码。这叫做函数的声明\n\n2. 函数表达式\n   除了用 function 命令声明函数，还可以采用变量赋值的写法。\n\n```js\nlet print = function () {\n  console.log(1);\n};\n```\n\n这种写法将一个匿名函数（没有名字的函数）赋值给变量。这时，这个匿名函数又称函数表达式\n\n### 函数的执行(调用)\n\n函数定义好之后，函数中的代码在程序运行过程中不会执行；\n\n```js\nfunction print() {\n  console.log(1);\n}\nprint();\n```\n\n### 事件的概念种类\n\n事件：就是发生的事情\n事件驱动：就是发生了某件事情之后要处理的手段和过程\n\n1. 鼠标事件\n   onclick 鼠标单击\n   ondbclick 鼠标双击\n   onmousedown 鼠标按键按下\n   onmouseup 鼠标按键抬起\n   onmousemove 鼠标在元素上移动\n   onmouseout 鼠标移出\n   onmouseenter 鼠标移入\n2. 键盘事件\n   onkeydown 键盘按键按下\n   onkeyup 键盘按键抬起\n   onkeypress 键盘按键按住\n3. 表单事件\n   onblur 失去焦点\n   onfocus 获取焦点\n   onchange 内容修改\n\n### 参数的声明\n\n函数名后面是一对圆括号，里面是传入函数的参数\nfunction 函数名称(参数列表){\n    函数体中的代码;\n}\n函数定义的时候的参数，称为形参\n\n```js\nfunction print(s) {\n  console.log(s);\n}\nfunction add(a, b) {\n  console.log(a + b);\n}\n```\n参数的传递\nprint（1）；\n调用函数的时候，传入了 参数 1，1 的值给了形参 s。\n函数调用时候传入的参数叫做实参\n\n### 函数的返回值\n\nJavaScript 引擎遇到 return 语句，就直接返回 return 后面的那个表达式的值,后面即使还有语句，也不会得到执行。\n也就是说，return 语句所带的那个表达式，就是函数的返回值。\n\n注、return 语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回 undefined。\n\n```js\nfunction add(x, y) {\n  return x + y; //返回x+y的和\n}\nvar res = add(1, 1); //把函数的返回值 赋值给 变量res\nconsole.log(res); //2\n```\n\n### 变量的声明提升\n\n函数内部会产生“变量提升”现象。在函数内部使用 var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。\n\n```js\nfunction foo(x) {\n  if (x > 100) {\n    var tmp = x - 100;\n  }\n}\n// 等同于\nfunction foo(x) {\n  var tmp;\n  if (x > 100) {\n    tmp = x - 100;\n  }\n}\n```\n\n### arguments\n\n由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。\narguments 对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\n```js\nlet f = function (one) {\n  console.log(arguments[0]);\n  console.log(arguments[1]);\n  console.log(arguments[2]);\n};\nf(1, 2, 3);\n```\n\n通过 arguments 对象的 length 属性，可以判断函数调用时到底带几个参数\n\n### 作用域\n\n作用域（scope）指的是变量存在的范围。\n局部作用域和全局作用域\n在 ES5 的规范中，Javascript 只有两种作用域：\n一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；\n另一种是函数作用域，变量只在函数内部存在。\n\n函数外部声明的变量就是全局变量（global variable）\n在函数内部定义的(使用 var)变量，外部无法读取，顾称为“局部变量”（local variable）\n\n```js\nvar v = 1; //全局变量\nfunction f() {\n  var b = 2; //局部变量\n  console.log(b);\n  console.log(v); //它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问\n}\nf();\n```\n\n上面的代码表明，函数 f 内部可以读取全局变量 v。\n\n函数内部定义的变量，会在该作用域内覆盖同名全局变量。（山高皇帝远，县官不如现管）\n\n```js\nvar v = 1;\nfunction f() {\n  var v = 2;\n  console.log(v);\n}\nf(); // 2\nv; // 1\n```\n\n上面代码中，变量 v 同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量 v 覆盖了全局变量 v。\n\n注意，对于 var 命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。\n\n```js\nif (true) {\n  var x = 5;\n}\nconsole.log(x); // 5\n```\n\n上面代码中，变量 x 在条件判断区块之中声明，结果就是一个全局变量，\n可以在区块之外读取。\n\n### 递归函数\n\n函数可以调用自身，这就是递归。\n\n简单来说，就是函数自己执行过程中，调用自己本身。\n\nf（n）求前 n 项和\n\n```js\nF(n)=F(n-1)+n = F(n-2)+n-1 +n= F(n-3)+n-2 + n-1 + n\n......   F(1)+2+3+4.... n-1 + n\n// F(100)= F(99)+100= F(98)+99+100 = F(1)+2+3+4.....+99+100\n```\n\n递归的步骤：\n\n1. 先找临界值，即无需计算 就能获取的值\n2. 找本次 和上一次的关系 f（n） = f(n-1)+n (数学归纳)\n3. 假设 当前函数已经可以使用了，调用自身计算上一次的运行结果，再写出本次运行结果 即可\n\n```js\n//求1-n之间的和\n//1 ........ 100\n//  1-  1000\n//1. 临界值1\n//2. sum(n-1)+n = sum(n)\nfunction sum1(n) {\n  //临界值\n  if (n == 1) {\n    return 1;\n  }\n  return sum1(n - 1) + n;\n}\n```\n\n### 构造函数及对象类型\n\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\n\n面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成\n\nJavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。\n\n构造函数就是一个普通的函数，但是有自己的特征和用法。\n\n```js\nfunction Vehicle() {\n  this.price = 1000;\n}\n```\n\n上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。\n构造函数的特点有两个。\n函数体内部使用了 this 关键字，代表了所要生成的对象实例。\n生成对象的时候，必须使用 new 命令\n\nnew 命令的作用，就是执行构造函数，返回一个实例对象。\n\n```js\nfunction Vehicle() {\n  this.price = 1000;\n}\nvar v = new Vehicle();\nv.price; // 1000\n```\n\n上面代码通过 new 命令，让构造函数 Vehicle 生成一个实例对象，保存在变量 v 中。这个新生成的实例对象，从构造函数 Vehicle 得到了 price 属性。new 命令执行时，构造函数内部的 this，就代表了新生成的实例对象，this.price 表示实例对象有一个 price 属性，值是 1000。\n\n---\n\n本文作者： 一只野生东子","source":"_posts/函数.md","raw":"---\ntitle: 函数\ndate: 2019-10-24\ntags: javaScript\n---\n\n### 函数的概念\n\n函数是一段可以反复调用的代码块。\n\n作用\n在程序设计中，常将一些常用的功能模块编写成函数，以减少重复编写程序段的工作量。\n提高代码的复用性、可读性等\n\n<!--more--> \n\n### 函数的创建方式（函数的声明）\n\n1. function 命令\n   function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号。函数体放在大括号里面。\n   function 函数名称() {\n      函数中要执行的代码;\n   }\n\n```js\nfunction print() {\n  console.log(1);\n}\n```\n\n上面的代码命名了一个 print 函数，以后使用 print()这种形式，就可以调用相应的代码。这叫做函数的声明\n\n2. 函数表达式\n   除了用 function 命令声明函数，还可以采用变量赋值的写法。\n\n```js\nlet print = function () {\n  console.log(1);\n};\n```\n\n这种写法将一个匿名函数（没有名字的函数）赋值给变量。这时，这个匿名函数又称函数表达式\n\n### 函数的执行(调用)\n\n函数定义好之后，函数中的代码在程序运行过程中不会执行；\n\n```js\nfunction print() {\n  console.log(1);\n}\nprint();\n```\n\n### 事件的概念种类\n\n事件：就是发生的事情\n事件驱动：就是发生了某件事情之后要处理的手段和过程\n\n1. 鼠标事件\n   onclick 鼠标单击\n   ondbclick 鼠标双击\n   onmousedown 鼠标按键按下\n   onmouseup 鼠标按键抬起\n   onmousemove 鼠标在元素上移动\n   onmouseout 鼠标移出\n   onmouseenter 鼠标移入\n2. 键盘事件\n   onkeydown 键盘按键按下\n   onkeyup 键盘按键抬起\n   onkeypress 键盘按键按住\n3. 表单事件\n   onblur 失去焦点\n   onfocus 获取焦点\n   onchange 内容修改\n\n### 参数的声明\n\n函数名后面是一对圆括号，里面是传入函数的参数\nfunction 函数名称(参数列表){\n    函数体中的代码;\n}\n函数定义的时候的参数，称为形参\n\n```js\nfunction print(s) {\n  console.log(s);\n}\nfunction add(a, b) {\n  console.log(a + b);\n}\n```\n参数的传递\nprint（1）；\n调用函数的时候，传入了 参数 1，1 的值给了形参 s。\n函数调用时候传入的参数叫做实参\n\n### 函数的返回值\n\nJavaScript 引擎遇到 return 语句，就直接返回 return 后面的那个表达式的值,后面即使还有语句，也不会得到执行。\n也就是说，return 语句所带的那个表达式，就是函数的返回值。\n\n注、return 语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回 undefined。\n\n```js\nfunction add(x, y) {\n  return x + y; //返回x+y的和\n}\nvar res = add(1, 1); //把函数的返回值 赋值给 变量res\nconsole.log(res); //2\n```\n\n### 变量的声明提升\n\n函数内部会产生“变量提升”现象。在函数内部使用 var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。\n\n```js\nfunction foo(x) {\n  if (x > 100) {\n    var tmp = x - 100;\n  }\n}\n// 等同于\nfunction foo(x) {\n  var tmp;\n  if (x > 100) {\n    tmp = x - 100;\n  }\n}\n```\n\n### arguments\n\n由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。\narguments 对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\n```js\nlet f = function (one) {\n  console.log(arguments[0]);\n  console.log(arguments[1]);\n  console.log(arguments[2]);\n};\nf(1, 2, 3);\n```\n\n通过 arguments 对象的 length 属性，可以判断函数调用时到底带几个参数\n\n### 作用域\n\n作用域（scope）指的是变量存在的范围。\n局部作用域和全局作用域\n在 ES5 的规范中，Javascript 只有两种作用域：\n一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；\n另一种是函数作用域，变量只在函数内部存在。\n\n函数外部声明的变量就是全局变量（global variable）\n在函数内部定义的(使用 var)变量，外部无法读取，顾称为“局部变量”（local variable）\n\n```js\nvar v = 1; //全局变量\nfunction f() {\n  var b = 2; //局部变量\n  console.log(b);\n  console.log(v); //它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问\n}\nf();\n```\n\n上面的代码表明，函数 f 内部可以读取全局变量 v。\n\n函数内部定义的变量，会在该作用域内覆盖同名全局变量。（山高皇帝远，县官不如现管）\n\n```js\nvar v = 1;\nfunction f() {\n  var v = 2;\n  console.log(v);\n}\nf(); // 2\nv; // 1\n```\n\n上面代码中，变量 v 同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量 v 覆盖了全局变量 v。\n\n注意，对于 var 命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。\n\n```js\nif (true) {\n  var x = 5;\n}\nconsole.log(x); // 5\n```\n\n上面代码中，变量 x 在条件判断区块之中声明，结果就是一个全局变量，\n可以在区块之外读取。\n\n### 递归函数\n\n函数可以调用自身，这就是递归。\n\n简单来说，就是函数自己执行过程中，调用自己本身。\n\nf（n）求前 n 项和\n\n```js\nF(n)=F(n-1)+n = F(n-2)+n-1 +n= F(n-3)+n-2 + n-1 + n\n......   F(1)+2+3+4.... n-1 + n\n// F(100)= F(99)+100= F(98)+99+100 = F(1)+2+3+4.....+99+100\n```\n\n递归的步骤：\n\n1. 先找临界值，即无需计算 就能获取的值\n2. 找本次 和上一次的关系 f（n） = f(n-1)+n (数学归纳)\n3. 假设 当前函数已经可以使用了，调用自身计算上一次的运行结果，再写出本次运行结果 即可\n\n```js\n//求1-n之间的和\n//1 ........ 100\n//  1-  1000\n//1. 临界值1\n//2. sum(n-1)+n = sum(n)\nfunction sum1(n) {\n  //临界值\n  if (n == 1) {\n    return 1;\n  }\n  return sum1(n - 1) + n;\n}\n```\n\n### 构造函数及对象类型\n\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\n\n面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成\n\nJavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。\n\n构造函数就是一个普通的函数，但是有自己的特征和用法。\n\n```js\nfunction Vehicle() {\n  this.price = 1000;\n}\n```\n\n上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。\n构造函数的特点有两个。\n函数体内部使用了 this 关键字，代表了所要生成的对象实例。\n生成对象的时候，必须使用 new 命令\n\nnew 命令的作用，就是执行构造函数，返回一个实例对象。\n\n```js\nfunction Vehicle() {\n  this.price = 1000;\n}\nvar v = new Vehicle();\nv.price; // 1000\n```\n\n上面代码通过 new 命令，让构造函数 Vehicle 生成一个实例对象，保存在变量 v 中。这个新生成的实例对象，从构造函数 Vehicle 得到了 price 属性。new 命令执行时，构造函数内部的 this，就代表了新生成的实例对象，this.price 表示实例对象有一个 price 属性，值是 1000。\n\n---\n\n本文作者： 一只野生东子","slug":"函数","published":1,"updated":"2021-11-26T06:27:30.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2m000q9co3039f2egf","content":"<h3 id=\"函数的概念\"><a href=\"#函数的概念\" class=\"headerlink\" title=\"函数的概念\"></a>函数的概念</h3><p>函数是一段可以反复调用的代码块。</p>\n<p>作用<br>在程序设计中，常将一些常用的功能模块编写成函数，以减少重复编写程序段的工作量。<br>提高代码的复用性、可读性等</p>\n<span id=\"more\"></span> \n\n<h3 id=\"函数的创建方式（函数的声明）\"><a href=\"#函数的创建方式（函数的声明）\" class=\"headerlink\" title=\"函数的创建方式（函数的声明）\"></a>函数的创建方式（函数的声明）</h3><ol>\n<li>function 命令<br>function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号。函数体放在大括号里面。<br>function 函数名称() {<br>   函数中要执行的代码;<br>}</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面的代码命名了一个 print 函数，以后使用 print()这种形式，就可以调用相应的代码。这叫做函数的声明</p>\n<ol start=\"2\">\n<li>函数表达式<br>除了用 function 命令声明函数，还可以采用变量赋值的写法。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>这种写法将一个匿名函数（没有名字的函数）赋值给变量。这时，这个匿名函数又称函数表达式</p>\n<h3 id=\"函数的执行-调用\"><a href=\"#函数的执行-调用\" class=\"headerlink\" title=\"函数的执行(调用)\"></a>函数的执行(调用)</h3><p>函数定义好之后，函数中的代码在程序运行过程中不会执行；</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print();</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"事件的概念种类\"><a href=\"#事件的概念种类\" class=\"headerlink\" title=\"事件的概念种类\"></a>事件的概念种类</h3><p>事件：就是发生的事情<br>事件驱动：就是发生了某件事情之后要处理的手段和过程</p>\n<ol>\n<li>鼠标事件<br>onclick 鼠标单击<br>ondbclick 鼠标双击<br>onmousedown 鼠标按键按下<br>onmouseup 鼠标按键抬起<br>onmousemove 鼠标在元素上移动<br>onmouseout 鼠标移出<br>onmouseenter 鼠标移入</li>\n<li>键盘事件<br>onkeydown 键盘按键按下<br>onkeyup 键盘按键抬起<br>onkeypress 键盘按键按住</li>\n<li>表单事件<br>onblur 失去焦点<br>onfocus 获取焦点<br>onchange 内容修改</li>\n</ol>\n<h3 id=\"参数的声明\"><a href=\"#参数的声明\" class=\"headerlink\" title=\"参数的声明\"></a>参数的声明</h3><p>函数名后面是一对圆括号，里面是传入函数的参数<br>function 函数名称(参数列表){<br>    函数体中的代码;<br>}<br>函数定义的时候的参数，称为形参</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>参数的传递<br>print（1）；<br>调用函数的时候，传入了 参数 1，1 的值给了形参 s。<br>函数调用时候传入的参数叫做实参</p>\n<h3 id=\"函数的返回值\"><a href=\"#函数的返回值\" class=\"headerlink\" title=\"函数的返回值\"></a>函数的返回值</h3><p>JavaScript 引擎遇到 return 语句，就直接返回 return 后面的那个表达式的值,后面即使还有语句，也不会得到执行。<br>也就是说，return 语句所带的那个表达式，就是函数的返回值。</p>\n<p>注、return 语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回 undefined。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y; <span class=\"comment\">//返回x+y的和</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = add(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">//把函数的返回值 赋值给 变量res</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"变量的声明提升\"><a href=\"#变量的声明提升\" class=\"headerlink\" title=\"变量的声明提升\"></a>变量的声明提升</h3><p>函数内部会产生“变量提升”现象。在函数内部使用 var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = x - <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    tmp = x - <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h3><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。<br>arguments 对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">one</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p>通过 arguments 对象的 length 属性，可以判断函数调用时到底带几个参数</p>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域（scope）指的是变量存在的范围。<br>局部作用域和全局作用域<br>在 ES5 的规范中，Javascript 只有两种作用域：<br>一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；<br>另一种是函数作用域，变量只在函数内部存在。</p>\n<p>函数外部声明的变量就是全局变量（global variable）<br>在函数内部定义的(使用 var)变量，外部无法读取，顾称为“局部变量”（local variable）</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"number\">1</span>; <span class=\"comment\">//全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>; <span class=\"comment\">//局部变量</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure></div>\n\n<p>上面的代码表明，函数 f 内部可以读取全局变量 v。</p>\n<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。（山高皇帝远，县官不如现管）</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">v; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，变量 v 同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量 v 覆盖了全局变量 v。</p>\n<p>注意，对于 var 命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，变量 x 在条件判断区块之中声明，结果就是一个全局变量，<br>可以在区块之外读取。</p>\n<h3 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h3><p>函数可以调用自身，这就是递归。</p>\n<p>简单来说，就是函数自己执行过程中，调用自己本身。</p>\n<p>f（n）求前 n 项和</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F(n)=F(n-<span class=\"number\">1</span>)+n = F(n-<span class=\"number\">2</span>)+n-<span class=\"number\">1</span> +n= F(n-<span class=\"number\">3</span>)+n-<span class=\"number\">2</span> + n-<span class=\"number\">1</span> + n</span><br><span class=\"line\">......   F(<span class=\"number\">1</span>)+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">4.</span>... n-<span class=\"number\">1</span> + n</span><br><span class=\"line\"><span class=\"comment\">// F(100)= F(99)+100= F(98)+99+100 = F(1)+2+3+4.....+99+100</span></span><br></pre></td></tr></table></figure></div>\n\n<p>递归的步骤：</p>\n<ol>\n<li>先找临界值，即无需计算 就能获取的值</li>\n<li>找本次 和上一次的关系 f（n） = f(n-1)+n (数学归纳)</li>\n<li>假设 当前函数已经可以使用了，调用自身计算上一次的运行结果，再写出本次运行结果 即可</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求1-n之间的和</span></span><br><span class=\"line\"><span class=\"comment\">//1 ........ 100</span></span><br><span class=\"line\"><span class=\"comment\">//  1-  1000</span></span><br><span class=\"line\"><span class=\"comment\">//1. 临界值1</span></span><br><span class=\"line\"><span class=\"comment\">//2. sum(n-1)+n = sum(n)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//临界值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum1(n - <span class=\"number\">1</span>) + n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"构造函数及对象类型\"><a href=\"#构造函数及对象类型\" class=\"headerlink\" title=\"构造函数及对象类型\"></a>构造函数及对象类型</h3><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>\n<p>面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成</p>\n<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>\n<p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vehicle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.price = <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。<br>构造函数的特点有两个。<br>函数体内部使用了 this 关键字，代表了所要生成的对象实例。<br>生成对象的时候，必须使用 new 命令</p>\n<p>new 命令的作用，就是执行构造函数，返回一个实例对象。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vehicle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.price = <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">v.price; <span class=\"comment\">// 1000</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码通过 new 命令，让构造函数 Vehicle 生成一个实例对象，保存在变量 v 中。这个新生成的实例对象，从构造函数 Vehicle 得到了 price 属性。new 命令执行时，构造函数内部的 this，就代表了新生成的实例对象，this.price 表示实例对象有一个 price 属性，值是 1000。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"函数的概念\"><a href=\"#函数的概念\" class=\"headerlink\" title=\"函数的概念\"></a>函数的概念</h3><p>函数是一段可以反复调用的代码块。</p>\n<p>作用<br>在程序设计中，常将一些常用的功能模块编写成函数，以减少重复编写程序段的工作量。<br>提高代码的复用性、可读性等</p>","more":"<h3 id=\"函数的创建方式（函数的声明）\"><a href=\"#函数的创建方式（函数的声明）\" class=\"headerlink\" title=\"函数的创建方式（函数的声明）\"></a>函数的创建方式（函数的声明）</h3><ol>\n<li>function 命令<br>function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号。函数体放在大括号里面。<br>function 函数名称() {<br>   函数中要执行的代码;<br>}</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码命名了一个 print 函数，以后使用 print()这种形式，就可以调用相应的代码。这叫做函数的声明</p>\n<ol start=\"2\">\n<li>函数表达式<br>除了用 function 命令声明函数，还可以采用变量赋值的写法。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法将一个匿名函数（没有名字的函数）赋值给变量。这时，这个匿名函数又称函数表达式</p>\n<h3 id=\"函数的执行-调用\"><a href=\"#函数的执行-调用\" class=\"headerlink\" title=\"函数的执行(调用)\"></a>函数的执行(调用)</h3><p>函数定义好之后，函数中的代码在程序运行过程中不会执行；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事件的概念种类\"><a href=\"#事件的概念种类\" class=\"headerlink\" title=\"事件的概念种类\"></a>事件的概念种类</h3><p>事件：就是发生的事情<br>事件驱动：就是发生了某件事情之后要处理的手段和过程</p>\n<ol>\n<li>鼠标事件<br>onclick 鼠标单击<br>ondbclick 鼠标双击<br>onmousedown 鼠标按键按下<br>onmouseup 鼠标按键抬起<br>onmousemove 鼠标在元素上移动<br>onmouseout 鼠标移出<br>onmouseenter 鼠标移入</li>\n<li>键盘事件<br>onkeydown 键盘按键按下<br>onkeyup 键盘按键抬起<br>onkeypress 键盘按键按住</li>\n<li>表单事件<br>onblur 失去焦点<br>onfocus 获取焦点<br>onchange 内容修改</li>\n</ol>\n<h3 id=\"参数的声明\"><a href=\"#参数的声明\" class=\"headerlink\" title=\"参数的声明\"></a>参数的声明</h3><p>函数名后面是一对圆括号，里面是传入函数的参数<br>function 函数名称(参数列表){<br>    函数体中的代码;<br>}<br>函数定义的时候的参数，称为形参</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数的传递<br>print（1）；<br>调用函数的时候，传入了 参数 1，1 的值给了形参 s。<br>函数调用时候传入的参数叫做实参</p>\n<h3 id=\"函数的返回值\"><a href=\"#函数的返回值\" class=\"headerlink\" title=\"函数的返回值\"></a>函数的返回值</h3><p>JavaScript 引擎遇到 return 语句，就直接返回 return 后面的那个表达式的值,后面即使还有语句，也不会得到执行。<br>也就是说，return 语句所带的那个表达式，就是函数的返回值。</p>\n<p>注、return 语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回 undefined。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y; <span class=\"comment\">//返回x+y的和</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = add(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">//把函数的返回值 赋值给 变量res</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量的声明提升\"><a href=\"#变量的声明提升\" class=\"headerlink\" title=\"变量的声明提升\"></a>变量的声明提升</h3><p>函数内部会产生“变量提升”现象。在函数内部使用 var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = x - <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    tmp = x - <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h3><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。<br>arguments 对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">one</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>通过 arguments 对象的 length 属性，可以判断函数调用时到底带几个参数</p>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域（scope）指的是变量存在的范围。<br>局部作用域和全局作用域<br>在 ES5 的规范中，Javascript 只有两种作用域：<br>一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；<br>另一种是函数作用域，变量只在函数内部存在。</p>\n<p>函数外部声明的变量就是全局变量（global variable）<br>在函数内部定义的(使用 var)变量，外部无法读取，顾称为“局部变量”（local variable）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"number\">1</span>; <span class=\"comment\">//全局变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>; <span class=\"comment\">//局部变量</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码表明，函数 f 内部可以读取全局变量 v。</p>\n<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。（山高皇帝远，县官不如现管）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">v; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 v 同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量 v 覆盖了全局变量 v。</p>\n<p>注意，对于 var 命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量 x 在条件判断区块之中声明，结果就是一个全局变量，<br>可以在区块之外读取。</p>\n<h3 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h3><p>函数可以调用自身，这就是递归。</p>\n<p>简单来说，就是函数自己执行过程中，调用自己本身。</p>\n<p>f（n）求前 n 项和</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F(n)=F(n-<span class=\"number\">1</span>)+n = F(n-<span class=\"number\">2</span>)+n-<span class=\"number\">1</span> +n= F(n-<span class=\"number\">3</span>)+n-<span class=\"number\">2</span> + n-<span class=\"number\">1</span> + n</span><br><span class=\"line\">......   F(<span class=\"number\">1</span>)+<span class=\"number\">2</span>+<span class=\"number\">3</span>+<span class=\"number\">4.</span>... n-<span class=\"number\">1</span> + n</span><br><span class=\"line\"><span class=\"comment\">// F(100)= F(99)+100= F(98)+99+100 = F(1)+2+3+4.....+99+100</span></span><br></pre></td></tr></table></figure>\n\n<p>递归的步骤：</p>\n<ol>\n<li>先找临界值，即无需计算 就能获取的值</li>\n<li>找本次 和上一次的关系 f（n） = f(n-1)+n (数学归纳)</li>\n<li>假设 当前函数已经可以使用了，调用自身计算上一次的运行结果，再写出本次运行结果 即可</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求1-n之间的和</span></span><br><span class=\"line\"><span class=\"comment\">//1 ........ 100</span></span><br><span class=\"line\"><span class=\"comment\">//  1-  1000</span></span><br><span class=\"line\"><span class=\"comment\">//1. 临界值1</span></span><br><span class=\"line\"><span class=\"comment\">//2. sum(n-1)+n = sum(n)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//临界值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum1(n - <span class=\"number\">1</span>) + n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数及对象类型\"><a href=\"#构造函数及对象类型\" class=\"headerlink\" title=\"构造函数及对象类型\"></a>构造函数及对象类型</h3><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>\n<p>面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成</p>\n<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>\n<p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vehicle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.price = <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。<br>构造函数的特点有两个。<br>函数体内部使用了 this 关键字，代表了所要生成的对象实例。<br>生成对象的时候，必须使用 new 命令</p>\n<p>new 命令的作用，就是执行构造函数，返回一个实例对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vehicle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.price = <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">v.price; <span class=\"comment\">// 1000</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码通过 new 命令，让构造函数 Vehicle 生成一个实例对象，保存在变量 v 中。这个新生成的实例对象，从构造函数 Vehicle 得到了 price 属性。new 命令执行时，构造函数内部的 this，就代表了新生成的实例对象，this.price 表示实例对象有一个 price 属性，值是 1000。</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"嗷嗷嗷","date":"9999-09-08T16:00:00.000Z","_content":"  \n## <font face=\"楷体\" color=orangered size=6>我给你买杯奶茶吧</font>","source":"_posts/奶茶.md","raw":"---\ntitle: 嗷嗷嗷\ndate: 9999-09-09\n---\n  \n## <font face=\"楷体\" color=orangered size=6>我给你买杯奶茶吧</font>","slug":"奶茶","published":1,"updated":"2021-11-29T04:42:57.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2n000t9co3066q2ted","content":"<h2 id=\"我给你买杯奶茶吧\"><a href=\"#我给你买杯奶茶吧\" class=\"headerlink\" title=\"我给你买杯奶茶吧\"></a><font face=\"楷体\" color=orangered size=6>我给你买杯奶茶吧</font></h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"我给你买杯奶茶吧\"><a href=\"#我给你买杯奶茶吧\" class=\"headerlink\" title=\"我给你买杯奶茶吧\"></a><font face=\"楷体\" color=orangered size=6>我给你买杯奶茶吧</font></h2>"},{"title":"浏览器兼容和精灵图","date":"2020-03-21T16:00:00.000Z","_content":"\n### 浏览器相关\n\n1. 浏览器内核\n\n   浏览器最关键的部分就是它的渲染引擎（Rendering Engine），也就是大家平常所说的的“内核”。\n\n<!--more--> \n\n   五大浏览器内核\n   \n   Trident   （MSHTML）     （三叉戟；三叉线；三齿鱼叉）\n   Gecko      （壁虎）\n   Presto      （ 迅速的）\n   Webkit    （Safari 内核,Chrome 内核原型,它是苹果公司自己的内核，也是苹果的 Safari 浏览器使用的内   核）\n   Blink         (由 Google 和 Opera Software 开发的浏览器排版引擎)\n\n2. 浏览器内核代表浏览器\n   Trident:IE、Maxthon(遨游)、腾讯 、Theworld 世界之窗、360 浏览器\n   代表作品 IE,因为 IE 捆绑在 Windows 中，所以占有极高的市场份额，又称 IE 内核或是 MSHTML，此内核只能应用于 windows 平台，且是不开源的。\n\n   Gecko:代表作品 Mozilla Firefox 是开源的,它的最大优势是跨平台，能在 Microsoft Windows、Linux 和 MacOS X 等主要操作系统上运行。\n\n   Webkit:代表作品 Safari、Chrome ， 是一个开源项目。\n\n   Presto:代表作品 Opera ，Presto 是由 Opera Software 开发的浏览器排版引擎。它也是世界上公认的渲染速度最快的引擎。\n\n   Blink:由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。\n\n### CSS 兼容问题\n\n1. 样式在各浏览器中解析不一致的情况，或者说 CSS 样式在浏览器中不能正确显示的问题称为 CSS bug.\n2. CSS Hack: CSS 中，Hack 是指一种兼容 CSS 在不同浏览器中正确显示的技巧方法，修补 bug 的方法\n3. Filter:表示过滤器的意思，它是一种对特定的浏览器或浏览器组显示或隐藏规则或声明的方法。本质上讲，Filter 是 hack 方法中的一种；\n\n### IE6 常见 CSS 解析 Bug 及 hack（解决方法）\n\n1. 默认高度（IE6）\n   描述：在 IE6 及以下版本中，部分块元素拥有默认高度（低于 18px 高度）\n   hack1:给元素添加声明：font-size:0;\n   hack2：给元素添加声明：overflow:hidden;\n2. 图片间隙\n   div 中的图片间隙\n   bug：在块元素中插入图片时，有时图片会将块元素下方撑大三像素。\n   Hack：给<img>添加声明：display:block; vertical-align:middle\n3. 双倍浮向（双倍边距）\n   描述：当 Ie6 及更低版本浏览器在解析浮动元素时，会错误地把浮向边的边界加倍显示。\n   hack:给浮动元素添加声明：display:inline;\n4. 表单元素行高不一致(IE,MOZ,C,O,S)\n   bug：表单元素行高对齐方式不一致\n   hack:给表单元素添加声明：float:left;\n5. 按钮元素默认大小及样式不一致\n   hack1:统一大小及样式/（用 a 标记模拟）\n   hack2:input 外边套一个标签，在这个标签里写按钮的样式，把 input 的边框去掉。\n   hack3:如果这个按钮是一个图片，直接把图片作为按钮的背景图即可。\n6. 百分比 bug\n   描述：在 IE6 及以下版本中在解析百分比时，会按四舍五入方式计算从而导致 50%加 50%大于 100%的情况。\n   hack:给右面的浮动元素添加声明：clear:right; 意思：清除右浮动。\n   clear:left 清除左浮动\n   clear:both 清除两边的浮动\n7. 鼠标指针 bug\n   描述：cursor 属性的 hand 属性值只有 IE8 浏览器识别;\n   hack:如统一某元素鼠标指针形状为手型，应添加声明：cursor:pointer;\n   cursor 的值有:\n   auto 默认\n   crosshair 加号\n   text 文本\n   wait 等待\n   help 帮助\n   progress 过程\n   inherit 继承\n   move 移动\n   ne-resize 向上或向右移动\n   pointer 手形\n8. 透明属性\n   IE 浏览器写法：filter:alpha(opacity=数值);取值范围 1-100(IE8 以下)\n   兼容其他浏览器写法：opacity:数值;(数值的取值范围 0-1,0.1,0.2,0.3—–0.9)\n9. 当 li 里的 A 加 display:block 或 float:left 时，出现行高不一致，有的会多出 3 像素；\n   hack1：给 a 加display:inline-block;\n   Hack3：给 li 加 float，并加宽度；\n10. 当 li 加 float 属性，并且 li 里的 A 转换成块元素,并给 a 加了高度时，IE6 里会出现每个 LI 单独占一行或阶梯状的情况；\n   hack1：不给 a 标签加高度；\n   Hack2：给 a 标签也添加 float；\n11. 父元素里有块元素，如果给子元素添加添加margin-top,父元素会下来。\n   Hack1：给父元素添加overflow:hidden;\n   Hack2：给子元素添加 float；\n   Hack3：给父元素加边框；\n\n或者用其他的方法达到我们想要的效果：如给父元素加padding-top\n\n### 图片整合(精灵图)\n\n用 background-position”来实现背景图片的定位技术,这种技术可以成为 css sprites 技术，又称为 css 精灵。\n\n将导航背景图片，按钮、背景小图标等小图片有规则的合并成一张背景图，即将多张图片合为一张整图，再利用 background 属性进行背景定位，用数字精确的定位出背景图片在布局盒子中的位置；\n\n优点: 1)通过图片整合来减少对服务器的请求次数，从而提高 页面的加载速度。 2)通过整合图片来减小图片的体积。\n\n注意点: 1)根据实际容器的大小，小图片和小图片之间要留有足够的空间 2)开发和修改时需要精确测量每一个背景单元的精确位置，测量和修改起来比较麻烦。\n\n滑动门技术:\n\n1. 什么是滑动门\n   滑动门是一个形象的称呼，它利用 CSS 背景图像可层叠性，并允许彼此之上进行滑动来创造一些特殊动态效果\n2. 滑动门特征\n   通过滑动门技术，可以使 CSS 设计出来的导航菜单兼具传统布局的图像效果，与 CSS 布局的高效扩展性 。\n\n---\n\n本文作者： 一只野生东子","source":"_posts/浏览器兼容和精灵图.md","raw":"---\ntitle: 浏览器兼容和精灵图\ndate: 2020-03-22\ntags: javaScript、css\n---\n\n### 浏览器相关\n\n1. 浏览器内核\n\n   浏览器最关键的部分就是它的渲染引擎（Rendering Engine），也就是大家平常所说的的“内核”。\n\n<!--more--> \n\n   五大浏览器内核\n   \n   Trident   （MSHTML）     （三叉戟；三叉线；三齿鱼叉）\n   Gecko      （壁虎）\n   Presto      （ 迅速的）\n   Webkit    （Safari 内核,Chrome 内核原型,它是苹果公司自己的内核，也是苹果的 Safari 浏览器使用的内   核）\n   Blink         (由 Google 和 Opera Software 开发的浏览器排版引擎)\n\n2. 浏览器内核代表浏览器\n   Trident:IE、Maxthon(遨游)、腾讯 、Theworld 世界之窗、360 浏览器\n   代表作品 IE,因为 IE 捆绑在 Windows 中，所以占有极高的市场份额，又称 IE 内核或是 MSHTML，此内核只能应用于 windows 平台，且是不开源的。\n\n   Gecko:代表作品 Mozilla Firefox 是开源的,它的最大优势是跨平台，能在 Microsoft Windows、Linux 和 MacOS X 等主要操作系统上运行。\n\n   Webkit:代表作品 Safari、Chrome ， 是一个开源项目。\n\n   Presto:代表作品 Opera ，Presto 是由 Opera Software 开发的浏览器排版引擎。它也是世界上公认的渲染速度最快的引擎。\n\n   Blink:由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。\n\n### CSS 兼容问题\n\n1. 样式在各浏览器中解析不一致的情况，或者说 CSS 样式在浏览器中不能正确显示的问题称为 CSS bug.\n2. CSS Hack: CSS 中，Hack 是指一种兼容 CSS 在不同浏览器中正确显示的技巧方法，修补 bug 的方法\n3. Filter:表示过滤器的意思，它是一种对特定的浏览器或浏览器组显示或隐藏规则或声明的方法。本质上讲，Filter 是 hack 方法中的一种；\n\n### IE6 常见 CSS 解析 Bug 及 hack（解决方法）\n\n1. 默认高度（IE6）\n   描述：在 IE6 及以下版本中，部分块元素拥有默认高度（低于 18px 高度）\n   hack1:给元素添加声明：font-size:0;\n   hack2：给元素添加声明：overflow:hidden;\n2. 图片间隙\n   div 中的图片间隙\n   bug：在块元素中插入图片时，有时图片会将块元素下方撑大三像素。\n   Hack：给<img>添加声明：display:block; vertical-align:middle\n3. 双倍浮向（双倍边距）\n   描述：当 Ie6 及更低版本浏览器在解析浮动元素时，会错误地把浮向边的边界加倍显示。\n   hack:给浮动元素添加声明：display:inline;\n4. 表单元素行高不一致(IE,MOZ,C,O,S)\n   bug：表单元素行高对齐方式不一致\n   hack:给表单元素添加声明：float:left;\n5. 按钮元素默认大小及样式不一致\n   hack1:统一大小及样式/（用 a 标记模拟）\n   hack2:input 外边套一个标签，在这个标签里写按钮的样式，把 input 的边框去掉。\n   hack3:如果这个按钮是一个图片，直接把图片作为按钮的背景图即可。\n6. 百分比 bug\n   描述：在 IE6 及以下版本中在解析百分比时，会按四舍五入方式计算从而导致 50%加 50%大于 100%的情况。\n   hack:给右面的浮动元素添加声明：clear:right; 意思：清除右浮动。\n   clear:left 清除左浮动\n   clear:both 清除两边的浮动\n7. 鼠标指针 bug\n   描述：cursor 属性的 hand 属性值只有 IE8 浏览器识别;\n   hack:如统一某元素鼠标指针形状为手型，应添加声明：cursor:pointer;\n   cursor 的值有:\n   auto 默认\n   crosshair 加号\n   text 文本\n   wait 等待\n   help 帮助\n   progress 过程\n   inherit 继承\n   move 移动\n   ne-resize 向上或向右移动\n   pointer 手形\n8. 透明属性\n   IE 浏览器写法：filter:alpha(opacity=数值);取值范围 1-100(IE8 以下)\n   兼容其他浏览器写法：opacity:数值;(数值的取值范围 0-1,0.1,0.2,0.3—–0.9)\n9. 当 li 里的 A 加 display:block 或 float:left 时，出现行高不一致，有的会多出 3 像素；\n   hack1：给 a 加display:inline-block;\n   Hack3：给 li 加 float，并加宽度；\n10. 当 li 加 float 属性，并且 li 里的 A 转换成块元素,并给 a 加了高度时，IE6 里会出现每个 LI 单独占一行或阶梯状的情况；\n   hack1：不给 a 标签加高度；\n   Hack2：给 a 标签也添加 float；\n11. 父元素里有块元素，如果给子元素添加添加margin-top,父元素会下来。\n   Hack1：给父元素添加overflow:hidden;\n   Hack2：给子元素添加 float；\n   Hack3：给父元素加边框；\n\n或者用其他的方法达到我们想要的效果：如给父元素加padding-top\n\n### 图片整合(精灵图)\n\n用 background-position”来实现背景图片的定位技术,这种技术可以成为 css sprites 技术，又称为 css 精灵。\n\n将导航背景图片，按钮、背景小图标等小图片有规则的合并成一张背景图，即将多张图片合为一张整图，再利用 background 属性进行背景定位，用数字精确的定位出背景图片在布局盒子中的位置；\n\n优点: 1)通过图片整合来减少对服务器的请求次数，从而提高 页面的加载速度。 2)通过整合图片来减小图片的体积。\n\n注意点: 1)根据实际容器的大小，小图片和小图片之间要留有足够的空间 2)开发和修改时需要精确测量每一个背景单元的精确位置，测量和修改起来比较麻烦。\n\n滑动门技术:\n\n1. 什么是滑动门\n   滑动门是一个形象的称呼，它利用 CSS 背景图像可层叠性，并允许彼此之上进行滑动来创造一些特殊动态效果\n2. 滑动门特征\n   通过滑动门技术，可以使 CSS 设计出来的导航菜单兼具传统布局的图像效果，与 CSS 布局的高效扩展性 。\n\n---\n\n本文作者： 一只野生东子","slug":"浏览器兼容和精灵图","published":1,"updated":"2021-11-26T08:51:03.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2o000v9co30oee7iqp","content":"<h3 id=\"浏览器相关\"><a href=\"#浏览器相关\" class=\"headerlink\" title=\"浏览器相关\"></a>浏览器相关</h3><ol>\n<li><p>浏览器内核</p>\n<p>浏览器最关键的部分就是它的渲染引擎（Rendering Engine），也就是大家平常所说的的“内核”。</p>\n</li>\n</ol>\n<span id=\"more\"></span> \n\n<p>   五大浏览器内核</p>\n<p>   Trident   （MSHTML）     （三叉戟；三叉线；三齿鱼叉）<br>   Gecko      （壁虎）<br>   Presto      （ 迅速的）<br>   Webkit    （Safari 内核,Chrome 内核原型,它是苹果公司自己的内核，也是苹果的 Safari 浏览器使用的内   核）<br>   Blink         (由 Google 和 Opera Software 开发的浏览器排版引擎)</p>\n<ol start=\"2\">\n<li><p>浏览器内核代表浏览器<br>Trident:IE、Maxthon(遨游)、腾讯 、Theworld 世界之窗、360 浏览器<br>代表作品 IE,因为 IE 捆绑在 Windows 中，所以占有极高的市场份额，又称 IE 内核或是 MSHTML，此内核只能应用于 windows 平台，且是不开源的。</p>\n<p>Gecko:代表作品 Mozilla Firefox 是开源的,它的最大优势是跨平台，能在 Microsoft Windows、Linux 和 MacOS X 等主要操作系统上运行。</p>\n<p>Webkit:代表作品 Safari、Chrome ， 是一个开源项目。</p>\n<p>Presto:代表作品 Opera ，Presto 是由 Opera Software 开发的浏览器排版引擎。它也是世界上公认的渲染速度最快的引擎。</p>\n<p>Blink:由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。</p>\n</li>\n</ol>\n<h3 id=\"CSS-兼容问题\"><a href=\"#CSS-兼容问题\" class=\"headerlink\" title=\"CSS 兼容问题\"></a>CSS 兼容问题</h3><ol>\n<li>样式在各浏览器中解析不一致的情况，或者说 CSS 样式在浏览器中不能正确显示的问题称为 CSS bug.</li>\n<li>CSS Hack: CSS 中，Hack 是指一种兼容 CSS 在不同浏览器中正确显示的技巧方法，修补 bug 的方法</li>\n<li>Filter:表示过滤器的意思，它是一种对特定的浏览器或浏览器组显示或隐藏规则或声明的方法。本质上讲，Filter 是 hack 方法中的一种；</li>\n</ol>\n<h3 id=\"IE6-常见-CSS-解析-Bug-及-hack（解决方法）\"><a href=\"#IE6-常见-CSS-解析-Bug-及-hack（解决方法）\" class=\"headerlink\" title=\"IE6 常见 CSS 解析 Bug 及 hack（解决方法）\"></a>IE6 常见 CSS 解析 Bug 及 hack（解决方法）</h3><ol>\n<li>默认高度（IE6）<br>描述：在 IE6 及以下版本中，部分块元素拥有默认高度（低于 18px 高度）<br>hack1:给元素添加声明：font-size:0;<br>hack2：给元素添加声明：overflow:hidden;</li>\n<li>图片间隙<br>div 中的图片间隙<br>bug：在块元素中插入图片时，有时图片会将块元素下方撑大三像素。<br>Hack：给<img>添加声明：display:block; vertical-align:middle</li>\n<li>双倍浮向（双倍边距）<br>描述：当 Ie6 及更低版本浏览器在解析浮动元素时，会错误地把浮向边的边界加倍显示。<br>hack:给浮动元素添加声明：display:inline;</li>\n<li>表单元素行高不一致(IE,MOZ,C,O,S)<br>bug：表单元素行高对齐方式不一致<br>hack:给表单元素添加声明：float:left;</li>\n<li>按钮元素默认大小及样式不一致<br>hack1:统一大小及样式/（用 a 标记模拟）<br>hack2:input 外边套一个标签，在这个标签里写按钮的样式，把 input 的边框去掉。<br>hack3:如果这个按钮是一个图片，直接把图片作为按钮的背景图即可。</li>\n<li>百分比 bug<br>描述：在 IE6 及以下版本中在解析百分比时，会按四舍五入方式计算从而导致 50%加 50%大于 100%的情况。<br>hack:给右面的浮动元素添加声明：clear:right; 意思：清除右浮动。<br>clear:left 清除左浮动<br>clear:both 清除两边的浮动</li>\n<li>鼠标指针 bug<br>描述：cursor 属性的 hand 属性值只有 IE8 浏览器识别;<br>hack:如统一某元素鼠标指针形状为手型，应添加声明：cursor:pointer;<br>cursor 的值有:<br>auto 默认<br>crosshair 加号<br>text 文本<br>wait 等待<br>help 帮助<br>progress 过程<br>inherit 继承<br>move 移动<br>ne-resize 向上或向右移动<br>pointer 手形</li>\n<li>透明属性<br>IE 浏览器写法：filter:alpha(opacity=数值);取值范围 1-100(IE8 以下)<br>兼容其他浏览器写法：opacity:数值;(数值的取值范围 0-1,0.1,0.2,0.3—–0.9)</li>\n<li>当 li 里的 A 加 display:block 或 float:left 时，出现行高不一致，有的会多出 3 像素；<br>hack1：给 a 加display:inline-block;<br>Hack3：给 li 加 float，并加宽度；</li>\n<li>当 li 加 float 属性，并且 li 里的 A 转换成块元素,并给 a 加了高度时，IE6 里会出现每个 LI 单独占一行或阶梯状的情况；<br>hack1：不给 a 标签加高度；<br>Hack2：给 a 标签也添加 float；</li>\n<li>父元素里有块元素，如果给子元素添加添加margin-top,父元素会下来。<br>Hack1：给父元素添加overflow:hidden;<br>Hack2：给子元素添加 float；<br>Hack3：给父元素加边框；</li>\n</ol>\n<p>或者用其他的方法达到我们想要的效果：如给父元素加padding-top</p>\n<h3 id=\"图片整合-精灵图\"><a href=\"#图片整合-精灵图\" class=\"headerlink\" title=\"图片整合(精灵图)\"></a>图片整合(精灵图)</h3><p>用 background-position”来实现背景图片的定位技术,这种技术可以成为 css sprites 技术，又称为 css 精灵。</p>\n<p>将导航背景图片，按钮、背景小图标等小图片有规则的合并成一张背景图，即将多张图片合为一张整图，再利用 background 属性进行背景定位，用数字精确的定位出背景图片在布局盒子中的位置；</p>\n<p>优点: 1)通过图片整合来减少对服务器的请求次数，从而提高 页面的加载速度。 2)通过整合图片来减小图片的体积。</p>\n<p>注意点: 1)根据实际容器的大小，小图片和小图片之间要留有足够的空间 2)开发和修改时需要精确测量每一个背景单元的精确位置，测量和修改起来比较麻烦。</p>\n<p>滑动门技术:</p>\n<ol>\n<li>什么是滑动门<br>滑动门是一个形象的称呼，它利用 CSS 背景图像可层叠性，并允许彼此之上进行滑动来创造一些特殊动态效果</li>\n<li>滑动门特征<br>通过滑动门技术，可以使 CSS 设计出来的导航菜单兼具传统布局的图像效果，与 CSS 布局的高效扩展性 。</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"浏览器相关\"><a href=\"#浏览器相关\" class=\"headerlink\" title=\"浏览器相关\"></a>浏览器相关</h3><ol>\n<li><p>浏览器内核</p>\n<p>浏览器最关键的部分就是它的渲染引擎（Rendering Engine），也就是大家平常所说的的“内核”。</p>\n</li>\n</ol>","more":"<p>   五大浏览器内核</p>\n<p>   Trident   （MSHTML）     （三叉戟；三叉线；三齿鱼叉）<br>   Gecko      （壁虎）<br>   Presto      （ 迅速的）<br>   Webkit    （Safari 内核,Chrome 内核原型,它是苹果公司自己的内核，也是苹果的 Safari 浏览器使用的内   核）<br>   Blink         (由 Google 和 Opera Software 开发的浏览器排版引擎)</p>\n<ol start=\"2\">\n<li><p>浏览器内核代表浏览器<br>Trident:IE、Maxthon(遨游)、腾讯 、Theworld 世界之窗、360 浏览器<br>代表作品 IE,因为 IE 捆绑在 Windows 中，所以占有极高的市场份额，又称 IE 内核或是 MSHTML，此内核只能应用于 windows 平台，且是不开源的。</p>\n<p>Gecko:代表作品 Mozilla Firefox 是开源的,它的最大优势是跨平台，能在 Microsoft Windows、Linux 和 MacOS X 等主要操作系统上运行。</p>\n<p>Webkit:代表作品 Safari、Chrome ， 是一个开源项目。</p>\n<p>Presto:代表作品 Opera ，Presto 是由 Opera Software 开发的浏览器排版引擎。它也是世界上公认的渲染速度最快的引擎。</p>\n<p>Blink:由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。</p>\n</li>\n</ol>\n<h3 id=\"CSS-兼容问题\"><a href=\"#CSS-兼容问题\" class=\"headerlink\" title=\"CSS 兼容问题\"></a>CSS 兼容问题</h3><ol>\n<li>样式在各浏览器中解析不一致的情况，或者说 CSS 样式在浏览器中不能正确显示的问题称为 CSS bug.</li>\n<li>CSS Hack: CSS 中，Hack 是指一种兼容 CSS 在不同浏览器中正确显示的技巧方法，修补 bug 的方法</li>\n<li>Filter:表示过滤器的意思，它是一种对特定的浏览器或浏览器组显示或隐藏规则或声明的方法。本质上讲，Filter 是 hack 方法中的一种；</li>\n</ol>\n<h3 id=\"IE6-常见-CSS-解析-Bug-及-hack（解决方法）\"><a href=\"#IE6-常见-CSS-解析-Bug-及-hack（解决方法）\" class=\"headerlink\" title=\"IE6 常见 CSS 解析 Bug 及 hack（解决方法）\"></a>IE6 常见 CSS 解析 Bug 及 hack（解决方法）</h3><ol>\n<li>默认高度（IE6）<br>描述：在 IE6 及以下版本中，部分块元素拥有默认高度（低于 18px 高度）<br>hack1:给元素添加声明：font-size:0;<br>hack2：给元素添加声明：overflow:hidden;</li>\n<li>图片间隙<br>div 中的图片间隙<br>bug：在块元素中插入图片时，有时图片会将块元素下方撑大三像素。<br>Hack：给<img>添加声明：display:block; vertical-align:middle</li>\n<li>双倍浮向（双倍边距）<br>描述：当 Ie6 及更低版本浏览器在解析浮动元素时，会错误地把浮向边的边界加倍显示。<br>hack:给浮动元素添加声明：display:inline;</li>\n<li>表单元素行高不一致(IE,MOZ,C,O,S)<br>bug：表单元素行高对齐方式不一致<br>hack:给表单元素添加声明：float:left;</li>\n<li>按钮元素默认大小及样式不一致<br>hack1:统一大小及样式/（用 a 标记模拟）<br>hack2:input 外边套一个标签，在这个标签里写按钮的样式，把 input 的边框去掉。<br>hack3:如果这个按钮是一个图片，直接把图片作为按钮的背景图即可。</li>\n<li>百分比 bug<br>描述：在 IE6 及以下版本中在解析百分比时，会按四舍五入方式计算从而导致 50%加 50%大于 100%的情况。<br>hack:给右面的浮动元素添加声明：clear:right; 意思：清除右浮动。<br>clear:left 清除左浮动<br>clear:both 清除两边的浮动</li>\n<li>鼠标指针 bug<br>描述：cursor 属性的 hand 属性值只有 IE8 浏览器识别;<br>hack:如统一某元素鼠标指针形状为手型，应添加声明：cursor:pointer;<br>cursor 的值有:<br>auto 默认<br>crosshair 加号<br>text 文本<br>wait 等待<br>help 帮助<br>progress 过程<br>inherit 继承<br>move 移动<br>ne-resize 向上或向右移动<br>pointer 手形</li>\n<li>透明属性<br>IE 浏览器写法：filter:alpha(opacity=数值);取值范围 1-100(IE8 以下)<br>兼容其他浏览器写法：opacity:数值;(数值的取值范围 0-1,0.1,0.2,0.3—–0.9)</li>\n<li>当 li 里的 A 加 display:block 或 float:left 时，出现行高不一致，有的会多出 3 像素；<br>hack1：给 a 加display:inline-block;<br>Hack3：给 li 加 float，并加宽度；</li>\n<li>当 li 加 float 属性，并且 li 里的 A 转换成块元素,并给 a 加了高度时，IE6 里会出现每个 LI 单独占一行或阶梯状的情况；<br>hack1：不给 a 标签加高度；<br>Hack2：给 a 标签也添加 float；</li>\n<li>父元素里有块元素，如果给子元素添加添加margin-top,父元素会下来。<br>Hack1：给父元素添加overflow:hidden;<br>Hack2：给子元素添加 float；<br>Hack3：给父元素加边框；</li>\n</ol>\n<p>或者用其他的方法达到我们想要的效果：如给父元素加padding-top</p>\n<h3 id=\"图片整合-精灵图\"><a href=\"#图片整合-精灵图\" class=\"headerlink\" title=\"图片整合(精灵图)\"></a>图片整合(精灵图)</h3><p>用 background-position”来实现背景图片的定位技术,这种技术可以成为 css sprites 技术，又称为 css 精灵。</p>\n<p>将导航背景图片，按钮、背景小图标等小图片有规则的合并成一张背景图，即将多张图片合为一张整图，再利用 background 属性进行背景定位，用数字精确的定位出背景图片在布局盒子中的位置；</p>\n<p>优点: 1)通过图片整合来减少对服务器的请求次数，从而提高 页面的加载速度。 2)通过整合图片来减小图片的体积。</p>\n<p>注意点: 1)根据实际容器的大小，小图片和小图片之间要留有足够的空间 2)开发和修改时需要精确测量每一个背景单元的精确位置，测量和修改起来比较麻烦。</p>\n<p>滑动门技术:</p>\n<ol>\n<li>什么是滑动门<br>滑动门是一个形象的称呼，它利用 CSS 背景图像可层叠性，并允许彼此之上进行滑动来创造一些特殊动态效果</li>\n<li>滑动门特征<br>通过滑动门技术，可以使 CSS 设计出来的导航菜单兼具传统布局的图像效果，与 CSS 布局的高效扩展性 。</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"数组","date":"2019-11-21T16:00:00.000Z","_content":"\n### 数组的概念\n\n所谓数组，是有序的元素序列。（一组有序 数据）\nJavaScript 的 Array 可以包含任意数据类型。注：一般来说数组中元素的类型相同\n\n<!--more--> \n\n数组的创建方式\n\n1. 字面量\n\n```js\nvar arr = [1, 2]; //数组中有两个元素\narr.length; //获取数组的长度\narr[i]; //获取数组中的第i个元素，i称为数组的下标或者索引，下标从0开始\narr[0]; //获取数组中的第一个元素\narr[0] = 100; //修改数组中第一个元素的值为100\n```\n\n2. 构造函数方式创建数组\n   Array 是一个构造函数，可以用它生成新的数组\n\n```js\nvar arr = new Array(2);\narr.length; // 2\narr[0]; //undefined\n```\n\n上面代码中，Array 构造函数的参数 2，表示生成一个两个成员的数组。\n\nArray 构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。\n\n```js\n// 单个非数值（比如字符串、布尔值、对象等）作为参数，\n// 则该参数是返回的新数组的成员\nnew Array(\"abc\"); // ['abc']\n// 多参数时，所有参数都是返回的新数组的成员\nnew Array(1, 2); // [1, 2]\nnew Array(\"a\", \"b\", \"c\"); // ['a', 'b', 'c']\n```\n\n可以看到，Array 作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。\n\n### 数组的操作\n\n### push/pop/unshift/shift\n\n1. push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组\n\n```js\nvar arr = [];\narr.push(1); // 1\narr.push(\"a\"); // 2\narr.push(true, {}); // 4\narr; // [1, 'a', true, {}]\n```\n\n2. pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。\n\n```js\nvar arr = [\"a\", \"b\", \"c\"];\narr.pop(); // 'c'\narr; // ['a', 'b']\n```\n\n对空数组使用 pop 方法，不会报错，而是返回 undefined。\n\npush 和 pop 结合使用，就构成了“后进先出”的栈结构（stack）。\n\n```js\nvar arr = [];\narr.push(1, 2);\narr.push(3); //1,2,3\narr.pop();\narr; // [1, 2]\n```\n\n上面代码中，3 是最后进入数组的，但是最早离开数组。\n\n3. shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.shift(); // 'a'\na; // ['b', 'c']\n```\n\npush 和 shift 结合使用，就构成了“先进先出”的队列结构（queue）。\n\n4. unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.unshift(\"x\"); // 4\na; // ['x', 'a', 'b', 'c']\n```\n\n### slice/splice\n\n1. slice方法用于复制目标数组的一部分，返回一个新数组，原数组不变。\n   arr.slice(start, end);\n   它的第一个参数为起始位置（从 0 开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.slice(0); // [\"a\", \"b\", \"c\"]\na.slice(1); // [\"b\", \"c\"]\na.slice(1, 2); // [\"b\"]\na.slice(2, 6); // [\"c\"]\na.slice(); // [\"a\", \"b\", \"c\"]\n```\n\n上面代码中，最后一个例子 slice 没有参数，实际上等于返回一个原数组的拷贝。\n\n如果 slice 方法的参数是负数，则表示倒数计算的位置。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.slice(-2); // [\"b\", \"c\"]\na.slice(-2, -1); // [\"b\"]\n```\n\n上面代码中，-2 表示倒数计算的第二个位置，-1 表示倒数计算的第一个位置。\n\n如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.slice(4); // []\na.slice(2, 1); // []\n```\n\n2. splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。\narr.splice(start, count, addElement1, addElement2, ...);\nsplice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。\n\n```js\nvar a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\na.splice(4, 2); // [\"e\", \"f\"]\na; // [\"a\", \"b\", \"c\", \"d\"]\n```\n上面代码从原数组 4 号位置，删除了两个数组成员。\n\n```js\nvar a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\na.splice(4, 2, 1, 2); // [\"e\", \"f\"]\na; // [\"a\", \"b\", \"c\", \"d\", 1, 2]\n```\n上面代码除了删除成员，还插入了两个新成员。\n起始位置如果是负数，就表示从倒数位置开始删除。\n\n```js\nvar a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\na.splice(-4, 2); // [\"c\", \"d\"]\n```\n\n上面代码表示，从倒数第四个位置 c 开始删除两个成员。\n\n如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0。\n\n```js\nvar a = [1, 1, 1];\na.splice(1, 0, 2); // []  在 删除位置的前面添加了\na; // [1, 2, 1, 1]\n```\n\n如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。\n\n```js\nvar a = [1, 2, 3, 4];\na.splice(2); // [3, 4]\na; // [1, 2]\n```\n\n### reverse/sort\n\n1. reverse方法用于颠倒排列数组元素，返回改变后的数组(还是原数组)。注意，该方法将改变原数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.reverse(); // [\"c\", \"b\", \"a\"]\na; // [\"c\", \"b\", \"a\"]\n```\n\n2. sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。\n\n```js\n[\"d\", \"c\", \"b\", \"a\"]\n  .sort()\n  [\n    // ['a', 'b', 'c', 'd']\n    (4, 3, 2, 1)\n  ].sort()\n  [\n    // [1, 2, 3, 4]\n    (11, 101)\n  ].sort()\n  [\n    // [101, 11]\n    (10111, 1101, 111)\n  ].sort();\n// [10111, 1101, 111]\n```\n\n上面代码的最后两个例子，需要特殊注意。sort 方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以 101 排在 11 的前面。\n\n如果想让 sort 方法按照自定义方式排序，可以传入一个函数作为参数。\n\n```js\n[10111, 1101, 111].sort(function (a, b) {\n  return a - b; //升序\n});\n// [111, 1101, 10111]\n```\n\n上面代码中，sort 的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于 0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面\n\n### join\njoin 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\n\n```js\nvar a = [1, 2, 3, 4];\na.join(' ') // '1 2 3 4'\na.join(' | ') // \"1 | 2 | 3 | 4\"\na.join() // \"1,2,3,4\"\n//如果数组成员是undefined或null或空位，会被转成空字符串。\n[undefined, null].join('#')\n// '#'\n['a',, 'b'].join('-')\n// 'a--b'\n```\n\n数组的遍历（for）\n整数数组/字符串数组/对象数组/二维数组\nfor-in循环 for(var i in arr)i 是下标\nfor(var i in obj) i 是属性名\n函数的值传递和引用传递\n堆和栈及索引思维\nJSON 表示对象的方法\n随机点名程序\n数组的排序（冒泡，选择）\n\n### 数组的冒泡排序\n\n思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。\n\n即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n\n```js\nvar arr = [5, 1, 3, 2, 4];\n//1,5,3,2,4\n//1 , 3,5,2,4\n//1,3   2,5,4\n//1,3,2    4,      5\n//外层循环 执行4 次，每次找到一个最大的数字放在 尾部\nfor (var i = 0; i < 5 - 1; i++) {\n  console.log(i);\n  for (var j = 0; j < 5 - i - 1; j++) {\n    if (arr[j] > arr[j + 1]) {\n      //交换数组两个元素的值\n      var t = arr[j];\n      arr[j] = arr[j + 1];\n      arr[j + 1] = t;\n    }\n  }\n}\n```\n\n### 选择排序\n\n思路分析：选择排序和冒泡排序类似，跟冒泡不同之处在于，它不是每比较一次就调换位置，\n而是一轮比较完毕，找到最大值(或者最小值)之后，将其放在正确的位置，其他数的位置不变。\n\n```js\n//选择排序 ，每次选择一个最小值 ，放特定位置上\n//外层控制比较轮数，每轮找到最小值 跟i位置上的元素进行交换\nfor (var i = 0; i < array.length - 1; i++) {\n  var minIndex = i;\n  var min = array[i];\n  for (var j = i + 1; j < array.length; j++) {\n    //当循环出来的元素 比最小值 小的时候，最小值发生变化，最小值索引也变化\n    if (min > array[j]) {\n      min = array[j];\n      minIndex = j;\n    }\n  }\n  //确定了最小值以后需要给  i位置上的元素进行交换\n  if (minIndex != i) {\n    var tmp = array[i];\n    array[i] = array[minIndex];\n    array[minIndex] = tmp;\n  }\n}\n```\n\n---\n\n本文作者： 一只野生东子\n","source":"_posts/数组.md","raw":"---\ntitle: 数组\ndate: 2019-11-22\ntags: javaScript、Array\n---\n\n### 数组的概念\n\n所谓数组，是有序的元素序列。（一组有序 数据）\nJavaScript 的 Array 可以包含任意数据类型。注：一般来说数组中元素的类型相同\n\n<!--more--> \n\n数组的创建方式\n\n1. 字面量\n\n```js\nvar arr = [1, 2]; //数组中有两个元素\narr.length; //获取数组的长度\narr[i]; //获取数组中的第i个元素，i称为数组的下标或者索引，下标从0开始\narr[0]; //获取数组中的第一个元素\narr[0] = 100; //修改数组中第一个元素的值为100\n```\n\n2. 构造函数方式创建数组\n   Array 是一个构造函数，可以用它生成新的数组\n\n```js\nvar arr = new Array(2);\narr.length; // 2\narr[0]; //undefined\n```\n\n上面代码中，Array 构造函数的参数 2，表示生成一个两个成员的数组。\n\nArray 构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。\n\n```js\n// 单个非数值（比如字符串、布尔值、对象等）作为参数，\n// 则该参数是返回的新数组的成员\nnew Array(\"abc\"); // ['abc']\n// 多参数时，所有参数都是返回的新数组的成员\nnew Array(1, 2); // [1, 2]\nnew Array(\"a\", \"b\", \"c\"); // ['a', 'b', 'c']\n```\n\n可以看到，Array 作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。\n\n### 数组的操作\n\n### push/pop/unshift/shift\n\n1. push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组\n\n```js\nvar arr = [];\narr.push(1); // 1\narr.push(\"a\"); // 2\narr.push(true, {}); // 4\narr; // [1, 'a', true, {}]\n```\n\n2. pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。\n\n```js\nvar arr = [\"a\", \"b\", \"c\"];\narr.pop(); // 'c'\narr; // ['a', 'b']\n```\n\n对空数组使用 pop 方法，不会报错，而是返回 undefined。\n\npush 和 pop 结合使用，就构成了“后进先出”的栈结构（stack）。\n\n```js\nvar arr = [];\narr.push(1, 2);\narr.push(3); //1,2,3\narr.pop();\narr; // [1, 2]\n```\n\n上面代码中，3 是最后进入数组的，但是最早离开数组。\n\n3. shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.shift(); // 'a'\na; // ['b', 'c']\n```\n\npush 和 shift 结合使用，就构成了“先进先出”的队列结构（queue）。\n\n4. unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.unshift(\"x\"); // 4\na; // ['x', 'a', 'b', 'c']\n```\n\n### slice/splice\n\n1. slice方法用于复制目标数组的一部分，返回一个新数组，原数组不变。\n   arr.slice(start, end);\n   它的第一个参数为起始位置（从 0 开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.slice(0); // [\"a\", \"b\", \"c\"]\na.slice(1); // [\"b\", \"c\"]\na.slice(1, 2); // [\"b\"]\na.slice(2, 6); // [\"c\"]\na.slice(); // [\"a\", \"b\", \"c\"]\n```\n\n上面代码中，最后一个例子 slice 没有参数，实际上等于返回一个原数组的拷贝。\n\n如果 slice 方法的参数是负数，则表示倒数计算的位置。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.slice(-2); // [\"b\", \"c\"]\na.slice(-2, -1); // [\"b\"]\n```\n\n上面代码中，-2 表示倒数计算的第二个位置，-1 表示倒数计算的第一个位置。\n\n如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.slice(4); // []\na.slice(2, 1); // []\n```\n\n2. splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。\narr.splice(start, count, addElement1, addElement2, ...);\nsplice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。\n\n```js\nvar a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\na.splice(4, 2); // [\"e\", \"f\"]\na; // [\"a\", \"b\", \"c\", \"d\"]\n```\n上面代码从原数组 4 号位置，删除了两个数组成员。\n\n```js\nvar a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\na.splice(4, 2, 1, 2); // [\"e\", \"f\"]\na; // [\"a\", \"b\", \"c\", \"d\", 1, 2]\n```\n上面代码除了删除成员，还插入了两个新成员。\n起始位置如果是负数，就表示从倒数位置开始删除。\n\n```js\nvar a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\na.splice(-4, 2); // [\"c\", \"d\"]\n```\n\n上面代码表示，从倒数第四个位置 c 开始删除两个成员。\n\n如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0。\n\n```js\nvar a = [1, 1, 1];\na.splice(1, 0, 2); // []  在 删除位置的前面添加了\na; // [1, 2, 1, 1]\n```\n\n如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。\n\n```js\nvar a = [1, 2, 3, 4];\na.splice(2); // [3, 4]\na; // [1, 2]\n```\n\n### reverse/sort\n\n1. reverse方法用于颠倒排列数组元素，返回改变后的数组(还是原数组)。注意，该方法将改变原数组。\n\n```js\nvar a = [\"a\", \"b\", \"c\"];\na.reverse(); // [\"c\", \"b\", \"a\"]\na; // [\"c\", \"b\", \"a\"]\n```\n\n2. sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。\n\n```js\n[\"d\", \"c\", \"b\", \"a\"]\n  .sort()\n  [\n    // ['a', 'b', 'c', 'd']\n    (4, 3, 2, 1)\n  ].sort()\n  [\n    // [1, 2, 3, 4]\n    (11, 101)\n  ].sort()\n  [\n    // [101, 11]\n    (10111, 1101, 111)\n  ].sort();\n// [10111, 1101, 111]\n```\n\n上面代码的最后两个例子，需要特殊注意。sort 方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以 101 排在 11 的前面。\n\n如果想让 sort 方法按照自定义方式排序，可以传入一个函数作为参数。\n\n```js\n[10111, 1101, 111].sort(function (a, b) {\n  return a - b; //升序\n});\n// [111, 1101, 10111]\n```\n\n上面代码中，sort 的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于 0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面\n\n### join\njoin 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\n\n```js\nvar a = [1, 2, 3, 4];\na.join(' ') // '1 2 3 4'\na.join(' | ') // \"1 | 2 | 3 | 4\"\na.join() // \"1,2,3,4\"\n//如果数组成员是undefined或null或空位，会被转成空字符串。\n[undefined, null].join('#')\n// '#'\n['a',, 'b'].join('-')\n// 'a--b'\n```\n\n数组的遍历（for）\n整数数组/字符串数组/对象数组/二维数组\nfor-in循环 for(var i in arr)i 是下标\nfor(var i in obj) i 是属性名\n函数的值传递和引用传递\n堆和栈及索引思维\nJSON 表示对象的方法\n随机点名程序\n数组的排序（冒泡，选择）\n\n### 数组的冒泡排序\n\n思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。\n\n即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n\n```js\nvar arr = [5, 1, 3, 2, 4];\n//1,5,3,2,4\n//1 , 3,5,2,4\n//1,3   2,5,4\n//1,3,2    4,      5\n//外层循环 执行4 次，每次找到一个最大的数字放在 尾部\nfor (var i = 0; i < 5 - 1; i++) {\n  console.log(i);\n  for (var j = 0; j < 5 - i - 1; j++) {\n    if (arr[j] > arr[j + 1]) {\n      //交换数组两个元素的值\n      var t = arr[j];\n      arr[j] = arr[j + 1];\n      arr[j + 1] = t;\n    }\n  }\n}\n```\n\n### 选择排序\n\n思路分析：选择排序和冒泡排序类似，跟冒泡不同之处在于，它不是每比较一次就调换位置，\n而是一轮比较完毕，找到最大值(或者最小值)之后，将其放在正确的位置，其他数的位置不变。\n\n```js\n//选择排序 ，每次选择一个最小值 ，放特定位置上\n//外层控制比较轮数，每轮找到最小值 跟i位置上的元素进行交换\nfor (var i = 0; i < array.length - 1; i++) {\n  var minIndex = i;\n  var min = array[i];\n  for (var j = i + 1; j < array.length; j++) {\n    //当循环出来的元素 比最小值 小的时候，最小值发生变化，最小值索引也变化\n    if (min > array[j]) {\n      min = array[j];\n      minIndex = j;\n    }\n  }\n  //确定了最小值以后需要给  i位置上的元素进行交换\n  if (minIndex != i) {\n    var tmp = array[i];\n    array[i] = array[minIndex];\n    array[minIndex] = tmp;\n  }\n}\n```\n\n---\n\n本文作者： 一只野生东子\n","slug":"数组","published":1,"updated":"2021-11-26T07:08:14.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2p000y9co3g9wd117p","content":"<h3 id=\"数组的概念\"><a href=\"#数组的概念\" class=\"headerlink\" title=\"数组的概念\"></a>数组的概念</h3><p>所谓数组，是有序的元素序列。（一组有序 数据）<br>JavaScript 的 Array 可以包含任意数据类型。注：一般来说数组中元素的类型相同</p>\n<span id=\"more\"></span> \n\n<p>数组的创建方式</p>\n<ol>\n<li>字面量</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]; <span class=\"comment\">//数组中有两个元素</span></span><br><span class=\"line\">arr.length; <span class=\"comment\">//获取数组的长度</span></span><br><span class=\"line\">arr[i]; <span class=\"comment\">//获取数组中的第i个元素，i称为数组的下标或者索引，下标从0开始</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//获取数组中的第一个元素</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">100</span>; <span class=\"comment\">//修改数组中第一个元素的值为100</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>构造函数方式创建数组<br>Array 是一个构造函数，可以用它生成新的数组</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">arr.length; <span class=\"comment\">// 2</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，Array 构造函数的参数 2，表示生成一个两个成员的数组。</p>\n<p>Array 构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span></span><br><span class=\"line\"><span class=\"comment\">// 则该参数是返回的新数组的成员</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">// [&#x27;abc&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 多参数时，所有参数都是返回的新数组的成员</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>); <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>可以看到，Array 作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>\n<h3 id=\"数组的操作\"><a href=\"#数组的操作\" class=\"headerlink\" title=\"数组的操作\"></a>数组的操作</h3><h3 id=\"push-pop-unshift-shift\"><a href=\"#push-pop-unshift-shift\" class=\"headerlink\" title=\"push/pop/unshift/shift\"></a>push/pop/unshift/shift</h3><ol>\n<li>push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr.push(<span class=\"number\">1</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">arr.push(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\">arr.push(<span class=\"literal\">true</span>, &#123;&#125;); <span class=\"comment\">// 4</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [1, &#x27;a&#x27;, true, &#123;&#125;]</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">arr.pop(); <span class=\"comment\">// &#x27;c&#x27;</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>对空数组使用 pop 方法，不会报错，而是返回 undefined。</p>\n<p>push 和 pop 结合使用，就构成了“后进先出”的栈结构（stack）。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr.push(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">arr.push(<span class=\"number\">3</span>); <span class=\"comment\">//1,2,3</span></span><br><span class=\"line\">arr.pop();</span><br><span class=\"line\">arr; <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，3 是最后进入数组的，但是最早离开数组。</p>\n<ol start=\"3\">\n<li>shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.shift(); <span class=\"comment\">// &#x27;a&#x27;</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>push 和 shift 结合使用，就构成了“先进先出”的队列结构（queue）。</p>\n<ol start=\"4\">\n<li>unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.unshift(<span class=\"string\">&quot;x&quot;</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"slice-splice\"><a href=\"#slice-splice\" class=\"headerlink\" title=\"slice/splice\"></a>slice/splice</h3><ol>\n<li>slice方法用于复制目标数组的一部分，返回一个新数组，原数组不变。<br>arr.slice(start, end);<br>它的第一个参数为起始位置（从 0 开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.slice(<span class=\"number\">0</span>); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>); <span class=\"comment\">// [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;b&quot;]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">2</span>, <span class=\"number\">6</span>); <span class=\"comment\">// [&quot;c&quot;]</span></span><br><span class=\"line\">a.slice(); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，最后一个例子 slice 没有参数，实际上等于返回一个原数组的拷贝。</p>\n<p>如果 slice 方法的参数是负数，则表示倒数计算的位置。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.slice(-<span class=\"number\">2</span>); <span class=\"comment\">// [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\">a.slice(-<span class=\"number\">2</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，-2 表示倒数计算的第二个位置，-1 表示倒数计算的第一个位置。</p>\n<p>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.slice(<span class=\"number\">4</span>); <span class=\"comment\">// []</span></span><br><span class=\"line\">a.slice(<span class=\"number\">2</span>, <span class=\"number\">1</span>); <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。<br>arr.splice(start, count, addElement1, addElement2, …);<br>splice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;f&quot;</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">4</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;e&quot;, &quot;f&quot;]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure></div>\n<p>上面代码从原数组 4 号位置，删除了两个数组成员。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;f&quot;</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;e&quot;, &quot;f&quot;]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span></span><br></pre></td></tr></table></figure></div>\n<p>上面代码除了删除成员，还插入了两个新成员。<br>起始位置如果是负数，就表示从倒数位置开始删除。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;f&quot;</span>];</span><br><span class=\"line\">a.splice(-<span class=\"number\">4</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码表示，从倒数第四个位置 c 开始删除两个成员。</p>\n<p>如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>); <span class=\"comment\">// []  在 删除位置的前面添加了</span></span><br><span class=\"line\">a; <span class=\"comment\">// [1, 2, 1, 1]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">2</span>); <span class=\"comment\">// [3, 4]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"reverse-sort\"><a href=\"#reverse-sort\" class=\"headerlink\" title=\"reverse/sort\"></a>reverse/sort</h3><ol>\n<li>reverse方法用于颠倒排列数组元素，返回改变后的数组(还是原数组)。注意，该方法将改变原数组。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.reverse(); <span class=\"comment\">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;a&quot;</span>]</span><br><span class=\"line\">  .sort()</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class=\"line\">    (<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  ].sort()</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\">    (<span class=\"number\">11</span>, <span class=\"number\">101</span>)</span><br><span class=\"line\">  ].sort()</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">// [101, 11]</span></span><br><span class=\"line\">    (<span class=\"number\">10111</span>, <span class=\"number\">1101</span>, <span class=\"number\">111</span>)</span><br><span class=\"line\">  ].sort();</span><br><span class=\"line\"><span class=\"comment\">// [10111, 1101, 111]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码的最后两个例子，需要特殊注意。sort 方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以 101 排在 11 的前面。</p>\n<p>如果想让 sort 方法按照自定义方式排序，可以传入一个函数作为参数。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">10111</span>, <span class=\"number\">1101</span>, <span class=\"number\">111</span>].sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b; <span class=\"comment\">//升序</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// [111, 1101, 10111]</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上面代码中，sort 的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于 0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>join 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.join(<span class=\"string\">&#x27; &#x27;</span>) <span class=\"comment\">// &#x27;1 2 3 4&#x27;</span></span><br><span class=\"line\">a.join(<span class=\"string\">&#x27; | &#x27;</span>) <span class=\"comment\">// &quot;1 | 2 | 3 | 4&quot;</span></span><br><span class=\"line\">a.join() <span class=\"comment\">// &quot;1,2,3,4&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果数组成员是undefined或null或空位，会被转成空字符串。</span></span><br><span class=\"line\">[<span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>].join(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// &#x27;#&#x27;</span></span><br><span class=\"line\">[<span class=\"string\">&#x27;a&#x27;</span>,, <span class=\"string\">&#x27;b&#x27;</span>].join(<span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// &#x27;a--b&#x27;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>数组的遍历（for）<br>整数数组/字符串数组/对象数组/二维数组<br>for-in循环 for(var i in arr)i 是下标<br>for(var i in obj) i 是属性名<br>函数的值传递和引用传递<br>堆和栈及索引思维<br>JSON 表示对象的方法<br>随机点名程序<br>数组的排序（冒泡，选择）</p>\n<h3 id=\"数组的冒泡排序\"><a href=\"#数组的冒泡排序\" class=\"headerlink\" title=\"数组的冒泡排序\"></a>数组的冒泡排序</h3><p>思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。</p>\n<p>即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">//1,5,3,2,4</span></span><br><span class=\"line\"><span class=\"comment\">//1 , 3,5,2,4</span></span><br><span class=\"line\"><span class=\"comment\">//1,3   2,5,4</span></span><br><span class=\"line\"><span class=\"comment\">//1,3,2    4,      5</span></span><br><span class=\"line\"><span class=\"comment\">//外层循环 执行4 次，每次找到一个最大的数字放在 尾部</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span> - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span> - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//交换数组两个元素的值</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> t = arr[j];</span><br><span class=\"line\">      arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">      arr[j + <span class=\"number\">1</span>] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>思路分析：选择排序和冒泡排序类似，跟冒泡不同之处在于，它不是每比较一次就调换位置，<br>而是一轮比较完毕，找到最大值(或者最小值)之后，将其放在正确的位置，其他数的位置不变。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//选择排序 ，每次选择一个最小值 ，放特定位置上</span></span><br><span class=\"line\"><span class=\"comment\">//外层控制比较轮数，每轮找到最小值 跟i位置上的元素进行交换</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> minIndex = i;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> min = array[i];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当循环出来的元素 比最小值 小的时候，最小值发生变化，最小值索引也变化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (min &gt; array[j]) &#123;</span><br><span class=\"line\">      min = array[j];</span><br><span class=\"line\">      minIndex = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//确定了最小值以后需要给  i位置上的元素进行交换</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = array[i];</span><br><span class=\"line\">    array[i] = array[minIndex];</span><br><span class=\"line\">    array[minIndex] = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"数组的概念\"><a href=\"#数组的概念\" class=\"headerlink\" title=\"数组的概念\"></a>数组的概念</h3><p>所谓数组，是有序的元素序列。（一组有序 数据）<br>JavaScript 的 Array 可以包含任意数据类型。注：一般来说数组中元素的类型相同</p>","more":"<p>数组的创建方式</p>\n<ol>\n<li>字面量</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]; <span class=\"comment\">//数组中有两个元素</span></span><br><span class=\"line\">arr.length; <span class=\"comment\">//获取数组的长度</span></span><br><span class=\"line\">arr[i]; <span class=\"comment\">//获取数组中的第i个元素，i称为数组的下标或者索引，下标从0开始</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//获取数组中的第一个元素</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">100</span>; <span class=\"comment\">//修改数组中第一个元素的值为100</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>构造函数方式创建数组<br>Array 是一个构造函数，可以用它生成新的数组</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">arr.length; <span class=\"comment\">// 2</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，Array 构造函数的参数 2，表示生成一个两个成员的数组。</p>\n<p>Array 构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span></span><br><span class=\"line\"><span class=\"comment\">// 则该参数是返回的新数组的成员</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">// [&#x27;abc&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 多参数时，所有参数都是返回的新数组的成员</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>); <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，Array 作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>\n<h3 id=\"数组的操作\"><a href=\"#数组的操作\" class=\"headerlink\" title=\"数组的操作\"></a>数组的操作</h3><h3 id=\"push-pop-unshift-shift\"><a href=\"#push-pop-unshift-shift\" class=\"headerlink\" title=\"push/pop/unshift/shift\"></a>push/pop/unshift/shift</h3><ol>\n<li>push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr.push(<span class=\"number\">1</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">arr.push(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\">arr.push(<span class=\"literal\">true</span>, &#123;&#125;); <span class=\"comment\">// 4</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [1, &#x27;a&#x27;, true, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">arr.pop(); <span class=\"comment\">// &#x27;c&#x27;</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<p>对空数组使用 pop 方法，不会报错，而是返回 undefined。</p>\n<p>push 和 pop 结合使用，就构成了“后进先出”的栈结构（stack）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr.push(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">arr.push(<span class=\"number\">3</span>); <span class=\"comment\">//1,2,3</span></span><br><span class=\"line\">arr.pop();</span><br><span class=\"line\">arr; <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，3 是最后进入数组的，但是最早离开数组。</p>\n<ol start=\"3\">\n<li>shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.shift(); <span class=\"comment\">// &#x27;a&#x27;</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<p>push 和 shift 结合使用，就构成了“先进先出”的队列结构（queue）。</p>\n<ol start=\"4\">\n<li>unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.unshift(<span class=\"string\">&quot;x&quot;</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"slice-splice\"><a href=\"#slice-splice\" class=\"headerlink\" title=\"slice/splice\"></a>slice/splice</h3><ol>\n<li>slice方法用于复制目标数组的一部分，返回一个新数组，原数组不变。<br>arr.slice(start, end);<br>它的第一个参数为起始位置（从 0 开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.slice(<span class=\"number\">0</span>); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>); <span class=\"comment\">// [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;b&quot;]</span></span><br><span class=\"line\">a.slice(<span class=\"number\">2</span>, <span class=\"number\">6</span>); <span class=\"comment\">// [&quot;c&quot;]</span></span><br><span class=\"line\">a.slice(); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，最后一个例子 slice 没有参数，实际上等于返回一个原数组的拷贝。</p>\n<p>如果 slice 方法的参数是负数，则表示倒数计算的位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.slice(-<span class=\"number\">2</span>); <span class=\"comment\">// [&quot;b&quot;, &quot;c&quot;]</span></span><br><span class=\"line\">a.slice(-<span class=\"number\">2</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，-2 表示倒数计算的第二个位置，-1 表示倒数计算的第一个位置。</p>\n<p>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.slice(<span class=\"number\">4</span>); <span class=\"comment\">// []</span></span><br><span class=\"line\">a.slice(<span class=\"number\">2</span>, <span class=\"number\">1</span>); <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。<br>arr.splice(start, count, addElement1, addElement2, …);<br>splice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;f&quot;</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">4</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;e&quot;, &quot;f&quot;]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码从原数组 4 号位置，删除了两个数组成员。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;f&quot;</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;e&quot;, &quot;f&quot;]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码除了删除成员，还插入了两个新成员。<br>起始位置如果是负数，就表示从倒数位置开始删除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;f&quot;</span>];</span><br><span class=\"line\">a.splice(-<span class=\"number\">4</span>, <span class=\"number\">2</span>); <span class=\"comment\">// [&quot;c&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示，从倒数第四个位置 c 开始删除两个成员。</p>\n<p>如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>); <span class=\"comment\">// []  在 删除位置的前面添加了</span></span><br><span class=\"line\">a; <span class=\"comment\">// [1, 2, 1, 1]</span></span><br></pre></td></tr></table></figure>\n\n<p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">2</span>); <span class=\"comment\">// [3, 4]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reverse-sort\"><a href=\"#reverse-sort\" class=\"headerlink\" title=\"reverse/sort\"></a>reverse/sort</h3><ol>\n<li>reverse方法用于颠倒排列数组元素，返回改变后的数组(还是原数组)。注意，该方法将改变原数组。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">a.reverse(); <span class=\"comment\">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br><span class=\"line\">a; <span class=\"comment\">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;a&quot;</span>]</span><br><span class=\"line\">  .sort()</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class=\"line\">    (<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  ].sort()</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\">    (<span class=\"number\">11</span>, <span class=\"number\">101</span>)</span><br><span class=\"line\">  ].sort()</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">// [101, 11]</span></span><br><span class=\"line\">    (<span class=\"number\">10111</span>, <span class=\"number\">1101</span>, <span class=\"number\">111</span>)</span><br><span class=\"line\">  ].sort();</span><br><span class=\"line\"><span class=\"comment\">// [10111, 1101, 111]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的最后两个例子，需要特殊注意。sort 方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以 101 排在 11 的前面。</p>\n<p>如果想让 sort 方法按照自定义方式排序，可以传入一个函数作为参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">10111</span>, <span class=\"number\">1101</span>, <span class=\"number\">111</span>].sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b; <span class=\"comment\">//升序</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// [111, 1101, 10111]</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，sort 的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于 0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>join 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.join(<span class=\"string\">&#x27; &#x27;</span>) <span class=\"comment\">// &#x27;1 2 3 4&#x27;</span></span><br><span class=\"line\">a.join(<span class=\"string\">&#x27; | &#x27;</span>) <span class=\"comment\">// &quot;1 | 2 | 3 | 4&quot;</span></span><br><span class=\"line\">a.join() <span class=\"comment\">// &quot;1,2,3,4&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//如果数组成员是undefined或null或空位，会被转成空字符串。</span></span><br><span class=\"line\">[<span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>].join(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// &#x27;#&#x27;</span></span><br><span class=\"line\">[<span class=\"string\">&#x27;a&#x27;</span>,, <span class=\"string\">&#x27;b&#x27;</span>].join(<span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// &#x27;a--b&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>数组的遍历（for）<br>整数数组/字符串数组/对象数组/二维数组<br>for-in循环 for(var i in arr)i 是下标<br>for(var i in obj) i 是属性名<br>函数的值传递和引用传递<br>堆和栈及索引思维<br>JSON 表示对象的方法<br>随机点名程序<br>数组的排序（冒泡，选择）</p>\n<h3 id=\"数组的冒泡排序\"><a href=\"#数组的冒泡排序\" class=\"headerlink\" title=\"数组的冒泡排序\"></a>数组的冒泡排序</h3><p>思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。</p>\n<p>即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">//1,5,3,2,4</span></span><br><span class=\"line\"><span class=\"comment\">//1 , 3,5,2,4</span></span><br><span class=\"line\"><span class=\"comment\">//1,3   2,5,4</span></span><br><span class=\"line\"><span class=\"comment\">//1,3,2    4,      5</span></span><br><span class=\"line\"><span class=\"comment\">//外层循环 执行4 次，每次找到一个最大的数字放在 尾部</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span> - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span> - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//交换数组两个元素的值</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> t = arr[j];</span><br><span class=\"line\">      arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">      arr[j + <span class=\"number\">1</span>] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>思路分析：选择排序和冒泡排序类似，跟冒泡不同之处在于，它不是每比较一次就调换位置，<br>而是一轮比较完毕，找到最大值(或者最小值)之后，将其放在正确的位置，其他数的位置不变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//选择排序 ，每次选择一个最小值 ，放特定位置上</span></span><br><span class=\"line\"><span class=\"comment\">//外层控制比较轮数，每轮找到最小值 跟i位置上的元素进行交换</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> minIndex = i;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> min = array[i];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当循环出来的元素 比最小值 小的时候，最小值发生变化，最小值索引也变化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (min &gt; array[j]) &#123;</span><br><span class=\"line\">      min = array[j];</span><br><span class=\"line\">      minIndex = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//确定了最小值以后需要给  i位置上的元素进行交换</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = array[i];</span><br><span class=\"line\">    array[i] = array[minIndex];</span><br><span class=\"line\">    array[minIndex] = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"盒模型","date":"2019-10-25T16:00:00.000Z","_content":"\n### 盒模型的概念\n\ncss 定义的所有元素都可以拥有像盒子一样的外形和平面空间，它是 css 布局的基石，它规定了网页元素如何显示以及元素间相互关系。\n\n### 盒模型的组成\n\nCSS 盒子模式都具备这些属性：内容(content)、填充(padding)、边框(border)、边界(margin)\n\n<!--more--> \n\n用日常生活的盒子来理解这四个属性\n\n1. 内容（content）盒子里装的东西；\n2. 填充（padding）就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；\n3. 边框（border）盒子本身；\n4. 边界（margin）盒子与盒子之间的空隙，或者是大盒子与嵌套在里面的小盒子之间的空隙。\n\n### padding 属性\n\n### padding 的定义\n\n1. padding 是元素内容到元素边框之间的距离，叫内填充、补白或内边距\n2. padding 区域内会显示背景色和背景图片\n\n### padding 的用法\n\n1. 用来调整内容在容器中的位置关系\n2. 用来调整子元素在父元素中的位置关系。（注：padding 属性需要添加在父元素上。）\n3. padding 值是额外加在元素原有大小之上的，如想保证元素大小不变，需从元素宽或高上减掉后添加的padding 属性值。\n\n### 四种表示形式\n\n一个值：padding:2px; 四周的填充都是 2px\n二个值：padding:10px   20px ; 上下     左右  \n三个值：padding:10px   20px   30px ; 上     左右     下\n四个值：padding:10px   20px   30px   40px; 上    右    下    左\n\n### margin 属性\n\n边界：margin,在元素外边的空白区域，被称为外边距。\nmargin-left:左边界\nmargin-right:右边界\nmargin-top:上边界\nmargin-bottom:下边界\n\n属性值的 4 种方式:\n四个值：上 右 下 左\n三个值：上 左右 下\n二个值：上下 左右\n一个值：四个方向\n\n```css\nmargin: 2px; /*定义元素四边边界为2px*/\nmargin: 2px 4px; /*定义元素上下边界为2px，左右边界为4px*/\nmargin: 2px 4px 6px; /*定义元素上边界为2px，左右边界4px，下边界为6px，*/\nmargin: 2px 4px 6px 8px; /*定义元素上、右边界为2px，下右边界为6px，左边界为8px*/\nmargin: 0 auto; /*在浏览器中横向居中*/\n```\n\n定义元素上、下边界为 2px\n说明：可单独设置一方向边界，如：margin-top:10px;\n\n### border 的使用方法\n\nborder:边框宽度 边框风格 边框颜色;\n例如：border:5px solid #f00\n\n边框：border,网页中很多修饰性线条都是由边框来实现的\n边框宽度：border-width:\n边框颜色：border-color:\n边框样式：border-style:solid(实线)/dashed(虚线)dotted(点划线)double(双线)\n\n### 元素总尺寸计算方法\n\nwidth 和 height 属性\n在 CSS 中，width 和 height 指的是内容区域的宽度和高度。\n注意：增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素的总尺寸。\n\n盒子的实际大小：\n实际宽 =左右 margin+左右 border+左右 padding+width\n实际高 =上下 margin+上下 border+上下 padding+height\n\n### 单行文本溢出显示省略号的方法\n\n1. 容器宽度：width:value；\n2. 强制文本在一行内显示: white-space:nowrap;\n3. 溢出内容为隐藏：overflow:hidden;\n4. 溢出文本显示省略号：text-overflow:ellipsis;\n\n### 容器的溢出属性\n\noverflow:visible/hidden(隐藏)/scroll/auto(自动)/inherit;\nvisible:默认值，\nhidden：溢出容器的部分会隐藏；\nscroll：强制出现滚动条，如果有溢出，滚动条可以滚动，显示隐藏的部分;\nauto：如果内容有溢出会显示滚动条，如果没有溢出就不显示滚动条；\ninherit：从父元素继承 overflow 属性的值。\n\n### 空余空间\n\nwhite-space：normal/pre/nowrap/pre-wrap /pre-line /inherit\n该属性用来设置如何处理元素内的空白；\nnormal：默认值，空白会被浏览器忽略，\npre：空白会被浏览器保留，其行为方式类似 HTML 中的 pre 标签；\nnowrap:文本不会换行，文本会在同一行上继续，直到遇到换行标签为止；\npre-wrap：保留空白符序列，但是正常的进行换行；\npre-line:合并空白符序列，但是保留换行符；\ninherit：规定应该从父元素继承 White-space 属性的值；(ie 浏览器不支持此属性值)\n\n### 文本溢出:text-overflow:clip/ellipsis\n\n取值：\nclip：不显示省略号（…），而是简单的裁切;\nellipsis：当对象内文本溢出时，显示省略标记；\n\n---\n\n本文作者： 一只野生东子","source":"_posts/盒模型.md","raw":"---\ntitle: 盒模型\ndate: 2019-10-26\ntags: css、盒模型\n---\n\n### 盒模型的概念\n\ncss 定义的所有元素都可以拥有像盒子一样的外形和平面空间，它是 css 布局的基石，它规定了网页元素如何显示以及元素间相互关系。\n\n### 盒模型的组成\n\nCSS 盒子模式都具备这些属性：内容(content)、填充(padding)、边框(border)、边界(margin)\n\n<!--more--> \n\n用日常生活的盒子来理解这四个属性\n\n1. 内容（content）盒子里装的东西；\n2. 填充（padding）就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；\n3. 边框（border）盒子本身；\n4. 边界（margin）盒子与盒子之间的空隙，或者是大盒子与嵌套在里面的小盒子之间的空隙。\n\n### padding 属性\n\n### padding 的定义\n\n1. padding 是元素内容到元素边框之间的距离，叫内填充、补白或内边距\n2. padding 区域内会显示背景色和背景图片\n\n### padding 的用法\n\n1. 用来调整内容在容器中的位置关系\n2. 用来调整子元素在父元素中的位置关系。（注：padding 属性需要添加在父元素上。）\n3. padding 值是额外加在元素原有大小之上的，如想保证元素大小不变，需从元素宽或高上减掉后添加的padding 属性值。\n\n### 四种表示形式\n\n一个值：padding:2px; 四周的填充都是 2px\n二个值：padding:10px   20px ; 上下     左右  \n三个值：padding:10px   20px   30px ; 上     左右     下\n四个值：padding:10px   20px   30px   40px; 上    右    下    左\n\n### margin 属性\n\n边界：margin,在元素外边的空白区域，被称为外边距。\nmargin-left:左边界\nmargin-right:右边界\nmargin-top:上边界\nmargin-bottom:下边界\n\n属性值的 4 种方式:\n四个值：上 右 下 左\n三个值：上 左右 下\n二个值：上下 左右\n一个值：四个方向\n\n```css\nmargin: 2px; /*定义元素四边边界为2px*/\nmargin: 2px 4px; /*定义元素上下边界为2px，左右边界为4px*/\nmargin: 2px 4px 6px; /*定义元素上边界为2px，左右边界4px，下边界为6px，*/\nmargin: 2px 4px 6px 8px; /*定义元素上、右边界为2px，下右边界为6px，左边界为8px*/\nmargin: 0 auto; /*在浏览器中横向居中*/\n```\n\n定义元素上、下边界为 2px\n说明：可单独设置一方向边界，如：margin-top:10px;\n\n### border 的使用方法\n\nborder:边框宽度 边框风格 边框颜色;\n例如：border:5px solid #f00\n\n边框：border,网页中很多修饰性线条都是由边框来实现的\n边框宽度：border-width:\n边框颜色：border-color:\n边框样式：border-style:solid(实线)/dashed(虚线)dotted(点划线)double(双线)\n\n### 元素总尺寸计算方法\n\nwidth 和 height 属性\n在 CSS 中，width 和 height 指的是内容区域的宽度和高度。\n注意：增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素的总尺寸。\n\n盒子的实际大小：\n实际宽 =左右 margin+左右 border+左右 padding+width\n实际高 =上下 margin+上下 border+上下 padding+height\n\n### 单行文本溢出显示省略号的方法\n\n1. 容器宽度：width:value；\n2. 强制文本在一行内显示: white-space:nowrap;\n3. 溢出内容为隐藏：overflow:hidden;\n4. 溢出文本显示省略号：text-overflow:ellipsis;\n\n### 容器的溢出属性\n\noverflow:visible/hidden(隐藏)/scroll/auto(自动)/inherit;\nvisible:默认值，\nhidden：溢出容器的部分会隐藏；\nscroll：强制出现滚动条，如果有溢出，滚动条可以滚动，显示隐藏的部分;\nauto：如果内容有溢出会显示滚动条，如果没有溢出就不显示滚动条；\ninherit：从父元素继承 overflow 属性的值。\n\n### 空余空间\n\nwhite-space：normal/pre/nowrap/pre-wrap /pre-line /inherit\n该属性用来设置如何处理元素内的空白；\nnormal：默认值，空白会被浏览器忽略，\npre：空白会被浏览器保留，其行为方式类似 HTML 中的 pre 标签；\nnowrap:文本不会换行，文本会在同一行上继续，直到遇到换行标签为止；\npre-wrap：保留空白符序列，但是正常的进行换行；\npre-line:合并空白符序列，但是保留换行符；\ninherit：规定应该从父元素继承 White-space 属性的值；(ie 浏览器不支持此属性值)\n\n### 文本溢出:text-overflow:clip/ellipsis\n\n取值：\nclip：不显示省略号（…），而是简单的裁切;\nellipsis：当对象内文本溢出时，显示省略标记；\n\n---\n\n本文作者： 一只野生东子","slug":"盒模型","published":1,"updated":"2021-11-26T06:32:36.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2q00109co3cix79x29","content":"<h3 id=\"盒模型的概念\"><a href=\"#盒模型的概念\" class=\"headerlink\" title=\"盒模型的概念\"></a>盒模型的概念</h3><p>css 定义的所有元素都可以拥有像盒子一样的外形和平面空间，它是 css 布局的基石，它规定了网页元素如何显示以及元素间相互关系。</p>\n<h3 id=\"盒模型的组成\"><a href=\"#盒模型的组成\" class=\"headerlink\" title=\"盒模型的组成\"></a>盒模型的组成</h3><p>CSS 盒子模式都具备这些属性：内容(content)、填充(padding)、边框(border)、边界(margin)</p>\n<span id=\"more\"></span> \n\n<p>用日常生活的盒子来理解这四个属性</p>\n<ol>\n<li>内容（content）盒子里装的东西；</li>\n<li>填充（padding）就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；</li>\n<li>边框（border）盒子本身；</li>\n<li>边界（margin）盒子与盒子之间的空隙，或者是大盒子与嵌套在里面的小盒子之间的空隙。</li>\n</ol>\n<h3 id=\"padding-属性\"><a href=\"#padding-属性\" class=\"headerlink\" title=\"padding 属性\"></a>padding 属性</h3><h3 id=\"padding-的定义\"><a href=\"#padding-的定义\" class=\"headerlink\" title=\"padding 的定义\"></a>padding 的定义</h3><ol>\n<li>padding 是元素内容到元素边框之间的距离，叫内填充、补白或内边距</li>\n<li>padding 区域内会显示背景色和背景图片</li>\n</ol>\n<h3 id=\"padding-的用法\"><a href=\"#padding-的用法\" class=\"headerlink\" title=\"padding 的用法\"></a>padding 的用法</h3><ol>\n<li>用来调整内容在容器中的位置关系</li>\n<li>用来调整子元素在父元素中的位置关系。（注：padding 属性需要添加在父元素上。）</li>\n<li>padding 值是额外加在元素原有大小之上的，如想保证元素大小不变，需从元素宽或高上减掉后添加的padding 属性值。</li>\n</ol>\n<h3 id=\"四种表示形式\"><a href=\"#四种表示形式\" class=\"headerlink\" title=\"四种表示形式\"></a>四种表示形式</h3><p>一个值：padding:2px; 四周的填充都是 2px<br>二个值：padding:10px   20px ; 上下     左右<br>三个值：padding:10px   20px   30px ; 上     左右     下<br>四个值：padding:10px   20px   30px   40px; 上    右    下    左</p>\n<h3 id=\"margin-属性\"><a href=\"#margin-属性\" class=\"headerlink\" title=\"margin 属性\"></a>margin 属性</h3><p>边界：margin,在元素外边的空白区域，被称为外边距。<br>margin-left:左边界<br>margin-right:右边界<br>margin-top:上边界<br>margin-bottom:下边界</p>\n<p>属性值的 4 种方式:<br>四个值：上 右 下 左<br>三个值：上 左右 下<br>二个值：上下 左右<br>一个值：四个方向</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span>; <span class=\"comment\">/*定义元素四边边界为2px*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">4px</span>; <span class=\"comment\">/*定义元素上下边界为2px，左右边界为4px*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">4px</span> <span class=\"number\">6px</span>; <span class=\"comment\">/*定义元素上边界为2px，左右边界4px，下边界为6px，*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">4px</span> <span class=\"number\">6px</span> <span class=\"number\">8px</span>; <span class=\"comment\">/*定义元素上、右边界为2px，下右边界为6px，左边界为8px*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto; <span class=\"comment\">/*在浏览器中横向居中*/</span></span><br></pre></td></tr></table></figure></div>\n\n<p>定义元素上、下边界为 2px<br>说明：可单独设置一方向边界，如：margin-top:10px;</p>\n<h3 id=\"border-的使用方法\"><a href=\"#border-的使用方法\" class=\"headerlink\" title=\"border 的使用方法\"></a>border 的使用方法</h3><p>border:边框宽度 边框风格 边框颜色;<br>例如：border:5px solid #f00</p>\n<p>边框：border,网页中很多修饰性线条都是由边框来实现的<br>边框宽度：border-width:<br>边框颜色：border-color:<br>边框样式：border-style:solid(实线)/dashed(虚线)dotted(点划线)double(双线)</p>\n<h3 id=\"元素总尺寸计算方法\"><a href=\"#元素总尺寸计算方法\" class=\"headerlink\" title=\"元素总尺寸计算方法\"></a>元素总尺寸计算方法</h3><p>width 和 height 属性<br>在 CSS 中，width 和 height 指的是内容区域的宽度和高度。<br>注意：增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素的总尺寸。</p>\n<p>盒子的实际大小：<br>实际宽 =左右 margin+左右 border+左右 padding+width<br>实际高 =上下 margin+上下 border+上下 padding+height</p>\n<h3 id=\"单行文本溢出显示省略号的方法\"><a href=\"#单行文本溢出显示省略号的方法\" class=\"headerlink\" title=\"单行文本溢出显示省略号的方法\"></a>单行文本溢出显示省略号的方法</h3><ol>\n<li>容器宽度：width:value；</li>\n<li>强制文本在一行内显示: white-space:nowrap;</li>\n<li>溢出内容为隐藏：overflow:hidden;</li>\n<li>溢出文本显示省略号：text-overflow:ellipsis;</li>\n</ol>\n<h3 id=\"容器的溢出属性\"><a href=\"#容器的溢出属性\" class=\"headerlink\" title=\"容器的溢出属性\"></a>容器的溢出属性</h3><p>overflow:visible/hidden(隐藏)/scroll/auto(自动)/inherit;<br>visible:默认值，<br>hidden：溢出容器的部分会隐藏；<br>scroll：强制出现滚动条，如果有溢出，滚动条可以滚动，显示隐藏的部分;<br>auto：如果内容有溢出会显示滚动条，如果没有溢出就不显示滚动条；<br>inherit：从父元素继承 overflow 属性的值。</p>\n<h3 id=\"空余空间\"><a href=\"#空余空间\" class=\"headerlink\" title=\"空余空间\"></a>空余空间</h3><p>white-space：normal/pre/nowrap/pre-wrap /pre-line /inherit<br>该属性用来设置如何处理元素内的空白；<br>normal：默认值，空白会被浏览器忽略，<br>pre：空白会被浏览器保留，其行为方式类似 HTML 中的 pre 标签；<br>nowrap:文本不会换行，文本会在同一行上继续，直到遇到换行标签为止；<br>pre-wrap：保留空白符序列，但是正常的进行换行；<br>pre-line:合并空白符序列，但是保留换行符；<br>inherit：规定应该从父元素继承 White-space 属性的值；(ie 浏览器不支持此属性值)</p>\n<h3 id=\"文本溢出-text-overflow-clip-ellipsis\"><a href=\"#文本溢出-text-overflow-clip-ellipsis\" class=\"headerlink\" title=\"文本溢出:text-overflow:clip/ellipsis\"></a>文本溢出:text-overflow:clip/ellipsis</h3><p>取值：<br>clip：不显示省略号（…），而是简单的裁切;<br>ellipsis：当对象内文本溢出时，显示省略标记；</p>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"盒模型的概念\"><a href=\"#盒模型的概念\" class=\"headerlink\" title=\"盒模型的概念\"></a>盒模型的概念</h3><p>css 定义的所有元素都可以拥有像盒子一样的外形和平面空间，它是 css 布局的基石，它规定了网页元素如何显示以及元素间相互关系。</p>\n<h3 id=\"盒模型的组成\"><a href=\"#盒模型的组成\" class=\"headerlink\" title=\"盒模型的组成\"></a>盒模型的组成</h3><p>CSS 盒子模式都具备这些属性：内容(content)、填充(padding)、边框(border)、边界(margin)</p>","more":"<p>用日常生活的盒子来理解这四个属性</p>\n<ol>\n<li>内容（content）盒子里装的东西；</li>\n<li>填充（padding）就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；</li>\n<li>边框（border）盒子本身；</li>\n<li>边界（margin）盒子与盒子之间的空隙，或者是大盒子与嵌套在里面的小盒子之间的空隙。</li>\n</ol>\n<h3 id=\"padding-属性\"><a href=\"#padding-属性\" class=\"headerlink\" title=\"padding 属性\"></a>padding 属性</h3><h3 id=\"padding-的定义\"><a href=\"#padding-的定义\" class=\"headerlink\" title=\"padding 的定义\"></a>padding 的定义</h3><ol>\n<li>padding 是元素内容到元素边框之间的距离，叫内填充、补白或内边距</li>\n<li>padding 区域内会显示背景色和背景图片</li>\n</ol>\n<h3 id=\"padding-的用法\"><a href=\"#padding-的用法\" class=\"headerlink\" title=\"padding 的用法\"></a>padding 的用法</h3><ol>\n<li>用来调整内容在容器中的位置关系</li>\n<li>用来调整子元素在父元素中的位置关系。（注：padding 属性需要添加在父元素上。）</li>\n<li>padding 值是额外加在元素原有大小之上的，如想保证元素大小不变，需从元素宽或高上减掉后添加的padding 属性值。</li>\n</ol>\n<h3 id=\"四种表示形式\"><a href=\"#四种表示形式\" class=\"headerlink\" title=\"四种表示形式\"></a>四种表示形式</h3><p>一个值：padding:2px; 四周的填充都是 2px<br>二个值：padding:10px   20px ; 上下     左右<br>三个值：padding:10px   20px   30px ; 上     左右     下<br>四个值：padding:10px   20px   30px   40px; 上    右    下    左</p>\n<h3 id=\"margin-属性\"><a href=\"#margin-属性\" class=\"headerlink\" title=\"margin 属性\"></a>margin 属性</h3><p>边界：margin,在元素外边的空白区域，被称为外边距。<br>margin-left:左边界<br>margin-right:右边界<br>margin-top:上边界<br>margin-bottom:下边界</p>\n<p>属性值的 4 种方式:<br>四个值：上 右 下 左<br>三个值：上 左右 下<br>二个值：上下 左右<br>一个值：四个方向</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span>; <span class=\"comment\">/*定义元素四边边界为2px*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">4px</span>; <span class=\"comment\">/*定义元素上下边界为2px，左右边界为4px*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">4px</span> <span class=\"number\">6px</span>; <span class=\"comment\">/*定义元素上边界为2px，左右边界4px，下边界为6px，*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">4px</span> <span class=\"number\">6px</span> <span class=\"number\">8px</span>; <span class=\"comment\">/*定义元素上、右边界为2px，下右边界为6px，左边界为8px*/</span></span><br><span class=\"line\"><span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto; <span class=\"comment\">/*在浏览器中横向居中*/</span></span><br></pre></td></tr></table></figure>\n\n<p>定义元素上、下边界为 2px<br>说明：可单独设置一方向边界，如：margin-top:10px;</p>\n<h3 id=\"border-的使用方法\"><a href=\"#border-的使用方法\" class=\"headerlink\" title=\"border 的使用方法\"></a>border 的使用方法</h3><p>border:边框宽度 边框风格 边框颜色;<br>例如：border:5px solid #f00</p>\n<p>边框：border,网页中很多修饰性线条都是由边框来实现的<br>边框宽度：border-width:<br>边框颜色：border-color:<br>边框样式：border-style:solid(实线)/dashed(虚线)dotted(点划线)double(双线)</p>\n<h3 id=\"元素总尺寸计算方法\"><a href=\"#元素总尺寸计算方法\" class=\"headerlink\" title=\"元素总尺寸计算方法\"></a>元素总尺寸计算方法</h3><p>width 和 height 属性<br>在 CSS 中，width 和 height 指的是内容区域的宽度和高度。<br>注意：增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素的总尺寸。</p>\n<p>盒子的实际大小：<br>实际宽 =左右 margin+左右 border+左右 padding+width<br>实际高 =上下 margin+上下 border+上下 padding+height</p>\n<h3 id=\"单行文本溢出显示省略号的方法\"><a href=\"#单行文本溢出显示省略号的方法\" class=\"headerlink\" title=\"单行文本溢出显示省略号的方法\"></a>单行文本溢出显示省略号的方法</h3><ol>\n<li>容器宽度：width:value；</li>\n<li>强制文本在一行内显示: white-space:nowrap;</li>\n<li>溢出内容为隐藏：overflow:hidden;</li>\n<li>溢出文本显示省略号：text-overflow:ellipsis;</li>\n</ol>\n<h3 id=\"容器的溢出属性\"><a href=\"#容器的溢出属性\" class=\"headerlink\" title=\"容器的溢出属性\"></a>容器的溢出属性</h3><p>overflow:visible/hidden(隐藏)/scroll/auto(自动)/inherit;<br>visible:默认值，<br>hidden：溢出容器的部分会隐藏；<br>scroll：强制出现滚动条，如果有溢出，滚动条可以滚动，显示隐藏的部分;<br>auto：如果内容有溢出会显示滚动条，如果没有溢出就不显示滚动条；<br>inherit：从父元素继承 overflow 属性的值。</p>\n<h3 id=\"空余空间\"><a href=\"#空余空间\" class=\"headerlink\" title=\"空余空间\"></a>空余空间</h3><p>white-space：normal/pre/nowrap/pre-wrap /pre-line /inherit<br>该属性用来设置如何处理元素内的空白；<br>normal：默认值，空白会被浏览器忽略，<br>pre：空白会被浏览器保留，其行为方式类似 HTML 中的 pre 标签；<br>nowrap:文本不会换行，文本会在同一行上继续，直到遇到换行标签为止；<br>pre-wrap：保留空白符序列，但是正常的进行换行；<br>pre-line:合并空白符序列，但是保留换行符；<br>inherit：规定应该从父元素继承 White-space 属性的值；(ie 浏览器不支持此属性值)</p>\n<h3 id=\"文本溢出-text-overflow-clip-ellipsis\"><a href=\"#文本溢出-text-overflow-clip-ellipsis\" class=\"headerlink\" title=\"文本溢出:text-overflow:clip/ellipsis\"></a>文本溢出:text-overflow:clip/ellipsis</h3><p>取值：<br>clip：不显示省略号（…），而是简单的裁切;<br>ellipsis：当对象内文本溢出时，显示省略标记；</p>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"移动端布局","date":"2020-01-11T16:00:00.000Z","_content":"\n### 响应式网站设计\n\n什么是响应式布局\n\n1. 服务器根据不同的浏览器用户端，为用户呈现不同的页面效果。\n2. 可以让一个网站兼容不同分辨率的设备，给用户更好的视觉使用体验。\n3. 移动互联网催生了响应式布局的诞生。\n\n<!--more--> \n\n响应式设计优缺点\n优点:\n解决了设备之间的差异化展示,让不同的设备达到最优的视觉体验.\n缺点:\n兼容性代码多,工作量大,加载速度受影响\n对原有网站布局会产生影响,用户判断未必精确.\n\n响应式设计的原则\n\n1. 移动优先：在设计的初期就考虑页面如何在多终端展示\n2. 渐进增强：充分发挥硬件设备的最大功能\n\n如何实现响应式布局\n\n1. css3-Media Query：代码简单（媒体查询）\n2. 借助原生 Javascript：主要用于老浏览器上，加载速度慢，不推荐\n3. 第三方的开源框架，如 bootstrap，可以很好的实现浏览器对响应式的支持\n\n基本语法\n外联 CSS 语法\n\n```html\n<link\n  rel=\"“stylesheet”\"\n  href=\"“wide.css”\"\n  media=\"screen and (min-width:320px)\"\n/>\n<link\n  rel=\"“stylesheet”\"\n  href=\"“mobile.css”\"\n  media=\"screen and (max-width:1000px)\"\n/>\n```\n\n内嵌样式的语法\n\n```html\n<style>\n  @media all and  (min-width:500px) { … }\n</style>\n```\n\nCSS 2.1 支持 9 种媒体类型——注意：媒体类型名区分大小写\nbraille ——触觉反馈设备\nembossed ——盲文印刷设备\nhandheld ——小型或手持设备\nprint ——打印机\nprojection ——投影图像，如幻灯\nscreen ——计算机显示器\nspeech ——语音合成器\ntty ——打字机\ntv ——电视类\nall 所有\n\n响应式不同分辨率设置\n\n1. 1024px 显屏\n\n```css\n@media screen and (max-width : 1024px) { /* 样式写在这里 */ }\n```\n\n2. 800px 显屏\n\n```css\n@media screen and (max-width : 800px) { /* 样式写在这里 */ }\n```\n\n3. 640px 显屏\n\n```css\n@media screen and (max-width : 640px) { /* 样式写在这*/ }\n```\n\n4. iPad 横板显屏\n\n```css\n@media screen and (max-device-width: 1024px) and (orientation: landscape) {/*\n样式写在这 */ }\n```\n\n5. iPad 竖板显屏\n\n```css\n@media screen and (max-device-width: 768px) and (orientation: portrait) {/*\n样式写在这 */ }\n```\n\n### 移动端和 PC 端页面布局的不同点\n\n1. 显示设备（屏幕）\n2. 操作（鼠标、指尖）\n3. 浏览器内核:移动端不用考虑 ie，但是各种浏览器内核（手机自带）、微信浏览器内核\n4. 运行设备 移动设备（轻便、迅速、便携） pc 端（体验）\n5. 网络不同 移动 4g（注重速度） pc 光纤（注重体验速度）\n\n### 做移动端页面和 pc 端页面使用的方法也不同\n\n页面设置不同：\n\n1. Meta 标签设置 \n2. 单位=======用来适应不同的移动端屏幕尺寸；\n\nPx 像素。类似绝对单位。其实也是相对单位，相对于屏幕的分辨率；\nPt 磅 点 打印的尺寸\nEm 相对单位，相对于父级的 font-size 1em=父级的 font-size（直接的父级）\nRem 相对单位，相对于根元素的 font-size 1rem=根元素的 font-size\nVw，相对于屏幕的宽度 ，1vw==1%屏幕的宽度\nVh 相对单位，相对于屏幕高度，1vh==1%屏幕的高度\n\n### Meta 标签的设置不同\n\n```html\n<meta\n  name=\"viewport\"\n  content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"\n/>\n```\n\nwidth=device-width:宽度等于当前设备的宽度\nintial-scale:页面首次被显示是可视区域的缩放比例，取值 1.0 则页面按实际尺寸显示，无任何缩放\nmaximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，\nmaximum-scale用户可将页面放大的程序，1.0 将禁止用户放大到实际尺寸之上。\nuser-scalable:是否可对页面进行缩放，no 禁止缩放\n\n### Meta 标签的设置不同及其不同的效果（扩展）\n\n1.强制让文档与设备的宽度保持 1：1\n\n```html\n<meta\n  name=\"viewport\"\n  content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"\n/>\n```\n\n2.忽略页面中的数字识别为电话号码\n\n```html\n<meta name=\"format-detection\" content=\"telephone=no\" />\n3.忽略页面中的邮箱格式为邮箱 <meta name=\"format-detection\" content=\"email=no\" />\n```\n\n4.在 web app 应用下状态条（屏幕顶部条）的颜色\n\n```html\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n```\n\n认识 ppi 、dpr 、dpi\n\n**屏幕尺寸**：指的是屏幕对角线的长度\n**分辨率**：是指宽度上和高度上最多能显示的物理像素点个数\n**点距**：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小\n**PPI**:屏幕像素密度，即每英寸(1 英寸=2.54 厘米)聚集的像素点个数，这里的一英寸还是对角线长度\n**DPI**:每英寸像素点，印刷行业术语。对于电脑屏幕而言和 PPI 是一个意思\n**设备像素**(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。\n**设备独立像素**(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，这个点是没有固定大小的，越小越清晰，然后由相关系统转换为物理像素。\n**css 像素**(也叫虚拟像素)：指的是 CSS 样式代码中使用的逻辑像素，在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是设备像素(device pixel)\n**DPR**(设备像素比)：设备像素比 = 设备像素 / css 像素。(在 Retina 屏的 iphone 上，DPR 为 2，1 个 css 像素相当于 2 个物理像素)\n**每英寸像素**(pixel per inch, ppi/PPI): 它表示的是每英寸所拥有的像素(pixel)数目，更确切的说法应该是像素密度，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。数值越高，代表显示屏能够以越高的密度显示图像。\n**设备像素比**(device pixel ratio, dpr/DPR): 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。如何理解这个概念呢？通俗来说，它是指在开发中 1 个 CSS 像素占用多少设备像素，如 dpr=2 代表 1 个 CSS 像素用 2x2 个设备像素来绘制，这是因为 Retina 屏幕把 2x2 个像素当 1 个像素使用。比如原本 44 像素高的顶部导航栏，在 Retina 屏上用了 88 个像素的高度来显示。导致界面元素都变成 2 倍大小\n\n### vw 和 rem 做适配\n\n1. 只用 vw 单位做适配\n   如果设计稿的尺寸为 750px；那么 100vw=750px; 1vw=7.5px\n2. vw 结合 rem 做适配\n   假如 ui 图的宽度为 1920px，又因为 vw 会把宽度分为 100 份，那 1vw=19.2px，1920/100=19.2（px），现在这样还是不行，不好算，那就算出每 100px 是多少 vw，100px=(约等于)5.21（vw），这样，设根字体 html 为 5.21vw，则 0.18rem=18px（1rem=100px）\n1vw=19.2px 1px= 0.05208 vw 100px=5.21vw\nhtml{font-size:5.21vw} 5.21vw=100px=1rem\n\n### Js 方法获取 HTMLfontsize（需要手动刷新）\n\n```html\n<script>\n  var bw = document.documentElement.clientWidth / 7.2 + \"px\"; //获取屏幕宽度)除以7.2，添加上“px”，7.2是设计稿的宽度除以100后得到的值\n  var htmlTag = document.getElementsByTagName(\"html\")[0]; //在文档里面通过元素名来获取元素，html\n  htmlTag.style.fontSize = bw; //把计算后的值复制给根元素的font-size;1rem=100px\n</script>\n```\n\n```html\n<script>\n  window.onload = function () {\n    /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是\n                           为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/\n    getRem(640, 100);\n  };\n  window.onresize = function () {\n    getRem(640, 100);\n  };\n  function getRem(pwidth, prem) {\n    var html = document.getElementsByTagName(\"html\")[0];\n    var oWidth =\n      document.body.clientWidth || document.documentElement.clientWidth;\n    html.style.fontSize = (oWidth / pwidth) * prem + \"px\";\n  }\n</script>\n```\n\n### 移动端适配方案总结\n\n移动端的适配方案\n\n1. Vw 单位做适配\n   1、设计稿尺寸=100vw 算出 1vw=？Px\n   2、量出来的尺寸换算成 vw 单位书写 css 中；\n2. Vw 结合 rem 适配\n   1、设计稿的尺寸=100vw。算出 1vw=？Px；\n   2、算出 100px=？？vw；\n   3、html{font-size:？？vw}这时 1rem=100px\n   4、量出的尺寸除以 100，就是得出的 rem 单位的值\n3. Js 适配\n   1、引用 js；注意修改 js 中的一个参数，参数值设置成设计稿的尺寸\n   2、直接 1rem=100px;量出的尺寸除以 100，就是得出的 rem 单位的值\n\n--- \n\n本文作者： 一只野生东子\n","source":"_posts/移动端布局.md","raw":"---\ntitle: 移动端布局\ndate: 2020-01-12\ntags: html、css\n---\n\n### 响应式网站设计\n\n什么是响应式布局\n\n1. 服务器根据不同的浏览器用户端，为用户呈现不同的页面效果。\n2. 可以让一个网站兼容不同分辨率的设备，给用户更好的视觉使用体验。\n3. 移动互联网催生了响应式布局的诞生。\n\n<!--more--> \n\n响应式设计优缺点\n优点:\n解决了设备之间的差异化展示,让不同的设备达到最优的视觉体验.\n缺点:\n兼容性代码多,工作量大,加载速度受影响\n对原有网站布局会产生影响,用户判断未必精确.\n\n响应式设计的原则\n\n1. 移动优先：在设计的初期就考虑页面如何在多终端展示\n2. 渐进增强：充分发挥硬件设备的最大功能\n\n如何实现响应式布局\n\n1. css3-Media Query：代码简单（媒体查询）\n2. 借助原生 Javascript：主要用于老浏览器上，加载速度慢，不推荐\n3. 第三方的开源框架，如 bootstrap，可以很好的实现浏览器对响应式的支持\n\n基本语法\n外联 CSS 语法\n\n```html\n<link\n  rel=\"“stylesheet”\"\n  href=\"“wide.css”\"\n  media=\"screen and (min-width:320px)\"\n/>\n<link\n  rel=\"“stylesheet”\"\n  href=\"“mobile.css”\"\n  media=\"screen and (max-width:1000px)\"\n/>\n```\n\n内嵌样式的语法\n\n```html\n<style>\n  @media all and  (min-width:500px) { … }\n</style>\n```\n\nCSS 2.1 支持 9 种媒体类型——注意：媒体类型名区分大小写\nbraille ——触觉反馈设备\nembossed ——盲文印刷设备\nhandheld ——小型或手持设备\nprint ——打印机\nprojection ——投影图像，如幻灯\nscreen ——计算机显示器\nspeech ——语音合成器\ntty ——打字机\ntv ——电视类\nall 所有\n\n响应式不同分辨率设置\n\n1. 1024px 显屏\n\n```css\n@media screen and (max-width : 1024px) { /* 样式写在这里 */ }\n```\n\n2. 800px 显屏\n\n```css\n@media screen and (max-width : 800px) { /* 样式写在这里 */ }\n```\n\n3. 640px 显屏\n\n```css\n@media screen and (max-width : 640px) { /* 样式写在这*/ }\n```\n\n4. iPad 横板显屏\n\n```css\n@media screen and (max-device-width: 1024px) and (orientation: landscape) {/*\n样式写在这 */ }\n```\n\n5. iPad 竖板显屏\n\n```css\n@media screen and (max-device-width: 768px) and (orientation: portrait) {/*\n样式写在这 */ }\n```\n\n### 移动端和 PC 端页面布局的不同点\n\n1. 显示设备（屏幕）\n2. 操作（鼠标、指尖）\n3. 浏览器内核:移动端不用考虑 ie，但是各种浏览器内核（手机自带）、微信浏览器内核\n4. 运行设备 移动设备（轻便、迅速、便携） pc 端（体验）\n5. 网络不同 移动 4g（注重速度） pc 光纤（注重体验速度）\n\n### 做移动端页面和 pc 端页面使用的方法也不同\n\n页面设置不同：\n\n1. Meta 标签设置 \n2. 单位=======用来适应不同的移动端屏幕尺寸；\n\nPx 像素。类似绝对单位。其实也是相对单位，相对于屏幕的分辨率；\nPt 磅 点 打印的尺寸\nEm 相对单位，相对于父级的 font-size 1em=父级的 font-size（直接的父级）\nRem 相对单位，相对于根元素的 font-size 1rem=根元素的 font-size\nVw，相对于屏幕的宽度 ，1vw==1%屏幕的宽度\nVh 相对单位，相对于屏幕高度，1vh==1%屏幕的高度\n\n### Meta 标签的设置不同\n\n```html\n<meta\n  name=\"viewport\"\n  content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"\n/>\n```\n\nwidth=device-width:宽度等于当前设备的宽度\nintial-scale:页面首次被显示是可视区域的缩放比例，取值 1.0 则页面按实际尺寸显示，无任何缩放\nmaximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，\nmaximum-scale用户可将页面放大的程序，1.0 将禁止用户放大到实际尺寸之上。\nuser-scalable:是否可对页面进行缩放，no 禁止缩放\n\n### Meta 标签的设置不同及其不同的效果（扩展）\n\n1.强制让文档与设备的宽度保持 1：1\n\n```html\n<meta\n  name=\"viewport\"\n  content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"\n/>\n```\n\n2.忽略页面中的数字识别为电话号码\n\n```html\n<meta name=\"format-detection\" content=\"telephone=no\" />\n3.忽略页面中的邮箱格式为邮箱 <meta name=\"format-detection\" content=\"email=no\" />\n```\n\n4.在 web app 应用下状态条（屏幕顶部条）的颜色\n\n```html\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n```\n\n认识 ppi 、dpr 、dpi\n\n**屏幕尺寸**：指的是屏幕对角线的长度\n**分辨率**：是指宽度上和高度上最多能显示的物理像素点个数\n**点距**：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小\n**PPI**:屏幕像素密度，即每英寸(1 英寸=2.54 厘米)聚集的像素点个数，这里的一英寸还是对角线长度\n**DPI**:每英寸像素点，印刷行业术语。对于电脑屏幕而言和 PPI 是一个意思\n**设备像素**(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。\n**设备独立像素**(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，这个点是没有固定大小的，越小越清晰，然后由相关系统转换为物理像素。\n**css 像素**(也叫虚拟像素)：指的是 CSS 样式代码中使用的逻辑像素，在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是设备像素(device pixel)\n**DPR**(设备像素比)：设备像素比 = 设备像素 / css 像素。(在 Retina 屏的 iphone 上，DPR 为 2，1 个 css 像素相当于 2 个物理像素)\n**每英寸像素**(pixel per inch, ppi/PPI): 它表示的是每英寸所拥有的像素(pixel)数目，更确切的说法应该是像素密度，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。数值越高，代表显示屏能够以越高的密度显示图像。\n**设备像素比**(device pixel ratio, dpr/DPR): 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。如何理解这个概念呢？通俗来说，它是指在开发中 1 个 CSS 像素占用多少设备像素，如 dpr=2 代表 1 个 CSS 像素用 2x2 个设备像素来绘制，这是因为 Retina 屏幕把 2x2 个像素当 1 个像素使用。比如原本 44 像素高的顶部导航栏，在 Retina 屏上用了 88 个像素的高度来显示。导致界面元素都变成 2 倍大小\n\n### vw 和 rem 做适配\n\n1. 只用 vw 单位做适配\n   如果设计稿的尺寸为 750px；那么 100vw=750px; 1vw=7.5px\n2. vw 结合 rem 做适配\n   假如 ui 图的宽度为 1920px，又因为 vw 会把宽度分为 100 份，那 1vw=19.2px，1920/100=19.2（px），现在这样还是不行，不好算，那就算出每 100px 是多少 vw，100px=(约等于)5.21（vw），这样，设根字体 html 为 5.21vw，则 0.18rem=18px（1rem=100px）\n1vw=19.2px 1px= 0.05208 vw 100px=5.21vw\nhtml{font-size:5.21vw} 5.21vw=100px=1rem\n\n### Js 方法获取 HTMLfontsize（需要手动刷新）\n\n```html\n<script>\n  var bw = document.documentElement.clientWidth / 7.2 + \"px\"; //获取屏幕宽度)除以7.2，添加上“px”，7.2是设计稿的宽度除以100后得到的值\n  var htmlTag = document.getElementsByTagName(\"html\")[0]; //在文档里面通过元素名来获取元素，html\n  htmlTag.style.fontSize = bw; //把计算后的值复制给根元素的font-size;1rem=100px\n</script>\n```\n\n```html\n<script>\n  window.onload = function () {\n    /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是\n                           为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/\n    getRem(640, 100);\n  };\n  window.onresize = function () {\n    getRem(640, 100);\n  };\n  function getRem(pwidth, prem) {\n    var html = document.getElementsByTagName(\"html\")[0];\n    var oWidth =\n      document.body.clientWidth || document.documentElement.clientWidth;\n    html.style.fontSize = (oWidth / pwidth) * prem + \"px\";\n  }\n</script>\n```\n\n### 移动端适配方案总结\n\n移动端的适配方案\n\n1. Vw 单位做适配\n   1、设计稿尺寸=100vw 算出 1vw=？Px\n   2、量出来的尺寸换算成 vw 单位书写 css 中；\n2. Vw 结合 rem 适配\n   1、设计稿的尺寸=100vw。算出 1vw=？Px；\n   2、算出 100px=？？vw；\n   3、html{font-size:？？vw}这时 1rem=100px\n   4、量出的尺寸除以 100，就是得出的 rem 单位的值\n3. Js 适配\n   1、引用 js；注意修改 js 中的一个参数，参数值设置成设计稿的尺寸\n   2、直接 1rem=100px;量出的尺寸除以 100，就是得出的 rem 单位的值\n\n--- \n\n本文作者： 一只野生东子\n","slug":"移动端布局","published":1,"updated":"2021-11-26T08:25:04.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2q00129co33kp51eyx","content":"<h3 id=\"响应式网站设计\"><a href=\"#响应式网站设计\" class=\"headerlink\" title=\"响应式网站设计\"></a>响应式网站设计</h3><p>什么是响应式布局</p>\n<ol>\n<li>服务器根据不同的浏览器用户端，为用户呈现不同的页面效果。</li>\n<li>可以让一个网站兼容不同分辨率的设备，给用户更好的视觉使用体验。</li>\n<li>移动互联网催生了响应式布局的诞生。</li>\n</ol>\n<span id=\"more\"></span> \n\n<p>响应式设计优缺点<br>优点:<br>解决了设备之间的差异化展示,让不同的设备达到最优的视觉体验.<br>缺点:<br>兼容性代码多,工作量大,加载速度受影响<br>对原有网站布局会产生影响,用户判断未必精确.</p>\n<p>响应式设计的原则</p>\n<ol>\n<li>移动优先：在设计的初期就考虑页面如何在多终端展示</li>\n<li>渐进增强：充分发挥硬件设备的最大功能</li>\n</ol>\n<p>如何实现响应式布局</p>\n<ol>\n<li>css3-Media Query：代码简单（媒体查询）</li>\n<li>借助原生 Javascript：主要用于老浏览器上，加载速度慢，不推荐</li>\n<li>第三方的开源框架，如 bootstrap，可以很好的实现浏览器对响应式的支持</li>\n</ol>\n<p>基本语法<br>外联 CSS 语法</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">rel</span>=<span class=\"string\">&quot;“stylesheet”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">href</span>=<span class=\"string\">&quot;“wide.css”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">media</span>=<span class=\"string\">&quot;screen and (min-width:320px)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">rel</span>=<span class=\"string\">&quot;“stylesheet”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">href</span>=<span class=\"string\">&quot;“mobile.css”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">media</span>=<span class=\"string\">&quot;screen and (max-width:1000px)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>内嵌样式的语法</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span>  (<span class=\"attribute\">min-width</span>:<span class=\"number\">500px</span>) &#123; … &#125;</span></span><br><span class=\"line\"><span class=\"css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>CSS 2.1 支持 9 种媒体类型——注意：媒体类型名区分大小写<br>braille ——触觉反馈设备<br>embossed ——盲文印刷设备<br>handheld ——小型或手持设备<br>print ——打印机<br>projection ——投影图像，如幻灯<br>screen ——计算机显示器<br>speech ——语音合成器<br>tty ——打字机<br>tv ——电视类<br>all 所有</p>\n<p>响应式不同分辨率设置</p>\n<ol>\n<li>1024px 显屏</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span> : <span class=\"number\">1024px</span>) &#123; <span class=\"comment\">/* 样式写在这里 */</span> &#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>800px 显屏</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span> : <span class=\"number\">800px</span>) &#123; <span class=\"comment\">/* 样式写在这里 */</span> &#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li>640px 显屏</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span> : <span class=\"number\">640px</span>) &#123; <span class=\"comment\">/* 样式写在这*/</span> &#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"4\">\n<li>iPad 横板显屏</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-device-width</span>: <span class=\"number\">1024px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">orientation</span>: landscape) &#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">样式写在这 */</span> &#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"5\">\n<li>iPad 竖板显屏</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CSS\"><figure class=\"iseeu highlight /css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-device-width</span>: <span class=\"number\">768px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">orientation</span>: portrait) &#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">样式写在这 */</span> &#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"移动端和-PC-端页面布局的不同点\"><a href=\"#移动端和-PC-端页面布局的不同点\" class=\"headerlink\" title=\"移动端和 PC 端页面布局的不同点\"></a>移动端和 PC 端页面布局的不同点</h3><ol>\n<li>显示设备（屏幕）</li>\n<li>操作（鼠标、指尖）</li>\n<li>浏览器内核:移动端不用考虑 ie，但是各种浏览器内核（手机自带）、微信浏览器内核</li>\n<li>运行设备 移动设备（轻便、迅速、便携） pc 端（体验）</li>\n<li>网络不同 移动 4g（注重速度） pc 光纤（注重体验速度）</li>\n</ol>\n<h3 id=\"做移动端页面和-pc-端页面使用的方法也不同\"><a href=\"#做移动端页面和-pc-端页面使用的方法也不同\" class=\"headerlink\" title=\"做移动端页面和 pc 端页面使用的方法也不同\"></a>做移动端页面和 pc 端页面使用的方法也不同</h3><p>页面设置不同：</p>\n<ol>\n<li>Meta 标签设置 </li>\n<li>单位=======用来适应不同的移动端屏幕尺寸；</li>\n</ol>\n<p>Px 像素。类似绝对单位。其实也是相对单位，相对于屏幕的分辨率；<br>Pt 磅 点 打印的尺寸<br>Em 相对单位，相对于父级的 font-size 1em=父级的 font-size（直接的父级）<br>Rem 相对单位，相对于根元素的 font-size 1rem=根元素的 font-size<br>Vw，相对于屏幕的宽度 ，1vw==1%屏幕的宽度<br>Vh 相对单位，相对于屏幕高度，1vh==1%屏幕的高度</p>\n<h3 id=\"Meta-标签的设置不同\"><a href=\"#Meta-标签的设置不同\" class=\"headerlink\" title=\"Meta 标签的设置不同\"></a>Meta 标签的设置不同</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>width=device-width:宽度等于当前设备的宽度<br>intial-scale:页面首次被显示是可视区域的缩放比例，取值 1.0 则页面按实际尺寸显示，无任何缩放<br>maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，<br>maximum-scale用户可将页面放大的程序，1.0 将禁止用户放大到实际尺寸之上。<br>user-scalable:是否可对页面进行缩放，no 禁止缩放</p>\n<h3 id=\"Meta-标签的设置不同及其不同的效果（扩展）\"><a href=\"#Meta-标签的设置不同及其不同的效果（扩展）\" class=\"headerlink\" title=\"Meta 标签的设置不同及其不同的效果（扩展）\"></a>Meta 标签的设置不同及其不同的效果（扩展）</h3><p>1.强制让文档与设备的宽度保持 1：1</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>2.忽略页面中的数字识别为电话号码</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;format-detection&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;telephone=no&quot;</span> /&gt;</span></span><br><span class=\"line\">3.忽略页面中的邮箱格式为邮箱 <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;format-detection&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;email=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>4.在 web app 应用下状态条（屏幕顶部条）的颜色</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;black&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>认识 ppi 、dpr 、dpi</p>\n<p><strong>屏幕尺寸</strong>：指的是屏幕对角线的长度<br><strong>分辨率</strong>：是指宽度上和高度上最多能显示的物理像素点个数<br><strong>点距</strong>：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小<br><strong>PPI</strong>:屏幕像素密度，即每英寸(1 英寸=2.54 厘米)聚集的像素点个数，这里的一英寸还是对角线长度<br><strong>DPI</strong>:每英寸像素点，印刷行业术语。对于电脑屏幕而言和 PPI 是一个意思<br><strong>设备像素</strong>(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。<br><strong>设备独立像素</strong>(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，这个点是没有固定大小的，越小越清晰，然后由相关系统转换为物理像素。<br><strong>css 像素</strong>(也叫虚拟像素)：指的是 CSS 样式代码中使用的逻辑像素，在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是设备像素(device pixel)<br><strong>DPR</strong>(设备像素比)：设备像素比 = 设备像素 / css 像素。(在 Retina 屏的 iphone 上，DPR 为 2，1 个 css 像素相当于 2 个物理像素)<br><strong>每英寸像素</strong>(pixel per inch, ppi/PPI): 它表示的是每英寸所拥有的像素(pixel)数目，更确切的说法应该是像素密度，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。数值越高，代表显示屏能够以越高的密度显示图像。<br><strong>设备像素比</strong>(device pixel ratio, dpr/DPR): 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。如何理解这个概念呢？通俗来说，它是指在开发中 1 个 CSS 像素占用多少设备像素，如 dpr=2 代表 1 个 CSS 像素用 2x2 个设备像素来绘制，这是因为 Retina 屏幕把 2x2 个像素当 1 个像素使用。比如原本 44 像素高的顶部导航栏，在 Retina 屏上用了 88 个像素的高度来显示。导致界面元素都变成 2 倍大小</p>\n<h3 id=\"vw-和-rem-做适配\"><a href=\"#vw-和-rem-做适配\" class=\"headerlink\" title=\"vw 和 rem 做适配\"></a>vw 和 rem 做适配</h3><ol>\n<li>只用 vw 单位做适配<br>如果设计稿的尺寸为 750px；那么 100vw=750px; 1vw=7.5px</li>\n<li>vw 结合 rem 做适配<br>假如 ui 图的宽度为 1920px，又因为 vw 会把宽度分为 100 份，那 1vw=19.2px，1920/100=19.2（px），现在这样还是不行，不好算，那就算出每 100px 是多少 vw，100px=(约等于)5.21（vw），这样，设根字体 html 为 5.21vw，则 0.18rem=18px（1rem=100px）<br>1vw=19.2px 1px= 0.05208 vw 100px=5.21vw<br>html{font-size:5.21vw} 5.21vw=100px=1rem</li>\n</ol>\n<h3 id=\"Js-方法获取-HTMLfontsize（需要手动刷新）\"><a href=\"#Js-方法获取-HTMLfontsize（需要手动刷新）\" class=\"headerlink\" title=\"Js 方法获取 HTMLfontsize（需要手动刷新）\"></a>Js 方法获取 HTMLfontsize（需要手动刷新）</h3><div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> bw = <span class=\"built_in\">document</span>.documentElement.clientWidth / <span class=\"number\">7.2</span> + <span class=\"string\">&quot;px&quot;</span>; <span class=\"comment\">//获取屏幕宽度)除以7.2，添加上“px”，7.2是设计稿的宽度除以100后得到的值</span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> htmlTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;html&quot;</span>)[<span class=\"number\">0</span>]; <span class=\"comment\">//在文档里面通过元素名来获取元素，html</span></span></span><br><span class=\"line\"><span class=\"javascript\">  htmlTag.style.fontSize = bw; <span class=\"comment\">//把计算后的值复制给根元素的font-size;1rem=100px</span></span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"HTML\"><figure class=\"iseeu highlight /html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">/*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"javascript\">                           为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/</span></span></span><br><span class=\"line\"><span class=\"javascript\">    getRem(<span class=\"number\">640</span>, <span class=\"number\">100</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    getRem(<span class=\"number\">640</span>, <span class=\"number\">100</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRem</span>(<span class=\"params\">pwidth, prem</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> html = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;html&quot;</span>)[<span class=\"number\">0</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> oWidth =</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.body.clientWidth || <span class=\"built_in\">document</span>.documentElement.clientWidth;</span></span><br><span class=\"line\"><span class=\"javascript\">    html.style.fontSize = (oWidth / pwidth) * prem + <span class=\"string\">&quot;px&quot;</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"移动端适配方案总结\"><a href=\"#移动端适配方案总结\" class=\"headerlink\" title=\"移动端适配方案总结\"></a>移动端适配方案总结</h3><p>移动端的适配方案</p>\n<ol>\n<li>Vw 单位做适配<br>1、设计稿尺寸=100vw 算出 1vw=？Px<br>2、量出来的尺寸换算成 vw 单位书写 css 中；</li>\n<li>Vw 结合 rem 适配<br>1、设计稿的尺寸=100vw。算出 1vw=？Px；<br>2、算出 100px=？？vw；<br>3、html{font-size:？？vw}这时 1rem=100px<br>4、量出的尺寸除以 100，就是得出的 rem 单位的值</li>\n<li>Js 适配<br>1、引用 js；注意修改 js 中的一个参数，参数值设置成设计稿的尺寸<br>2、直接 1rem=100px;量出的尺寸除以 100，就是得出的 rem 单位的值</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"响应式网站设计\"><a href=\"#响应式网站设计\" class=\"headerlink\" title=\"响应式网站设计\"></a>响应式网站设计</h3><p>什么是响应式布局</p>\n<ol>\n<li>服务器根据不同的浏览器用户端，为用户呈现不同的页面效果。</li>\n<li>可以让一个网站兼容不同分辨率的设备，给用户更好的视觉使用体验。</li>\n<li>移动互联网催生了响应式布局的诞生。</li>\n</ol>","more":"<p>响应式设计优缺点<br>优点:<br>解决了设备之间的差异化展示,让不同的设备达到最优的视觉体验.<br>缺点:<br>兼容性代码多,工作量大,加载速度受影响<br>对原有网站布局会产生影响,用户判断未必精确.</p>\n<p>响应式设计的原则</p>\n<ol>\n<li>移动优先：在设计的初期就考虑页面如何在多终端展示</li>\n<li>渐进增强：充分发挥硬件设备的最大功能</li>\n</ol>\n<p>如何实现响应式布局</p>\n<ol>\n<li>css3-Media Query：代码简单（媒体查询）</li>\n<li>借助原生 Javascript：主要用于老浏览器上，加载速度慢，不推荐</li>\n<li>第三方的开源框架，如 bootstrap，可以很好的实现浏览器对响应式的支持</li>\n</ol>\n<p>基本语法<br>外联 CSS 语法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">rel</span>=<span class=\"string\">&quot;“stylesheet”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">href</span>=<span class=\"string\">&quot;“wide.css”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">media</span>=<span class=\"string\">&quot;screen and (min-width:320px)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">rel</span>=<span class=\"string\">&quot;“stylesheet”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">href</span>=<span class=\"string\">&quot;“mobile.css”&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">media</span>=<span class=\"string\">&quot;screen and (max-width:1000px)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>内嵌样式的语法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span>  (<span class=\"attribute\">min-width</span>:<span class=\"number\">500px</span>) &#123; … &#125;</span></span><br><span class=\"line\"><span class=\"css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>CSS 2.1 支持 9 种媒体类型——注意：媒体类型名区分大小写<br>braille ——触觉反馈设备<br>embossed ——盲文印刷设备<br>handheld ——小型或手持设备<br>print ——打印机<br>projection ——投影图像，如幻灯<br>screen ——计算机显示器<br>speech ——语音合成器<br>tty ——打字机<br>tv ——电视类<br>all 所有</p>\n<p>响应式不同分辨率设置</p>\n<ol>\n<li>1024px 显屏</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span> : <span class=\"number\">1024px</span>) &#123; <span class=\"comment\">/* 样式写在这里 */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>800px 显屏</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span> : <span class=\"number\">800px</span>) &#123; <span class=\"comment\">/* 样式写在这里 */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>640px 显屏</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span> : <span class=\"number\">640px</span>) &#123; <span class=\"comment\">/* 样式写在这*/</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>iPad 横板显屏</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-device-width</span>: <span class=\"number\">1024px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">orientation</span>: landscape) &#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">样式写在这 */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>iPad 竖板显屏</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-device-width</span>: <span class=\"number\">768px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">orientation</span>: portrait) &#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">样式写在这 */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移动端和-PC-端页面布局的不同点\"><a href=\"#移动端和-PC-端页面布局的不同点\" class=\"headerlink\" title=\"移动端和 PC 端页面布局的不同点\"></a>移动端和 PC 端页面布局的不同点</h3><ol>\n<li>显示设备（屏幕）</li>\n<li>操作（鼠标、指尖）</li>\n<li>浏览器内核:移动端不用考虑 ie，但是各种浏览器内核（手机自带）、微信浏览器内核</li>\n<li>运行设备 移动设备（轻便、迅速、便携） pc 端（体验）</li>\n<li>网络不同 移动 4g（注重速度） pc 光纤（注重体验速度）</li>\n</ol>\n<h3 id=\"做移动端页面和-pc-端页面使用的方法也不同\"><a href=\"#做移动端页面和-pc-端页面使用的方法也不同\" class=\"headerlink\" title=\"做移动端页面和 pc 端页面使用的方法也不同\"></a>做移动端页面和 pc 端页面使用的方法也不同</h3><p>页面设置不同：</p>\n<ol>\n<li>Meta 标签设置 </li>\n<li>单位=======用来适应不同的移动端屏幕尺寸；</li>\n</ol>\n<p>Px 像素。类似绝对单位。其实也是相对单位，相对于屏幕的分辨率；<br>Pt 磅 点 打印的尺寸<br>Em 相对单位，相对于父级的 font-size 1em=父级的 font-size（直接的父级）<br>Rem 相对单位，相对于根元素的 font-size 1rem=根元素的 font-size<br>Vw，相对于屏幕的宽度 ，1vw==1%屏幕的宽度<br>Vh 相对单位，相对于屏幕高度，1vh==1%屏幕的高度</p>\n<h3 id=\"Meta-标签的设置不同\"><a href=\"#Meta-标签的设置不同\" class=\"headerlink\" title=\"Meta 标签的设置不同\"></a>Meta 标签的设置不同</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>width=device-width:宽度等于当前设备的宽度<br>intial-scale:页面首次被显示是可视区域的缩放比例，取值 1.0 则页面按实际尺寸显示，无任何缩放<br>maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，<br>maximum-scale用户可将页面放大的程序，1.0 将禁止用户放大到实际尺寸之上。<br>user-scalable:是否可对页面进行缩放，no 禁止缩放</p>\n<h3 id=\"Meta-标签的设置不同及其不同的效果（扩展）\"><a href=\"#Meta-标签的设置不同及其不同的效果（扩展）\" class=\"headerlink\" title=\"Meta 标签的设置不同及其不同的效果（扩展）\"></a>Meta 标签的设置不同及其不同的效果（扩展）</h3><p>1.强制让文档与设备的宽度保持 1：1</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>2.忽略页面中的数字识别为电话号码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;format-detection&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;telephone=no&quot;</span> /&gt;</span></span><br><span class=\"line\">3.忽略页面中的邮箱格式为邮箱 <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;format-detection&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;email=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>4.在 web app 应用下状态条（屏幕顶部条）的颜色</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;black&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>认识 ppi 、dpr 、dpi</p>\n<p><strong>屏幕尺寸</strong>：指的是屏幕对角线的长度<br><strong>分辨率</strong>：是指宽度上和高度上最多能显示的物理像素点个数<br><strong>点距</strong>：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小<br><strong>PPI</strong>:屏幕像素密度，即每英寸(1 英寸=2.54 厘米)聚集的像素点个数，这里的一英寸还是对角线长度<br><strong>DPI</strong>:每英寸像素点，印刷行业术语。对于电脑屏幕而言和 PPI 是一个意思<br><strong>设备像素</strong>(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。<br><strong>设备独立像素</strong>(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，这个点是没有固定大小的，越小越清晰，然后由相关系统转换为物理像素。<br><strong>css 像素</strong>(也叫虚拟像素)：指的是 CSS 样式代码中使用的逻辑像素，在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是设备像素(device pixel)<br><strong>DPR</strong>(设备像素比)：设备像素比 = 设备像素 / css 像素。(在 Retina 屏的 iphone 上，DPR 为 2，1 个 css 像素相当于 2 个物理像素)<br><strong>每英寸像素</strong>(pixel per inch, ppi/PPI): 它表示的是每英寸所拥有的像素(pixel)数目，更确切的说法应该是像素密度，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。数值越高，代表显示屏能够以越高的密度显示图像。<br><strong>设备像素比</strong>(device pixel ratio, dpr/DPR): 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。如何理解这个概念呢？通俗来说，它是指在开发中 1 个 CSS 像素占用多少设备像素，如 dpr=2 代表 1 个 CSS 像素用 2x2 个设备像素来绘制，这是因为 Retina 屏幕把 2x2 个像素当 1 个像素使用。比如原本 44 像素高的顶部导航栏，在 Retina 屏上用了 88 个像素的高度来显示。导致界面元素都变成 2 倍大小</p>\n<h3 id=\"vw-和-rem-做适配\"><a href=\"#vw-和-rem-做适配\" class=\"headerlink\" title=\"vw 和 rem 做适配\"></a>vw 和 rem 做适配</h3><ol>\n<li>只用 vw 单位做适配<br>如果设计稿的尺寸为 750px；那么 100vw=750px; 1vw=7.5px</li>\n<li>vw 结合 rem 做适配<br>假如 ui 图的宽度为 1920px，又因为 vw 会把宽度分为 100 份，那 1vw=19.2px，1920/100=19.2（px），现在这样还是不行，不好算，那就算出每 100px 是多少 vw，100px=(约等于)5.21（vw），这样，设根字体 html 为 5.21vw，则 0.18rem=18px（1rem=100px）<br>1vw=19.2px 1px= 0.05208 vw 100px=5.21vw<br>html{font-size:5.21vw} 5.21vw=100px=1rem</li>\n</ol>\n<h3 id=\"Js-方法获取-HTMLfontsize（需要手动刷新）\"><a href=\"#Js-方法获取-HTMLfontsize（需要手动刷新）\" class=\"headerlink\" title=\"Js 方法获取 HTMLfontsize（需要手动刷新）\"></a>Js 方法获取 HTMLfontsize（需要手动刷新）</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> bw = <span class=\"built_in\">document</span>.documentElement.clientWidth / <span class=\"number\">7.2</span> + <span class=\"string\">&quot;px&quot;</span>; <span class=\"comment\">//获取屏幕宽度)除以7.2，添加上“px”，7.2是设计稿的宽度除以100后得到的值</span></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> htmlTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;html&quot;</span>)[<span class=\"number\">0</span>]; <span class=\"comment\">//在文档里面通过元素名来获取元素，html</span></span></span><br><span class=\"line\"><span class=\"javascript\">  htmlTag.style.fontSize = bw; <span class=\"comment\">//把计算后的值复制给根元素的font-size;1rem=100px</span></span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">/*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"javascript\">                           为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/</span></span></span><br><span class=\"line\"><span class=\"javascript\">    getRem(<span class=\"number\">640</span>, <span class=\"number\">100</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">window</span>.onresize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    getRem(<span class=\"number\">640</span>, <span class=\"number\">100</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRem</span>(<span class=\"params\">pwidth, prem</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> html = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;html&quot;</span>)[<span class=\"number\">0</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> oWidth =</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.body.clientWidth || <span class=\"built_in\">document</span>.documentElement.clientWidth;</span></span><br><span class=\"line\"><span class=\"javascript\">    html.style.fontSize = (oWidth / pwidth) * prem + <span class=\"string\">&quot;px&quot;</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移动端适配方案总结\"><a href=\"#移动端适配方案总结\" class=\"headerlink\" title=\"移动端适配方案总结\"></a>移动端适配方案总结</h3><p>移动端的适配方案</p>\n<ol>\n<li>Vw 单位做适配<br>1、设计稿尺寸=100vw 算出 1vw=？Px<br>2、量出来的尺寸换算成 vw 单位书写 css 中；</li>\n<li>Vw 结合 rem 适配<br>1、设计稿的尺寸=100vw。算出 1vw=？Px；<br>2、算出 100px=？？vw；<br>3、html{font-size:？？vw}这时 1rem=100px<br>4、量出的尺寸除以 100，就是得出的 rem 单位的值</li>\n<li>Js 适配<br>1、引用 js；注意修改 js 中的一个参数，参数值设置成设计稿的尺寸<br>2、直接 1rem=100px;量出的尺寸除以 100，就是得出的 rem 单位的值</li>\n</ol>\n<hr>\n<p>本文作者： 一只野生东子</p>"},{"title":"面向对象概念","date":"2020-04-13T16:00:00.000Z","_content":"\n### 面向对象概念\n\n面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了\n程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、\n分布式系统、网络管理结构、CAD 技术、人工 智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物，是一种高级的编程思想。\n面向对象是一种思想，很多种语言之中都有面向对象的思想，这种思想已经不同于面向过程的逻辑了。\n面向对象：只关注对象提供的功能， 不关注内部的细节。\n面向对象的特点：（封装，继承，多态）\n\n<!--more--> \n\n对象的组成：\n方法 和 属性\n什么是方法和属性呢？\n```var timer=null```\n```DOM.timer=null```\n\n1. 构造函数的使用\n   js 提供的构造函数 New Date();\n   自己定义的构造函数\n2. 构造函数和对象的关系\n   New 加构造函数创建对象\n3. 使用 Json 创建对象\n\n```js\n{ \"name\": \"wangcai\", \"age\": 2 }\n```\n\n4. 面相对象和面相过程的区别\n   面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。\n   面向对象： 狗.吃(X)\n   面向过程： 吃.(狗,X)\n   应用：\n   掌握面相对象编程的好处（继承 封装 多态）\n### 类\n\n1. 类的概念\n   类的概念 ： 类是具有相同属性和方法的一组对象的集合。为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分\n2. 类和对象\n   类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。类描述了一组有相同特性( 属性 ) 和相同行为 ( 方法 ) 的对象。\n3. JSON 字符串和对象直接的转换\n\n```js\nvar A = '{ \"a\" : 1 , \"b\" : \"hello\" }';\nJSON.parse(A);\nJSON.stringify();\n```\n\n### eval 函数\n\neval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。\n\n```js\neval(\"x=10;y=20;document.write(x*y)\");\ndocument.write(eval(\"2+2\"));\nvar x = 10;\ndocument.write(eval(x + 17));\n\neval(\"(\" + A + \")\"); //把字符串 转为对象\n```\n\n---\n\n本文作者： 一只野生东子","source":"_posts/面向对象.md","raw":"---\ntitle: 面向对象概念\ndate: 2020-04-14\ntags: javaScript\n---\n\n### 面向对象概念\n\n面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了\n程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、\n分布式系统、网络管理结构、CAD 技术、人工 智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物，是一种高级的编程思想。\n面向对象是一种思想，很多种语言之中都有面向对象的思想，这种思想已经不同于面向过程的逻辑了。\n面向对象：只关注对象提供的功能， 不关注内部的细节。\n面向对象的特点：（封装，继承，多态）\n\n<!--more--> \n\n对象的组成：\n方法 和 属性\n什么是方法和属性呢？\n```var timer=null```\n```DOM.timer=null```\n\n1. 构造函数的使用\n   js 提供的构造函数 New Date();\n   自己定义的构造函数\n2. 构造函数和对象的关系\n   New 加构造函数创建对象\n3. 使用 Json 创建对象\n\n```js\n{ \"name\": \"wangcai\", \"age\": 2 }\n```\n\n4. 面相对象和面相过程的区别\n   面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。\n   面向对象： 狗.吃(X)\n   面向过程： 吃.(狗,X)\n   应用：\n   掌握面相对象编程的好处（继承 封装 多态）\n### 类\n\n1. 类的概念\n   类的概念 ： 类是具有相同属性和方法的一组对象的集合。为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分\n2. 类和对象\n   类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。类描述了一组有相同特性( 属性 ) 和相同行为 ( 方法 ) 的对象。\n3. JSON 字符串和对象直接的转换\n\n```js\nvar A = '{ \"a\" : 1 , \"b\" : \"hello\" }';\nJSON.parse(A);\nJSON.stringify();\n```\n\n### eval 函数\n\neval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。\n\n```js\neval(\"x=10;y=20;document.write(x*y)\");\ndocument.write(eval(\"2+2\"));\nvar x = 10;\ndocument.write(eval(x + 17));\n\neval(\"(\" + A + \")\"); //把字符串 转为对象\n```\n\n---\n\n本文作者： 一只野生东子","slug":"面向对象","published":1,"updated":"2021-11-26T08:54:34.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwk82j2r00149co3328n8fuv","content":"<h3 id=\"面向对象概念\"><a href=\"#面向对象概念\" class=\"headerlink\" title=\"面向对象概念\"></a>面向对象概念</h3><p>面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了<br>程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、<br>分布式系统、网络管理结构、CAD 技术、人工 智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物，是一种高级的编程思想。<br>面向对象是一种思想，很多种语言之中都有面向对象的思想，这种思想已经不同于面向过程的逻辑了。<br>面向对象：只关注对象提供的功能， 不关注内部的细节。<br>面向对象的特点：（封装，继承，多态）</p>\n<span id=\"more\"></span> \n\n<p>对象的组成：<br>方法 和 属性<br>什么是方法和属性呢？<br><code>var timer=null</code><br><code>DOM.timer=null</code></p>\n<ol>\n<li>构造函数的使用<br>js 提供的构造函数 New Date();<br>自己定义的构造函数</li>\n<li>构造函数和对象的关系<br>New 加构造函数创建对象</li>\n<li>使用 Json 创建对象</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;wangcai&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"4\">\n<li><p>面相对象和面相过程的区别<br>面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。<br>面向对象： 狗.吃(X)<br>面向过程： 吃.(狗,X)<br>应用：<br>掌握面相对象编程的好处（继承 封装 多态）</p>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3></li>\n<li><p>类的概念<br>类的概念 ： 类是具有相同属性和方法的一组对象的集合。为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分</p>\n</li>\n<li><p>类和对象<br>类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。类描述了一组有相同特性( 属性 ) 和相同行为 ( 方法 ) 的对象。</p>\n</li>\n<li><p>JSON 字符串和对象直接的转换</p>\n</li>\n</ol>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"string\">&#x27;&#123; &quot;a&quot; : 1 , &quot;b&quot; : &quot;hello&quot; &#125;&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(A);</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify();</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"eval-函数\"><a href=\"#eval-函数\" class=\"headerlink\" title=\"eval 函数\"></a>eval 函数</h3><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>\n<div class=\"highlight-box\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight /js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">&quot;x=10;y=20;document.write(x*y)&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">eval</span>(<span class=\"string\">&quot;2+2&quot;</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">eval</span>(x + <span class=\"number\">17</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">&quot;(&quot;</span> + A + <span class=\"string\">&quot;)&quot;</span>); <span class=\"comment\">//把字符串 转为对象</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>本文作者： 一只野生东子</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"面向对象概念\"><a href=\"#面向对象概念\" class=\"headerlink\" title=\"面向对象概念\"></a>面向对象概念</h3><p>面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了<br>程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、<br>分布式系统、网络管理结构、CAD 技术、人工 智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物，是一种高级的编程思想。<br>面向对象是一种思想，很多种语言之中都有面向对象的思想，这种思想已经不同于面向过程的逻辑了。<br>面向对象：只关注对象提供的功能， 不关注内部的细节。<br>面向对象的特点：（封装，继承，多态）</p>","more":"<p>对象的组成：<br>方法 和 属性<br>什么是方法和属性呢？<br><code>var timer=null</code><br><code>DOM.timer=null</code></p>\n<ol>\n<li>构造函数的使用<br>js 提供的构造函数 New Date();<br>自己定义的构造函数</li>\n<li>构造函数和对象的关系<br>New 加构造函数创建对象</li>\n<li>使用 Json 创建对象</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;wangcai&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>面相对象和面相过程的区别<br>面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。<br>面向对象： 狗.吃(X)<br>面向过程： 吃.(狗,X)<br>应用：<br>掌握面相对象编程的好处（继承 封装 多态）</p>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3></li>\n<li><p>类的概念<br>类的概念 ： 类是具有相同属性和方法的一组对象的集合。为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分</p>\n</li>\n<li><p>类和对象<br>类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。类描述了一组有相同特性( 属性 ) 和相同行为 ( 方法 ) 的对象。</p>\n</li>\n<li><p>JSON 字符串和对象直接的转换</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"string\">&#x27;&#123; &quot;a&quot; : 1 , &quot;b&quot; : &quot;hello&quot; &#125;&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(A);</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"eval-函数\"><a href=\"#eval-函数\" class=\"headerlink\" title=\"eval 函数\"></a>eval 函数</h3><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">&quot;x=10;y=20;document.write(x*y)&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">eval</span>(<span class=\"string\">&quot;2+2&quot;</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">eval</span>(x + <span class=\"number\">17</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">&quot;(&quot;</span> + A + <span class=\"string\">&quot;)&quot;</span>); <span class=\"comment\">//把字符串 转为对象</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>本文作者： 一只野生东子</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckwk82j2300009co31033bf8q","tag_id":"ckwk82j2900029co38sv00944","_id":"ckwk82j2c00079co3g0r85g3z"},{"post_id":"ckwk82j2700019co345cifszz","tag_id":"ckwk82j2c00069co3hdrpedrn","_id":"ckwk82j2f000c9co358rv544n"},{"post_id":"ckwk82j2a00039co32lth6zkp","tag_id":"ckwk82j2e000a9co349gc3fu7","_id":"ckwk82j2h000g9co3f390528b"},{"post_id":"ckwk82j2b00049co3bndyaibe","tag_id":"ckwk82j2g000e9co3fm8q0o9z","_id":"ckwk82j2j000k9co38ztjc21j"},{"post_id":"ckwk82j2c00059co374vqbld5","tag_id":"ckwk82j2i000i9co31fdz1p4y","_id":"ckwk82j2l000o9co34rz4ctjq"},{"post_id":"ckwk82j2l000p9co36i3992oa","tag_id":"ckwk82j2g000e9co3fm8q0o9z","_id":"ckwk82j2n000s9co3a1y6gk86"},{"post_id":"ckwk82j2e00099co30ykh85aj","tag_id":"ckwk82j2g000e9co3fm8q0o9z","_id":"ckwk82j2o000u9co30zgmcjct"},{"post_id":"ckwk82j2m000q9co3039f2egf","tag_id":"ckwk82j2g000e9co3fm8q0o9z","_id":"ckwk82j2p000x9co3gl8m9wqx"},{"post_id":"ckwk82j2e000b9co32cqy0hqf","tag_id":"ckwk82j2n000r9co31eroenv1","_id":"ckwk82j2q000z9co37zz1bhxe"},{"post_id":"ckwk82j2f000d9co36lzifoic","tag_id":"ckwk82j2g000e9co3fm8q0o9z","_id":"ckwk82j2r00139co3b2wx1j8p"},{"post_id":"ckwk82j2h000f9co34z5g7yu6","tag_id":"ckwk82j2i000i9co31fdz1p4y","_id":"ckwk82j2s00169co33vw58odb"},{"post_id":"ckwk82j2r00149co3328n8fuv","tag_id":"ckwk82j2g000e9co3fm8q0o9z","_id":"ckwk82j2t00179co3dmvkai9a"},{"post_id":"ckwk82j2h000h9co37r5z9y4v","tag_id":"ckwk82j2r00159co37cgwfekz","_id":"ckwk82j2t00199co3bl473661"},{"post_id":"ckwk82j2i000j9co30qfygqel","tag_id":"ckwk82j2n000r9co31eroenv1","_id":"ckwk82j2u001b9co344dx23j7"},{"post_id":"ckwk82j2j000l9co36zvf2epj","tag_id":"ckwk82j2t001a9co32j0zdxup","_id":"ckwk82j2u001d9co31ngr3inq"},{"post_id":"ckwk82j2k000m9co326pj7omv","tag_id":"ckwk82j2u001c9co331kf30xj","_id":"ckwk82j2u001f9co32vu2ej3n"},{"post_id":"ckwk82j2o000v9co30oee7iqp","tag_id":"ckwk82j2u001e9co38qoc1xw5","_id":"ckwk82j2u001h9co37rpmcn8e"},{"post_id":"ckwk82j2p000y9co3g9wd117p","tag_id":"ckwk82j2u001g9co33hsqhj3w","_id":"ckwk82j2v001j9co30izy7xnj"},{"post_id":"ckwk82j2q00109co3cix79x29","tag_id":"ckwk82j2v001i9co35pnr8g10","_id":"ckwk82j2v001l9co3dx90em4y"},{"post_id":"ckwk82j2q00129co33kp51eyx","tag_id":"ckwk82j2v001k9co3hyn8bz0g","_id":"ckwk82j2v001m9co39qsr576l"}],"Tag":[{"name":"css、BFC","_id":"ckwk82j2900029co38sv00944"},{"name":"javaScript、es6","_id":"ckwk82j2c00069co3hdrpedrn"},{"name":"blog、bash","_id":"ckwk82j2e000a9co349gc3fu7"},{"name":"javaScript","_id":"ckwk82j2g000e9co3fm8q0o9z"},{"name":"css","_id":"ckwk82j2i000i9co31fdz1p4y"},{"name":"vue","_id":"ckwk82j2n000r9co31eroenv1"},{"name":"js","_id":"ckwk82j2r00159co37cgwfekz"},{"name":"HTTP","_id":"ckwk82j2t001a9co32j0zdxup"},{"name":"vuex","_id":"ckwk82j2u001c9co331kf30xj"},{"name":"javaScript、css","_id":"ckwk82j2u001e9co38qoc1xw5"},{"name":"javaScript、Array","_id":"ckwk82j2u001g9co33hsqhj3w"},{"name":"css、盒模型","_id":"ckwk82j2v001i9co35pnr8g10"},{"name":"html、css","_id":"ckwk82j2v001k9co3hyn8bz0g"}]}}